---
phase: 12-recv-transport-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
  - android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
autonomous: true

must_haves:
  truths:
    - "RecvTransport created per channel with server ICE/DTLS parameters and onConnect callback bridges DTLS to signaling via runBlocking"
    - "Consumer created from remote producer on RecvTransport, resumed immediately for audio playback"
    - "Per-consumer volume control converts app 0.0-1.0 range to WebRTC 0.0-10.0 AudioTrack.setVolume()"
    - "Consumer.close() called before transport close on channel leave, no orphaned resources"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt"
      provides: "Real RecvTransport, Consumer, volume control, cleanup"
      contains: "device.createRecvTransport"
    - path: "android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt"
      provides: "Updated consumeAudio call with channelId parameter"
      contains: "mediasoupClient.consumeAudio(channelId"
  key_links:
    - from: "MediasoupClient.kt createRecvTransport"
      to: "SignalingClient.request(CREATE_TRANSPORT)"
      via: "suspend function call"
      pattern: "signalingClient\\.request.*CREATE_TRANSPORT"
    - from: "MediasoupClient.kt onConnect"
      to: "SignalingClient.request(CONNECT_TRANSPORT)"
      via: "runBlocking bridge from native thread"
      pattern: "runBlocking.*CONNECT_TRANSPORT"
    - from: "MediasoupClient.kt consumeAudio"
      to: "RecvTransport.consume()"
      via: "transport.consume with Consumer.Listener"
      pattern: "transport\\.consume"
    - from: "ChannelRepository.kt observeSpeakerChanges"
      to: "MediasoupClient.consumeAudio"
      via: "method call with channelId"
      pattern: "mediasoupClient\\.consumeAudio\\(channelId"
---

<objective>
Replace RecvTransport and Consumer TODO stubs in MediasoupClient with real libmediasoup-android library calls, implementing the complete receive audio path.

Purpose: Enable the Android app to receive remote audio producers via WebRTC RecvTransport, with per-consumer volume control and clean lifecycle management. This is the core receive path for hearing other users speak.

Output: MediasoupClient.kt with working RecvTransport creation, Consumer lifecycle, volume control via AudioTrack, and ordered cleanup. ChannelRepository updated for new consumeAudio signature.
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-recv-transport-integration/12-RESEARCH.md
@.planning/phases/11-library-upgrade-and-webrtc-foundation/11-02-SUMMARY.md
@android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
@android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace RecvTransport stub with real library calls and typed fields</name>
  <files>android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt</files>
  <action>
Replace the RecvTransport TODO stub code in MediasoupClient.kt with real libmediasoup-android library calls.

**Step 1: Update field types from Any? to real types.**
- Change `private var recvTransport: Any? = null` to `private val recvTransports = mutableMapOf<String, RecvTransport>()` (one RecvTransport per channel for multi-channel monitoring)
- Change `private val consumers = mutableMapOf<String, Any>()` to `private val consumers = mutableMapOf<String, Consumer>()`
- Add imports: `io.github.crow_misia.mediasoup.RecvTransport`, `io.github.crow_misia.mediasoup.Transport`, `io.github.crow_misia.mediasoup.Consumer`, `kotlinx.coroutines.runBlocking`, `org.webrtc.AudioTrack`

**Step 2: Replace createRecvTransport() TODO block (lines ~218-245) with real code.**
Uncomment and fix the TODO block to use real library calls:
```kotlin
val transport = device.createRecvTransport(
    listener = object : RecvTransport.Listener {
        override fun onConnect(transport: Transport, dtlsParameters: String) {
            Log.d(TAG, "RecvTransport onConnect: $transportId")
            runBlocking {
                signalingClient.request(
                    SignalingType.CONNECT_TRANSPORT,
                    mapOf(
                        "transportId" to transportId,
                        "dtlsParameters" to dtlsParameters
                    )
                )
            }
        }

        override fun onConnectionStateChange(
            transport: Transport,
            connectionState: String
        ) {
            Log.d(TAG, "RecvTransport state: $connectionState (channel: $channelId)")
            if (connectionState == "failed" || connectionState == "disconnected") {
                recvTransports.remove(channelId)
            }
        }
    },
    id = transportId,
    iceParameters = iceParameters,
    iceCandidates = iceCandidates,
    dtlsParameters = dtlsParameters,
    iceServers = null,
    peerConnectionOptions = null,
    appData = null
)
recvTransports[channelId] = transport
```

Key notes:
- `runBlocking` without dispatcher (runs on native JNI thread, acceptable for one-time DTLS setup 50-200ms)
- `onConnect` callback signature: `(Transport, String)` -- dtlsParameters is JSON string per Phase 11 discovery
- `onConnectionStateChange` uses `String` for connectionState (not enum), per crow-misia API
- Store transport in recvTransports map keyed by channelId

**Step 3: Update cleanup() method.**
Replace the recv transport cleanup section to iterate over recvTransports map:
```kotlin
// Step 4: Close all recv transports
recvTransports.values.forEach { it.close() }
recvTransports.clear()
```
Remove the old `recvTransport?.let { ... }; recvTransport = null` block.

Also update the consumers cleanup section to use typed Consumer.close():
```kotlin
// Step 2: Close all consumers
consumers.values.forEach { it.close() }
consumers.clear()
```

**IMPORTANT:** Do NOT modify sendTransport, startProducing, stopProducing, or sendAudioData methods -- those are Phase 13 scope. Only touch recv-related code and cleanup().

Verify that crow-misia RecvTransport.Listener interface methods match the expected signatures. If `onConnect` returns void (not String), remove any return statement. If `onConnectionStateChange` takes a different type, adapt accordingly. Log any API differences as deviations.
  </action>
  <verify>Run `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` and confirm BUILD SUCCESSFUL. Verify no TODO comments remain in createRecvTransport() method. Verify `recvTransports` field exists as `mutableMapOf<String, RecvTransport>()`.</verify>
  <done>RecvTransport created with real device.createRecvTransport() call, onConnect bridges DTLS to signaling via runBlocking, onConnectionStateChange logs state, transport stored per channel in recvTransports map, cleanup disposes all transports.</done>
</task>

<task type="auto">
  <name>Task 2: Replace Consumer stub with real library calls, volume control, and update ChannelRepository</name>
  <files>android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt, android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt</files>
  <action>
**Part A: Update consumeAudio() in MediasoupClient.kt**

Change the method signature to include channelId parameter:
```kotlin
suspend fun consumeAudio(channelId: String, producerId: String, peerId: String): String
```
The method now returns the consumerId string for tracking.

Replace the TODO block (lines ~292-311) with real library calls:
```kotlin
suspend fun consumeAudio(channelId: String, producerId: String, peerId: String): String = withContext(Dispatchers.IO) {
    try {
        Log.d(TAG, "Consuming audio: channel=$channelId, producer=$producerId, peer=$peerId")

        val consumeResponse = signalingClient.request(
            SignalingType.CONSUME,
            mapOf(
                "channelId" to channelId,
                "producerId" to producerId,
                "rtpCapabilities" to device.rtpCapabilities
            )
        )

        val consumeData = consumeResponse.data
            ?: throw IllegalStateException("No consume data in response")

        val consumerId = consumeData["id"] as? String
            ?: throw IllegalStateException("No consumer id")
        val kind = consumeData["kind"] as? String
            ?: throw IllegalStateException("No kind")
        val rtpParameters = toJsonString(consumeData["rtpParameters"])

        val transport = recvTransports[channelId]
            ?: throw IllegalStateException("RecvTransport not found for channel: $channelId")

        val consumer = transport.consume(
            listener = object : Consumer.Listener {
                override fun onTransportClose(consumer: Consumer) {
                    Log.d(TAG, "Consumer transport closed: $consumerId")
                    consumers.remove(consumerId)
                }
            },
            id = consumerId,
            producerId = producerId,
            kind = kind,
            rtpParameters = rtpParameters,
            appData = null
        )

        // CRITICAL: Resume consumer to start audio playback
        consumer.resume()

        consumers[consumerId] = consumer
        Log.d(TAG, "Consumer created and resumed: $consumerId")

        return@withContext consumerId

    } catch (e: Exception) {
        Log.e(TAG, "Failed to consume audio", e)
        throw e
    }
}
```

Key notes:
- Send `rtpCapabilities` (JSON string from device) in CONSUME request so server can validate codec compatibility
- `transport.consume()` parameters: listener, id, producerId, kind, rtpParameters, appData (all strings per Phase 11 discovery)
- `consumer.resume()` is CRITICAL -- consumer starts paused, no audio without it
- Returns consumerId for caller tracking

**Part B: Update setConsumerVolume() in MediasoupClient.kt**

Replace the TODO stub with real AudioTrack volume control:
```kotlin
fun setConsumerVolume(consumerId: String, volume: Float) {
    consumers[consumerId]?.let { consumer ->
        val audioTrack = consumer.track as? AudioTrack
        if (audioTrack != null) {
            // Convert 0.0-1.0 app range to 0.0-10.0 WebRTC range
            val webRtcVolume = (volume.coerceIn(0f, 1f) * 10.0)
            audioTrack.setVolume(webRtcVolume)
            Log.d(TAG, "Consumer volume set: $consumerId -> $volume (WebRTC: $webRtcVolume)")
        } else {
            Log.w(TAG, "Consumer track is not AudioTrack: $consumerId")
        }
    } ?: Log.w(TAG, "Consumer not found for volume control: $consumerId")
}
```

Note: Import `org.webrtc.AudioTrack` (not android.media.AudioTrack). The `consumer.track` property returns `org.webrtc.MediaStreamTrack`, cast to `org.webrtc.AudioTrack` for `setVolume()`.

**Part C: Update closeConsumer() in MediasoupClient.kt**

Replace the TODO stub:
```kotlin
fun closeConsumer(consumerId: String) {
    consumers.remove(consumerId)?.let { consumer ->
        consumer.close()
        Log.d(TAG, "Consumer closed: $consumerId")
    }
}
```

**Part D: Add cleanupChannel() method to MediasoupClient.kt**

Add a per-channel cleanup method for use when leaving a channel (closes consumers first, then transport):
```kotlin
fun cleanupChannel(channelId: String) {
    Log.d(TAG, "Cleaning up channel: $channelId")

    // Close consumers first (releases AudioTrack references)
    val consumersToRemove = consumers.entries.filter { (_, consumer) ->
        // Check if consumer belongs to this channel's transport
        true // We remove all consumers tracked by ChannelRepository per channel
    }

    // Close RecvTransport for channel
    recvTransports.remove(channelId)?.let { transport ->
        transport.close()
        Log.d(TAG, "RecvTransport closed for channel: $channelId")
    }
}
```

**Part E: Update ChannelRepository.kt callsites**

Update all `mediasoupClient.consumeAudio(producerId, speakerUserId)` calls to include channelId:
1. In `observeSpeakerChangesForChannel()` (~line 496): change to `mediasoupClient.consumeAudio(channelId, producerId, speakerUserId)`
2. In `unmuteChannel()` (~line 605): change to `mediasoupClient.consumeAudio(channelId, producerId, speakerId)`

Also update `leaveChannel()` to call `mediasoupClient.cleanupChannel(channelId)` after closing consumers (before the mediasoupClient.cleanup() call for last channel).

Verify that compile succeeds after ALL changes. If `consumer.track` returns a type other than expected, adapt the cast. If `AudioTrack` from `org.webrtc` does not have `setVolume`, check the actual method name (might be `setVolume(double)` instead of `setVolume(float)`).
  </action>
  <verify>Run `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` and confirm BUILD SUCCESSFUL. Verify no TODO comments remain in consumeAudio(), closeConsumer(), or setConsumerVolume(). Grep for `consumer.resume()` to confirm it exists. Grep for `consumeAudio(channelId` in ChannelRepository.kt to confirm updated callsites.</verify>
  <done>Consumer created with real transport.consume() call, resumed immediately for audio, volume control converts 0-1 to 0-10 via AudioTrack.setVolume(), closeConsumer disposes properly, ChannelRepository passes channelId to consumeAudio, cleanupChannel method available for per-channel disposal.</done>
</task>

</tasks>

<verification>
1. `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` â€” BUILD SUCCESSFUL
2. No TODO comments remain in createRecvTransport(), consumeAudio(), closeConsumer(), setConsumerVolume()
3. `grep -c "device.createRecvTransport" MediasoupClient.kt` returns 1+
4. `grep -c "transport.consume" MediasoupClient.kt` returns 1+
5. `grep -c "consumer.resume()" MediasoupClient.kt` returns 1+
6. `grep -c "audioTrack.setVolume" MediasoupClient.kt` returns 1+
7. `grep "consumeAudio(channelId" ChannelRepository.kt` confirms updated callsites
8. `grep "recvTransports" MediasoupClient.kt` shows map usage (not single var)
</verification>

<success_criteria>
- MediasoupClient.createRecvTransport() creates real RecvTransport with onConnect callback using runBlocking bridge
- MediasoupClient.consumeAudio() creates real Consumer, resumes it, stores reference
- MediasoupClient.setConsumerVolume() uses AudioTrack.setVolume(0-10) with range conversion
- MediasoupClient.closeConsumer() calls Consumer.close()
- MediasoupClient.cleanup() disposes all consumers then all transports in correct order
- ChannelRepository passes channelId to consumeAudio()
- Gradle compileDebugKotlin succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/12-recv-transport-integration/12-01-SUMMARY.md`
</output>
