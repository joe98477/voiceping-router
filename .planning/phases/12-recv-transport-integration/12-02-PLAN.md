---
phase: 12-recv-transport-integration
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
  - android/app/src/main/java/com/voiceping/android/domain/model/ConsumerNetworkStats.kt
  - android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListViewModel.kt
autonomous: true

must_haves:
  truths:
    - "Consumer statistics available via getConsumerStats() returning packet loss and jitter metrics"
    - "Network quality polling runs every 5 seconds for active consumers"
    - "Network quality indicator data exposed to UI via ViewModel StateFlow"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt"
      provides: "getConsumerStats() method returning parsed RTC statistics"
      contains: "getConsumerStats"
    - path: "android/app/src/main/java/com/voiceping/android/domain/model/ConsumerNetworkStats.kt"
      provides: "Data class for network quality metrics"
      contains: "data class ConsumerNetworkStats"
    - path: "android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListViewModel.kt"
      provides: "Network quality polling and StateFlow exposure"
      contains: "networkQuality"
  key_links:
    - from: "ChannelListViewModel.kt"
      to: "MediasoupClient.getConsumerStats"
      via: "viewModelScope.launch polling loop"
      pattern: "mediasoupClient\\.getConsumerStats"
    - from: "MediasoupClient.getConsumerStats"
      to: "Consumer.stats"
      via: "RTCStatsReport parsing"
      pattern: "consumer\\.stats"
---

<objective>
Add consumer statistics retrieval to MediasoupClient and wire network quality polling in ChannelListViewModel for displaying packet loss and jitter indicators.

Purpose: Enable users to see network quality indicators (Good/Fair/Poor) for active audio consumers, helping diagnose audio issues and providing confidence in connection quality during critical communications.

Output: getConsumerStats() method in MediasoupClient, ConsumerNetworkStats data class, network quality polling in ChannelListViewModel with StateFlow exposure.
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-recv-transport-integration/12-RESEARCH.md
@.planning/phases/12-recv-transport-integration/12-01-SUMMARY.md
@android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
@android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListViewModel.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getConsumerStats() to MediasoupClient and create ConsumerNetworkStats data class</name>
  <files>android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt, android/app/src/main/java/com/voiceping/android/domain/model/ConsumerNetworkStats.kt</files>
  <action>
**Part A: Create ConsumerNetworkStats data class.**

Create new file `android/app/src/main/java/com/voiceping/android/domain/model/ConsumerNetworkStats.kt`:
```kotlin
package com.voiceping.android.domain.model

/**
 * Network quality metrics from WebRTC consumer statistics.
 * Parsed from RTCStatsReport inbound-rtp entries.
 *
 * @param packetsLost Cumulative packets lost
 * @param jitter Inter-arrival jitter in seconds (convert to ms for display)
 * @param packetsReceived Total packets received (for loss percentage calc)
 * @param indicator Quality indicator: "Good", "Fair", or "Poor"
 */
data class ConsumerNetworkStats(
    val packetsLost: Long = 0,
    val jitter: Double = 0.0,
    val packetsReceived: Long = 0,
    val indicator: String = "Good"
) {
    val lossPercentage: Double
        get() = if (packetsReceived + packetsLost > 0) {
            (packetsLost.toDouble() / (packetsReceived + packetsLost)) * 100.0
        } else 0.0

    val jitterMs: Int
        get() = (jitter * 1000).toInt()

    companion object {
        fun calculateIndicator(packetsLost: Long, jitterMs: Int): String = when {
            packetsLost < 10 && jitterMs < 30 -> "Good"
            packetsLost < 50 && jitterMs < 100 -> "Fair"
            else -> "Poor"
        }
    }
}
```

**Part B: Add getConsumerStats() to MediasoupClient.kt.**

Add this method after the existing setConsumerVolume() method:
```kotlin
/**
 * Get consumer statistics for network quality indicator.
 *
 * Parses RTCStatsReport from Consumer.getStats() to extract:
 * - packetsLost: Cumulative packets lost
 * - jitter: Packet arrival time variance
 * - packetsReceived: Total packets received
 *
 * @param consumerId Consumer ID to get stats for
 * @return ConsumerNetworkStats or null if consumer not found or stats unavailable
 */
suspend fun getConsumerStats(consumerId: String): ConsumerNetworkStats? = withContext(Dispatchers.IO) {
    consumers[consumerId]?.let { consumer ->
        try {
            val stats = consumer.stats
            var packetsLost = 0L
            var jitter = 0.0
            var packetsReceived = 0L

            // Parse RTCStatsReport — iterate statsMap for inbound-rtp entries
            stats.statsMap.forEach { (_, report) ->
                if (report.type == "inbound-rtp") {
                    packetsLost = (report.members["packetsLost"] as? Number)?.toLong() ?: 0L
                    jitter = (report.members["jitter"] as? Number)?.toDouble() ?: 0.0
                    packetsReceived = (report.members["packetsReceived"] as? Number)?.toLong() ?: 0L
                }
            }

            val jitterMs = (jitter * 1000).toInt()
            val indicator = ConsumerNetworkStats.calculateIndicator(packetsLost, jitterMs)

            return@withContext ConsumerNetworkStats(
                packetsLost = packetsLost,
                jitter = jitter,
                packetsReceived = packetsReceived,
                indicator = indicator
            )
        } catch (e: Exception) {
            Log.e(TAG, "Failed to get consumer stats: $consumerId", e)
            null
        }
    }
}
```

Add import for ConsumerNetworkStats at top of file:
```kotlin
import com.voiceping.android.domain.model.ConsumerNetworkStats
```

**IMPORTANT:** The `consumer.stats` property return type may vary. If it returns a JSON string instead of RTCStatsReport object (per Phase 11 pattern of JSON strings), parse it with Gson:
```kotlin
val statsJson = consumer.stats
val statsMap = gson.fromJson<Map<String, Any>>(statsJson, object : TypeToken<Map<String, Any>>() {}.type)
```
Adapt the parsing logic based on actual return type discovered during compilation.

If `consumer.stats` is not a property but a method (`consumer.getStats()`), use the method form. If it requires a callback pattern, wrap in `suspendCancellableCoroutine`.
  </action>
  <verify>Run `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` and confirm BUILD SUCCESSFUL. Verify `ConsumerNetworkStats.kt` exists with data class. Verify `getConsumerStats` method exists in MediasoupClient.kt.</verify>
  <done>ConsumerNetworkStats data class created with packetsLost, jitter, packetsReceived, and indicator fields. getConsumerStats() method in MediasoupClient parses RTCStatsReport for inbound-rtp metrics.</done>
</task>

<task type="auto">
  <name>Task 2: Wire network quality polling in ChannelListViewModel</name>
  <files>android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListViewModel.kt</files>
  <action>
Add network quality monitoring to ChannelListViewModel.

**Step 1: Add network quality state.**

Add a StateFlow for network quality data:
```kotlin
// Network quality per channel: channelId -> ConsumerNetworkStats
private val _networkQuality = MutableStateFlow<Map<String, ConsumerNetworkStats>>(emptyMap())
val networkQuality: StateFlow<Map<String, ConsumerNetworkStats>> = _networkQuality.asStateFlow()
```

Add import for ConsumerNetworkStats:
```kotlin
import com.voiceping.android.domain.model.ConsumerNetworkStats
```

**Step 2: Add polling job tracking.**

Add a map for active polling jobs:
```kotlin
private val networkQualityJobs = mutableMapOf<String, Job>()
```

**Step 3: Add start/stop polling methods.**

```kotlin
/**
 * Start polling network quality for a channel's active consumer.
 * Polls every 5 seconds while the consumer is active.
 */
private fun startNetworkQualityPolling(channelId: String, consumerId: String) {
    // Cancel existing polling for this channel
    networkQualityJobs[channelId]?.cancel()

    networkQualityJobs[channelId] = viewModelScope.launch {
        while (isActive) {
            delay(5000) // Poll every 5 seconds

            mediasoupClient.getConsumerStats(consumerId)?.let { stats ->
                _networkQuality.update { current ->
                    current + (channelId to stats)
                }
            }
        }
    }
}

/**
 * Stop polling network quality for a channel.
 */
private fun stopNetworkQualityPolling(channelId: String) {
    networkQualityJobs[channelId]?.cancel()
    networkQualityJobs.remove(channelId)
    _networkQuality.update { it - channelId }
}
```

**Step 4: Wire polling to channel monitoring lifecycle.**

In the existing channel observation logic, look for where speaker changes are handled:
- When a new speaker starts (consumer created): call `startNetworkQualityPolling(channelId, consumerId)`
- When speaker stops (consumer closed): call `stopNetworkQualityPolling(channelId)`
- When channel is left: call `stopNetworkQualityPolling(channelId)`

Find the appropriate location in ChannelListViewModel. The speaker changes are observed via `channelRepository.monitoredChannels` StateFlow. Add network quality polling start/stop by observing the monitoredChannels changes for currentSpeaker and consumerId fields.

If there's no direct consumer ID tracking in the ViewModel (since ChannelRepository manages consumers), add the polling start in a `monitoredChannels.collect` block:
- When `state.currentSpeaker != null && state.consumerId != null` and no active polling for this channel -> start polling
- When `state.currentSpeaker == null` and active polling exists -> stop polling

**Step 5: Clean up on ViewModel clear.**

Add to the existing `onCleared()` method (or create one):
```kotlin
override fun onCleared() {
    super.onCleared()
    networkQualityJobs.values.forEach { it.cancel() }
    networkQualityJobs.clear()
}
```

Add import for `kotlinx.coroutines.Job` and `kotlinx.coroutines.delay` if not already present.

NOTE: The UI component (ChannelListScreen) will observe `networkQuality` StateFlow in a future phase. For now, just expose the data. Do NOT modify ChannelListScreen.kt in this plan.
  </action>
  <verify>Run `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` and confirm BUILD SUCCESSFUL. Verify `networkQuality` StateFlow exists in ChannelListViewModel. Verify `startNetworkQualityPolling` and `stopNetworkQualityPolling` methods exist. Verify `onCleared()` cleans up polling jobs.</verify>
  <done>ChannelListViewModel exposes networkQuality StateFlow with per-channel ConsumerNetworkStats, polls every 5 seconds for active consumers, cleans up on speaker stop and ViewModel clear.</done>
</task>

</tasks>

<verification>
1. `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` — BUILD SUCCESSFUL
2. `ConsumerNetworkStats.kt` exists with data class containing packetsLost, jitter, packetsReceived, indicator
3. `grep "getConsumerStats" MediasoupClient.kt` returns method definition
4. `grep "networkQuality" ChannelListViewModel.kt` returns StateFlow declaration
5. `grep "startNetworkQualityPolling" ChannelListViewModel.kt` returns method definition
6. `grep "onCleared" ChannelListViewModel.kt` confirms cleanup exists
</verification>

<success_criteria>
- MediasoupClient.getConsumerStats() returns parsed ConsumerNetworkStats from RTCStatsReport
- ConsumerNetworkStats has packetsLost, jitter, packetsReceived, indicator, lossPercentage, jitterMs
- ChannelListViewModel polls getConsumerStats every 5 seconds for active consumers
- ChannelListViewModel exposes networkQuality StateFlow for UI consumption
- Polling starts when speaker active, stops when speaker stops or channel left
- Polling jobs cleaned up in onCleared()
- Gradle compileDebugKotlin succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/12-recv-transport-integration/12-02-SUMMARY.md`
</output>
