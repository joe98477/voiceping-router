---
phase: 01-webrtc-audio-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/server/signaling/websocketServer.ts
  - src/server/signaling/handlers.ts
  - src/server/index.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket server accepts connections with JWT authentication"
    - "Signaling messages are routed to correct handlers based on type"
    - "Client can request router capabilities and create transports via signaling"
    - "PTT start/stop messages acquire/release speaker locks"
    - "Speaker change events are broadcast to all channel participants"
  artifacts:
    - path: "src/server/signaling/websocketServer.ts"
      provides: "WebSocket server with JWT auth and message routing"
      exports: ["SignalingServer"]
      min_lines: 60
    - path: "src/server/signaling/handlers.ts"
      provides: "Message handlers for all signaling types"
      exports: ["SignalingHandlers"]
      min_lines: 120
    - path: "src/server/index.ts"
      provides: "Complete server entry point with all subsystems initialized"
      min_lines: 40
  key_links:
    - from: "src/server/signaling/websocketServer.ts"
      to: "src/shared/protocol.ts"
      via: "Parses incoming messages using SignalingType"
      pattern: "SignalingType"
    - from: "src/server/signaling/handlers.ts"
      to: "src/server/mediasoup/transportManager.ts"
      via: "Creates transports on CREATE_TRANSPORT message"
      pattern: "createWebRtcTransport"
    - from: "src/server/signaling/handlers.ts"
      to: "src/server/state/channelState.ts"
      via: "Starts/stops PTT via channel state manager"
      pattern: "startPtt|stopPtt"
    - from: "src/server/signaling/handlers.ts"
      to: "src/server/state/sessionStore.ts"
      via: "Tracks user sessions on connect/disconnect"
      pattern: "addSession|removeSession"
    - from: "src/server/index.ts"
      to: "src/server/mediasoup/workerPool.ts"
      via: "Initializes worker pool on startup"
      pattern: "workerPool\\.init"
---

<objective>
Implement the WebSocket signaling server that orchestrates WebRTC connections and PTT operations. This is the glue that connects clients to the mediasoup SFU and Redis state -- handling authentication, transport negotiation, and PTT start/stop flows.

Purpose: Clients cannot directly interact with mediasoup or Redis. The signaling server translates client requests (via WebSocket JSON messages) into mediasoup transport operations and Redis state changes. Per user decision, this is a dedicated WebSocket channel for WebRTC signaling.

Output: A complete signaling server that handles the full PTT lifecycle: join channel, create transports, produce/consume audio, PTT start/stop.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-webrtc-audio-foundation/01-RESEARCH.md
@.planning/phases/01-webrtc-audio-foundation/01-01-SUMMARY.md
@.planning/phases/01-webrtc-audio-foundation/01-02-SUMMARY.md
@.planning/phases/01-webrtc-audio-foundation/01-03-SUMMARY.md
@src/shared/protocol.ts
@src/shared/types.ts
@src/server/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: WebSocket signaling server with authentication</name>
  <files>
    src/server/signaling/websocketServer.ts
  </files>
  <action>
    Create `src/server/signaling/websocketServer.ts`:

    Class `SignalingServer` that manages WebSocket connections and message routing.

    **Constructor:**
    - Takes HTTP server instance, a `SignalingHandlers` instance
    - Creates `ws.WebSocketServer` attached to the HTTP server at path `/ws` (dedicated signaling path per user decision)

    **Connection handling:**
    - `verifyClient(info, callback)`: Extract JWT token from:
      1. `info.req.headers.authorization` (Bearer token)
      2. `info.req.url` query param `?token=xxx`
      3. `sec-websocket-protocol` header (legacy compatibility with existing client)
    - Decode JWT using jsonwebtoken.verify() with config.auth.jwtSecret
    - On valid token: attach `userId` and `userName` to the request object, callback(true)
    - On invalid/expired token: callback(false, 401, 'Unauthorized')

    **Message routing:**
    - On `connection` event: Log new connection with userId, create client context object `{ ws, userId, userName, channels: Set<string> }`
    - On `message` event: Parse JSON, extract `type` field, validate it's a known `SignalingType`
    - Route to corresponding handler method on the `SignalingHandlers` instance
    - Use request-response pattern: messages with `id` field get responses with same `id` for correlation
    - On `close` event: Call handlers.handleDisconnect() for cleanup
    - On `error` event: Log error, close connection

    **Utility methods:**
    - `sendToClient(ws, message: SignalingMessage)`: JSON.stringify and send
    - `broadcastToChannel(channelId: string, message: SignalingMessage, excludeUserId?: string)`: Send to all connected clients in a channel (iterate tracked connections)
    - `getConnectedClients()`: Return count for health check
    - Track clients in a Map<string, ClientContext> keyed by `${userId}:${connectionId}`

    **Heartbeat:**
    - Implement ping/pong interval (30s) to detect dead connections
    - On pong timeout: close connection, trigger disconnect cleanup
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - SignalingServer class exports and can be instantiated with mock params
    - JWT verification logic handles all three token locations
  </verify>
  <done>
    WebSocket signaling server authenticates via JWT, parses signaling messages by type, routes to handlers, supports request-response correlation via message IDs, and implements heartbeat for dead connection detection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Signaling handlers and server entry point wiring</name>
  <files>
    src/server/signaling/handlers.ts
    src/server/index.ts
  </files>
  <action>
    1. Create `src/server/signaling/handlers.ts`:

    Class `SignalingHandlers` that implements all signaling message handlers. Constructor takes: `RouterManager`, `TransportManager`, `ProducerConsumerManager`, `ChannelStateManager`, `SessionStore`, and a `broadcastToChannel` callback function.

    **Handler methods (one per SignalingType):**

    - `handleJoinChannel(ctx, data: { channelId })`:
      - Add user to channel in SessionStore
      - Get or create router for channel
      - Subscribe to channel state events
      - Respond with current channel state
      - Broadcast `CHANNEL_STATE` to existing channel members (new user joined)

    - `handleLeaveChannel(ctx, data: { channelId })`:
      - Remove user from channel in SessionStore
      - Close user's transports/producers/consumers for that channel
      - Unsubscribe from channel events
      - If user was speaking: release speaker lock
      - Broadcast updated channel state

    - `handleGetRouterCapabilities(ctx, data: { channelId })`:
      - Return router RTP capabilities for the channel
      - Client needs this to initialize mediasoup Device

    - `handleCreateTransport(ctx, data: { channelId, direction: 'send' | 'recv' })`:
      - Create WebRTC transport via TransportManager
      - Return TransportOptions (id, iceParameters, iceCandidates, dtlsParameters)

    - `handleConnectTransport(ctx, data: { transportId, dtlsParameters })`:
      - Connect transport DTLS layer
      - Return success/failure

    - `handleProduce(ctx, data: { transportId, kind, rtpParameters, channelId })`:
      - Create producer on transport
      - Return producer ID
      - Producer starts paused (PTT not active)

    - `handleConsume(ctx, data: { channelId, producerId })`:
      - Create consumer for the producer
      - Return consumer info (id, producerId, kind, rtpParameters)

    - `handlePttStart(ctx, data: { channelId })`:
      - Call ChannelStateManager.startPtt()
      - If acquired: resume producer, broadcast SPEAKER_CHANGED to channel
      - If denied: send PTT_DENIED to requesting client with current speaker info (per locked decision: "visual message showing [username] is speaking")

    - `handlePttStop(ctx, data: { channelId })`:
      - Call ChannelStateManager.stopPtt()
      - Pause producer
      - Broadcast SPEAKER_CHANGED (no active speaker) to channel

    - `handlePing(ctx)`:
      - Respond with PONG (application-level heartbeat)

    - `handleDisconnect(ctx)`:
      - Release any speaker locks held by user
      - Close all transports, producers, consumers for user
      - Remove user from all channels in SessionStore
      - Broadcast updated state to affected channels
      - Log disconnection

    **Error handling:**
    - Wrap each handler in try/catch
    - On error: send ERROR message back to client with error description
    - Log all errors with userId and channelId context

    2. Update `src/server/index.ts` to wire everything together:

    ```
    async function main() {
      // Initialize Redis
      await connectRedis();

      // Initialize mediasoup workers
      await workerPool.init();

      // Create managers
      const routerManager = new RouterManager(workerPool);
      const transportManager = new TransportManager(routerManager);
      const producerConsumerManager = new ProducerConsumerManager(transportManager);
      const channelStateManager = new ChannelStateManager(speakerLock);
      const sessionStore = new SessionStore();

      // Create HTTP server with health endpoint
      const server = http.createServer((req, res) => {
        if (req.url === '/health') {
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({
            status: 'ok',
            uptime: process.uptime(),
            workers: workerPool.getWorkerCount(),
            connections: signalingServer.getConnectedClients()
          }));
        } else {
          res.writeHead(404);
          res.end();
        }
      });

      // Create signaling handlers and server
      const handlers = new SignalingHandlers(
        routerManager, transportManager, producerConsumerManager,
        channelStateManager, sessionStore,
        (channelId, msg, excludeUserId) => signalingServer.broadcastToChannel(channelId, msg, excludeUserId)
      );
      const signalingServer = new SignalingServer(server, handlers);

      // Start server
      server.listen(config.server.port, config.server.host, () => {
        logger.info(`VoicePing audio server listening on ${config.server.host}:${config.server.port}`);
        logger.info(`mediasoup workers: ${workerPool.getWorkerCount()}`);
      });

      // Graceful shutdown
      process.on('SIGTERM', async () => { ... close everything ... });
      process.on('SIGINT', async () => { ... close everything ... });
    }

    main().catch(err => { logger.error('Fatal startup error', err); process.exit(1); });
    ```

    The server entry point initializes ALL subsystems in correct order and wires them together through dependency injection. Graceful shutdown closes WebSocket server, mediasoup workers, and Redis in reverse order.
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - `npm run dev` starts server (requires Redis running)
    - Health endpoint returns worker count and connection count
    - WebSocket connection at ws://localhost:3000/ws requires JWT token
    - Unauthenticated connection gets rejected with 401
  </verify>
  <done>
    All signaling message types have handlers. Server entry point wires mediasoup, Redis state, and signaling together. Server starts, authenticates connections, and routes messages to correct handlers. Graceful shutdown implemented.
  </done>
</task>

</tasks>

<verification>
1. Server starts with `npm run dev` (Redis must be running)
2. `/health` endpoint returns status with worker and connection counts
3. WebSocket connection rejected without valid JWT
4. WebSocket connection accepted with valid JWT
5. Send `{ "type": "ping", "id": "1" }` via WebSocket, receive `{ "type": "pong", "id": "1" }`
6. All signaling types from protocol.ts have corresponding handlers
</verification>

<success_criteria>
- WebSocket server authenticates via JWT from header, query param, or protocol header
- All 15 SignalingType values have handler implementations
- PTT start acquires speaker lock, PTT stop releases it
- PTT denied returns current speaker info to blocked client
- Disconnect triggers full cleanup (locks, transports, sessions)
- Server entry point initializes mediasoup, Redis, and signaling in correct order
- Graceful shutdown closes all resources
</success_criteria>

<output>
After completion, create `.planning/phases/01-webrtc-audio-foundation/01-04-SUMMARY.md`
</output>
