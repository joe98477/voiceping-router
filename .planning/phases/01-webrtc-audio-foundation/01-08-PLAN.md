---
phase: 01-webrtc-audio-foundation
plan: 08
type: execute
wave: 5
depends_on: ["01-06", "01-07"]
files_modified:
  - Dockerfile
  - docker-compose.yml
  - src/client/test/pttDemo.html
  - src/client/test/pttDemo.ts
  - scripts/generate-test-token.ts
autonomous: false

must_haves:
  truths:
    - "User can press PTT button and transmit audio that another user hears"
    - "Audio latency is under 300ms from button press to hearing audio"
    - "PTT works in Chrome, Firefox, and Safari desktop browsers"
    - "Busy channel blocks second user with tone and speaker name display"
    - "WebSocket reconnects after simulated network disruption"
  artifacts:
    - path: "Dockerfile"
      provides: "Docker image for mediasoup audio server"
      contains: "mediasoup"
    - path: "docker-compose.yml"
      provides: "Docker Compose with audio server, Redis, and Postgres"
      contains: "mediasoup"
    - path: "src/client/test/pttDemo.html"
      provides: "Test page for end-to-end PTT verification"
      min_lines: 30
    - path: "src/client/test/pttDemo.ts"
      provides: "Test page client code exercising full PTT pipeline"
      min_lines: 50
    - path: "scripts/generate-test-token.ts"
      provides: "Utility to generate JWT tokens for testing"
      min_lines: 15
  key_links:
    - from: "src/client/test/pttDemo.ts"
      to: "src/client/connectionManager.ts"
      via: "Uses ConnectionManager to establish PTT session"
      pattern: "ConnectionManager"
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "Builds audio server from Dockerfile"
      pattern: "build.*Dockerfile|context"
    - from: "scripts/generate-test-token.ts"
      to: "src/server/config.ts"
      via: "Uses same JWT secret for token generation"
      pattern: "ROUTER_JWT_SECRET"
---

<objective>
Create Docker deployment configuration, a test demo page exercising the full PTT pipeline end-to-end, and verify all Phase 1 success criteria: audio transmission, latency under 300ms, cross-browser compatibility, busy state handling, and WebSocket reconnection.

Purpose: This is the integration and verification plan. Everything built in Plans 01-07 gets wired together and proven working. The test demo page serves as both validation and a reference implementation for Phase 3's browser UI.

Output: Docker deployment, working PTT demo page, cross-browser verification.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-webrtc-audio-foundation/01-CONTEXT.md
@.planning/phases/01-webrtc-audio-foundation/01-RESEARCH.md
@.planning/phases/01-webrtc-audio-foundation/01-01-SUMMARY.md
@.planning/phases/01-webrtc-audio-foundation/01-04-SUMMARY.md
@.planning/phases/01-webrtc-audio-foundation/01-06-SUMMARY.md
@.planning/phases/01-webrtc-audio-foundation/01-07-SUMMARY.md
@Dockerfile
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Docker deployment and test utilities</name>
  <files>
    Dockerfile
    docker-compose.yml
    scripts/generate-test-token.ts
  </files>
  <action>
    1. Update `Dockerfile` for the new mediasoup-based audio server:
       - Base image: `node:20-bullseye` (Debian Bullseye for mediasoup C++ compilation)
       - mediasoup requires build tools: `apt-get install -y python3 make gcc g++` (for native addon compilation)
       - Working directory: `/app`
       - Copy `package.json` and `package-lock.json`, run `npm ci --production` (production deps only)
       - For dev stage: `npm ci` (include dev deps for building)
       - Multi-stage build:
         - Stage 1 (builder): Install all deps, run `npm run build` (tsc compilation)
         - Stage 2 (production): Copy only dist/, node_modules (production), package.json
       - Expose ports: 3000 (HTTP/WebSocket), 40000-49999/udp (mediasoup RTC)
       - CMD: `["node", "dist/server/index.js"]`
       - Health check: `HEALTHCHECK CMD curl -f http://localhost:3000/health || exit 1`
       - IMPORTANT: The existing Dockerfile is for the OLD vp-router. Read it first, then replace with the new one. Keep the same general Docker conventions but update for mediasoup.

    2. Update `docker-compose.yml` to include the audio server alongside existing services:
       - Read existing docker-compose.yml first to understand current service structure
       - Add/update `audio-server` service (replacing old vp-router service):
         - Build from root Dockerfile
         - Ports: `3000:3000`, `40000-49999:40000-49999/udp`
         - Environment: from .env file
         - Depends on: redis, postgres
         - Network: shared network with control-plane and web-ui
         - Restart: unless-stopped
       - Ensure Redis service exists (it should from existing compose)
       - Ensure Postgres service exists (it should from existing compose)
       - Add `MEDIASOUP_ANNOUNCED_IP` env var (set to host IP for Docker networking)

    3. Create `scripts/generate-test-token.ts`:
       - Import `jsonwebtoken` and sign a test token
       - Accept command-line args: `--userId <id> --userName <name> --secret <secret>`
       - Default: userId='test-user-1', userName='Test User', secret from env ROUTER_JWT_SECRET
       - Generate JWT with: `{ userId, userName, exp: Math.floor(Date.now()/1000) + 3600 }` (1 hour expiry)
       - Print token to stdout
       - Usage: `tsx scripts/generate-test-token.ts --userId user1 --userName "Alice"`
       - Also generate a second token for user2 (for two-user PTT testing)
  </action>
  <verify>
    - `docker build -t voiceping-audio .` completes successfully
    - `docker compose up -d redis postgres` starts infrastructure
    - `tsx scripts/generate-test-token.ts` outputs a valid JWT
    - JWT decodes correctly with the configured secret
  </verify>
  <done>
    Docker image builds with mediasoup native addon. Docker Compose runs audio server with Redis and Postgres. Test token generator creates JWTs for testing.
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end PTT demo page</name>
  <files>
    src/client/test/pttDemo.html
    src/client/test/pttDemo.ts
  </files>
  <action>
    1. Create `src/client/test/pttDemo.html`:
       - Minimal HTML page for testing the full PTT pipeline
       - Two user panels side by side (simulating two users in same channel)
       - Each panel has:
         - Connection status indicator (green/yellow/red dot + text)
         - Channel name display
         - Current speaker display ("[username] is speaking" or "Channel free")
         - PTT button (large, centered)
         - Mode toggle (hold-to-talk vs toggle)
         - Audio output area (for received audio)
       - At top: Token input fields (paste JWT for each user) and channel ID input
       - Connect/Disconnect buttons for each user
       - Latency display section:
         - Current RTT (from WebSocket ping/pong)
         - Last PTT latency (button press to audio received)
       - Logging console at bottom (shows all signaling messages, state changes)
       - Include bundled client script (reference pttDemo.ts)
       - Basic styling: flexbox layout, no framework needed, just functional
       - Serve this page via the HTTP server on a `/test` route

    2. Create `src/client/test/pttDemo.ts`:
       - Import `ConnectionManager` from client modules
       - Two ConnectionManager instances (one per user panel)

       **User Panel setup:**
       - Read token and channel ID from input fields
       - On "Connect" click: `connectionManager.connect()`
       - Wire connection state changes to UI indicator
       - Wire PTT button to container element in panel

       **Latency measurement:**
       - Record `performance.now()` when PTT button pressed
       - Record `performance.now()` when other panel's audio starts playing
       - Display difference as "PTT Latency: Xms"
       - Use MutationObserver or audio element's `playing` event to detect audio start
       - Log measurements to console

       **Logging:**
       - Intercept all signaling messages (both directions) and display in log console
       - Show timestamps, message types, and data summaries
       - Color-code: green for success, red for errors, yellow for warnings

       **Test scenarios this page enables:**
       1. Two-user PTT: User 1 presses PTT, User 2 hears audio
       2. Busy channel: User 1 transmitting, User 2 presses PTT -> busy feedback
       3. Reconnection: Disconnect User 1's WebSocket, observe reconnection
       4. Toggle mode: Switch to toggle, verify click-to-start/click-to-stop
       5. Latency measurement: Measure button-press to audio-heard time

    3. Update `src/server/index.ts` to serve the test page:
       - Add route handler: GET `/test` serves `pttDemo.html`
       - Add static file serving for client JS bundle and audio files
       - Only serve test page in development mode (NODE_ENV !== 'production')

    NOTE: For the client-side bundle, use a simple approach:
    - The test page can use ES module imports if served with correct MIME types
    - Or use esbuild/vite to bundle client code (add esbuild as devDependency if needed)
    - The goal is a WORKING test page, not a production build system (Phase 3 handles proper UI build)
  </action>
  <verify>
    - Server starts and serves test page at http://localhost:3000/test
    - Page loads without JavaScript errors
    - Two user panels display with connection controls
    - Both users can connect with valid JWT tokens
    - PTT button is visible and responds to mouse events
  </verify>
  <done>
    End-to-end test page enables two users to connect to the same channel, transmit PTT audio, observe busy state handling, measure latency, and test reconnection. All signaling messages are logged for debugging.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Cross-browser PTT verification</name>
  <what-built>
    Complete PTT audio system: mediasoup SFU server, WebSocket signaling, Redis speaker locks, client audio pipeline, PTT button with hold-to-talk and toggle modes, audio feedback tones, reconnection with exponential backoff, Docker deployment, and test demo page.
  </what-built>
  <how-to-verify>
    Start the system:
    1. Ensure Redis is running (locally or via Docker: `docker compose up -d redis`)
    2. Start the audio server: `npm run dev`
    3. Generate test tokens: `tsx scripts/generate-test-token.ts --userId user1 --userName "Alice"` and `tsx scripts/generate-test-token.ts --userId user2 --userName "Bob"`

    Open test page and verify in Chrome first:
    4. Open http://localhost:3000/test in Chrome
    5. Paste User 1 token, set channel "test-channel", click Connect
    6. Open a second browser tab/window for User 2
    7. Paste User 2 token, same channel, click Connect
    8. Both panels should show "Connected" (green indicator)

    Test PTT functionality:
    9. User 1: Click and hold PTT button
       - EXPECTED: Button changes to transmitting state, audio tone plays
    10. User 2: Should hear User 1's microphone audio
       - EXPECTED: Audio plays, speaker indicator shows "Alice is speaking"
    11. User 1: Release PTT button
       - EXPECTED: Audio stops, stop tone plays, channel shows "free"
    12. While User 1 is transmitting: User 2 presses PTT
       - EXPECTED: Busy tone plays, "Alice is speaking" shown, PTT blocked

    Test toggle mode:
    13. Switch User 1 to toggle mode
    14. Single click PTT: should start transmitting
    15. Single click again: should stop transmitting

    Test latency:
    16. Check latency display on the test page
       - EXPECTED: Under 300ms from button press to audio heard

    Test reconnection:
    17. While connected, open Chrome DevTools -> Network -> Offline mode
    18. Wait 5 seconds, disable offline mode
       - EXPECTED: Connection indicator goes yellow (reconnecting), then green (reconnected)
       - EXPECTED: PTT still works after reconnection

    Cross-browser testing:
    19. Repeat steps 4-12 in Firefox
    20. Repeat steps 4-12 in Safari (macOS)
       - Note any differences or issues

    Verify Docker deployment:
    21. `docker compose up -d` starts all services
    22. Test page accessible at http://localhost:3000/test
    23. PTT works through Docker (same as local testing)
  </how-to-verify>
  <resume-signal>Type "approved" if all Phase 1 success criteria pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
Phase 1 Success Criteria from Roadmap:
1. User can press button to transmit audio and hear received audio in real-time
2. Audio transmission latency measures under 300ms from button press to hearing audio
3. Audio works across Chrome, Firefox, and Safari desktop browsers
4. User receives visual feedback when PTT is blocked due to busy channel
5. WebSocket connection automatically reconnects after temporary network loss
</verification>

<success_criteria>
- Docker builds and runs the mediasoup audio server
- Test demo page loads and enables two-user PTT testing
- Audio transmits from speaker to listener in real-time
- Latency under 300ms verified via test page measurement
- Busy channel correctly blocks with tone and speaker name
- WebSocket reconnects with exponential backoff after network loss
- PTT works in Chrome, Firefox, and Safari desktop browsers
</success_criteria>

<output>
After completion, create `.planning/phases/01-webrtc-audio-foundation/01-08-SUMMARY.md`
</output>
