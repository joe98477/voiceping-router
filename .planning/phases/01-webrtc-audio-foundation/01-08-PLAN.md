---
phase: 01-webrtc-audio-foundation
plan: 08
type: execute
wave: 5
depends_on: ["01-06", "01-07"]
files_modified:
  - Dockerfile
  - docker-compose.yml
  - deploy/nginx/nginx.conf
  - deploy/nginx/generate-self-signed-cert.sh
  - src/client/test/pttDemo.html
  - src/client/test/pttDemo.ts
  - scripts/generate-test-token.ts
autonomous: false

must_haves:
  truths:
    - "User can press PTT button and transmit audio that another user hears"
    - "Audio latency is under 300ms from button press to hearing audio"
    - "PTT works in Chrome, Firefox, and Safari desktop browsers"
    - "Busy channel blocks second user with tone and speaker name display"
    - "WebSocket reconnects after simulated network disruption"
    - "WebSocket connections use WSS (TLS/SSL) via nginx reverse proxy in Docker deployment"
  artifacts:
    - path: "Dockerfile"
      provides: "Docker image for mediasoup audio server"
      contains: "mediasoup"
    - path: "docker-compose.yml"
      provides: "Docker Compose with audio server, nginx TLS proxy, Redis, and Postgres"
      contains: "nginx"
    - path: "deploy/nginx/nginx.conf"
      provides: "Nginx config with TLS termination and WebSocket proxy"
      contains: "ssl_certificate"
    - path: "deploy/nginx/generate-self-signed-cert.sh"
      provides: "Script to generate self-signed TLS certs for development"
      min_lines: 10
    - path: "src/client/test/pttDemo.html"
      provides: "Test page for end-to-end PTT verification"
      min_lines: 30
    - path: "src/client/test/pttDemo.ts"
      provides: "Test page client code exercising full PTT pipeline"
      min_lines: 50
    - path: "scripts/generate-test-token.ts"
      provides: "Utility to generate JWT tokens for testing"
      min_lines: 15
  key_links:
    - from: "src/client/test/pttDemo.ts"
      to: "src/client/connectionManager.ts"
      via: "Uses ConnectionManager to establish PTT session"
      pattern: "ConnectionManager"
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "Builds audio server from Dockerfile"
      pattern: "build.*Dockerfile|context"
    - from: "docker-compose.yml"
      to: "deploy/nginx/nginx.conf"
      via: "Mounts nginx config into nginx container"
      pattern: "nginx\\.conf"
    - from: "deploy/nginx/nginx.conf"
      to: "audio-server:3000"
      via: "Proxies WSS to WS on audio-server backend"
      pattern: "proxy_pass.*audio-server"
    - from: "scripts/generate-test-token.ts"
      to: "src/server/config.ts"
      via: "Uses same JWT secret for token generation"
      pattern: "ROUTER_JWT_SECRET"
---

<objective>
Create Docker deployment configuration with TLS-terminating nginx reverse proxy (satisfying SEC-02: WSS requirement), a test demo page exercising the full PTT pipeline end-to-end, and verify all Phase 1 success criteria: audio transmission, latency under 300ms, cross-browser compatibility, busy state handling, and WebSocket reconnection.

Purpose: This is the integration and verification plan. Everything built in Plans 01-07 gets wired together and proven working. The nginx reverse proxy ensures all WebSocket connections use WSS (TLS/SSL) in the Docker deployment, which is required by SEC-02 and is the standard production pattern for Node.js services. The test demo page serves as both validation and a reference implementation for Phase 3's browser UI.

Output: Docker deployment with WSS via nginx, working PTT demo page, cross-browser verification.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-webrtc-audio-foundation/01-CONTEXT.md
@.planning/phases/01-webrtc-audio-foundation/01-RESEARCH.md
@.planning/phases/01-webrtc-audio-foundation/01-01-SUMMARY.md
@.planning/phases/01-webrtc-audio-foundation/01-04-SUMMARY.md
@.planning/phases/01-webrtc-audio-foundation/01-06-SUMMARY.md
@.planning/phases/01-webrtc-audio-foundation/01-07-SUMMARY.md
@Dockerfile
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Docker deployment with TLS-terminating nginx proxy and test utilities</name>
  <files>
    Dockerfile
    docker-compose.yml
    deploy/nginx/nginx.conf
    deploy/nginx/generate-self-signed-cert.sh
    scripts/generate-test-token.ts
  </files>
  <action>
    1. Update `Dockerfile` for the new mediasoup-based audio server:
       - Base image: `node:20-bullseye` (Debian Bullseye for mediasoup C++ compilation)
       - mediasoup requires build tools: `apt-get install -y python3 make gcc g++` (for native addon compilation)
       - Working directory: `/app`
       - Copy `package.json` and `package-lock.json`, run `npm ci --production` (production deps only)
       - For dev stage: `npm ci` (include dev deps for building)
       - Multi-stage build:
         - Stage 1 (builder): Install all deps, run `npm run build` (tsc compilation)
         - Stage 2 (production): Copy only dist/, node_modules (production), package.json
       - Expose ports: 3000 (HTTP/WebSocket), 40000-49999/udp (mediasoup RTC)
       - CMD: `["node", "dist/server/index.js"]`
       - Health check: `HEALTHCHECK CMD curl -f http://localhost:3000/health || exit 1`
       - IMPORTANT: The existing Dockerfile is for the OLD vp-router. Read it first, then replace with the new one. Keep the same general Docker conventions but update for mediasoup.

    2. Create `deploy/nginx/nginx.conf` for TLS termination (SEC-02: WSS with TLS/SSL):
       - This nginx reverse proxy terminates TLS and proxies to the Node.js audio server over plain HTTP/WS internally. This is the standard production pattern -- the Node.js server does NOT handle TLS directly.
       - Listen on port 443 with SSL
       - Also listen on port 80 and redirect all HTTP to HTTPS
       - SSL certificate/key paths: `/etc/nginx/certs/server.crt` and `/etc/nginx/certs/server.key`
       - SSL protocols: TLSv1.2 TLSv1.3 (no older protocols)
       - SSL ciphers: modern cipher suite (ECDHE-ECDSA-AES128-GCM-SHA256, ECDHE-RSA-AES128-GCM-SHA256, etc.)
       - Proxy configuration for the audio server:
         ```
         location / {
             proxy_pass http://audio-server:3000;
             proxy_http_version 1.1;
             proxy_set_header Upgrade $http_upgrade;
             proxy_set_header Connection "upgrade";
             proxy_set_header Host $host;
             proxy_set_header X-Real-IP $remote_addr;
             proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
             proxy_set_header X-Forwarded-Proto $scheme;
             proxy_read_timeout 86400;  # 24h for long-lived WebSocket connections
             proxy_send_timeout 86400;
         }
         ```
       - The `Upgrade` and `Connection` headers are critical for WebSocket proxying (WS -> WSS)
       - Include `/health` passthrough to audio-server

    3. Create `deploy/nginx/generate-self-signed-cert.sh`:
       - Bash script to generate self-signed TLS certificates for development/testing
       - Uses `openssl req -x509 -nodes -days 365 -newkey rsa:2048` to generate cert and key
       - Output to `deploy/nginx/certs/server.crt` and `deploy/nginx/certs/server.key`
       - Subject: `/CN=localhost`
       - Add SAN (Subject Alternative Name) for `localhost` and `127.0.0.1`
       - Add `deploy/nginx/certs/` to `.gitignore` (never commit certs)
       - Make script executable
       - Print instructions: "Self-signed cert generated. Browsers will show security warning -- this is expected for development."

    4. Update `docker-compose.yml` to include the audio server AND nginx TLS proxy alongside existing services:
       - Read existing docker-compose.yml first to understand current service structure
       - Add/update `audio-server` service (replacing old vp-router service):
         - Build from root Dockerfile
         - Ports: Do NOT expose 3000 externally (nginx handles external traffic)
         - Expose: 3000 (internal Docker network only)
         - Port mapping for mediasoup RTC: `40000-49999:40000-49999/udp`
         - Environment: from .env file
         - Depends on: redis, postgres
         - Network: shared network with control-plane and web-ui
         - Restart: unless-stopped
       - Add `nginx` service for TLS termination (SEC-02):
         - Image: `nginx:1.25-alpine`
         - Ports: `443:443` (HTTPS/WSS), `80:80` (HTTP redirect to HTTPS)
         - Volumes:
           - `./deploy/nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro`
           - `./deploy/nginx/certs:/etc/nginx/certs:ro`
         - Depends on: audio-server
         - Network: same shared network
         - Restart: unless-stopped
       - Ensure Redis service exists (it should from existing compose)
       - Ensure Postgres service exists (it should from existing compose)
       - Add `MEDIASOUP_ANNOUNCED_IP` env var (set to host IP for Docker networking)

    5. Create `scripts/generate-test-token.ts`:
       - Import `jsonwebtoken` and sign a test token
       - Accept command-line args: `--userId <id> --userName <name> --secret <secret>`
       - Default: userId='test-user-1', userName='Test User', secret from env ROUTER_JWT_SECRET
       - Generate JWT with: `{ userId, userName, exp: Math.floor(Date.now()/1000) + 3600 }` (1 hour expiry)
       - Print token to stdout
       - Usage: `tsx scripts/generate-test-token.ts --userId user1 --userName "Alice"`
       - Also generate a second token for user2 (for two-user PTT testing)
  </action>
  <verify>
    - `docker build -t voiceping-audio .` completes successfully
    - `bash deploy/nginx/generate-self-signed-cert.sh` creates cert files in deploy/nginx/certs/
    - `docker compose up -d` starts audio-server, nginx, redis, and postgres
    - `curl -k https://localhost/health` returns 200 through nginx TLS proxy (the -k flag accepts self-signed cert)
    - `curl http://localhost` redirects to https://localhost (HTTP->HTTPS redirect)
    - `tsx scripts/generate-test-token.ts` outputs a valid JWT
    - JWT decodes correctly with the configured secret
  </verify>
  <done>
    Docker image builds with mediasoup native addon. Nginx reverse proxy terminates TLS and proxies WSS to WS on the audio server (SEC-02 satisfied). Docker Compose runs audio server, nginx, Redis, and Postgres. Self-signed cert generator enables local HTTPS/WSS testing. Test token generator creates JWTs for testing.
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end PTT demo page</name>
  <files>
    src/client/test/pttDemo.html
    src/client/test/pttDemo.ts
  </files>
  <action>
    1. Create `src/client/test/pttDemo.html`:
       - Minimal HTML page for testing the full PTT pipeline
       - Two user panels side by side (simulating two users in same channel)
       - Each panel has:
         - Connection status indicator (green/yellow/red dot + text)
         - Channel name display
         - Current speaker display ("[username] is speaking" or "Channel free")
         - PTT button (large, centered)
         - Mode toggle (hold-to-talk vs toggle)
         - Audio output area (for received audio)
       - At top: Token input fields (paste JWT for each user) and channel ID input
       - Connect/Disconnect buttons for each user
       - Server URL input (default: `wss://localhost/ws` for TLS, with option to switch to `ws://localhost:3000/ws` for direct dev mode)
       - Latency display section:
         - Current RTT (from WebSocket ping/pong)
         - Last PTT latency (button press to audio received)
       - Logging console at bottom (shows all signaling messages, state changes)
       - Include bundled client script (reference pttDemo.ts)
       - Basic styling: flexbox layout, no framework needed, just functional
       - Serve this page via the HTTP server on a `/test` route

    2. Create `src/client/test/pttDemo.ts`:
       - Import `ConnectionManager` from client modules
       - Two ConnectionManager instances (one per user panel)

       **User Panel setup:**
       - Read token and channel ID from input fields
       - On "Connect" click: `connectionManager.connect()`
       - Wire connection state changes to UI indicator
       - Wire PTT button to container element in panel

       **Latency measurement:**
       - Record `performance.now()` when PTT button pressed
       - Record `performance.now()` when other panel's audio starts playing
       - Display difference as "PTT Latency: Xms"
       - Use MutationObserver or audio element's `playing` event to detect audio start
       - Log measurements to console

       **Logging:**
       - Intercept all signaling messages (both directions) and display in log console
       - Show timestamps, message types, and data summaries
       - Color-code: green for success, red for errors, yellow for warnings

       **Test scenarios this page enables:**
       1. Two-user PTT: User 1 presses PTT, User 2 hears audio
       2. Busy channel: User 1 transmitting, User 2 presses PTT -> busy feedback
       3. Reconnection: Disconnect User 1's WebSocket, observe reconnection
       4. Toggle mode: Switch to toggle, verify click-to-start/click-to-stop
       5. Latency measurement: Measure button-press to audio-heard time
       6. WSS verification: Connect via wss://localhost/ws through nginx proxy

    3. Update `src/server/index.ts` to serve the test page:
       - Add route handler: GET `/test` serves `pttDemo.html`
       - Add static file serving for client JS bundle and audio files
       - Only serve test page in development mode (NODE_ENV !== 'production')

    NOTE: For the client-side bundle, use a simple approach:
    - The test page can use ES module imports if served with correct MIME types
    - Or use esbuild/vite to bundle client code (add esbuild as devDependency if needed)
    - The goal is a WORKING test page, not a production build system (Phase 3 handles proper UI build)
  </action>
  <verify>
    - Server starts and serves test page at http://localhost:3000/test
    - Page loads without JavaScript errors
    - Two user panels display with connection controls
    - Both users can connect with valid JWT tokens
    - PTT button is visible and responds to mouse events
    - Server URL field defaults to wss://localhost/ws
  </verify>
  <done>
    End-to-end test page enables two users to connect to the same channel, transmit PTT audio, observe busy state handling, measure latency, and test reconnection. Supports both WSS (via nginx) and direct WS (dev mode) connections. All signaling messages are logged for debugging.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Cross-browser PTT verification</name>
  <what-built>
    Complete PTT audio system: mediasoup SFU server, WebSocket signaling, Redis speaker locks, client audio pipeline, PTT button with hold-to-talk and toggle modes, audio feedback tones, reconnection with exponential backoff, Docker deployment with nginx TLS proxy (WSS), and test demo page.
  </what-built>
  <how-to-verify>
    Start the system:
    1. Generate self-signed TLS cert: `bash deploy/nginx/generate-self-signed-cert.sh`
    2. Start all services: `docker compose up -d` (starts redis, postgres, audio-server, nginx)
    3. Generate test tokens: `tsx scripts/generate-test-token.ts --userId user1 --userName "Alice"` and `tsx scripts/generate-test-token.ts --userId user2 --userName "Bob"`

    Verify WSS/TLS works (SEC-02):
    4. Open https://localhost in Chrome (accept self-signed cert warning)
    5. Verify the connection is HTTPS (lock icon in address bar, even if with cert warning)
    6. Open https://localhost/test for the test page

    Open test page and verify in Chrome first:
    7. Paste User 1 token, set channel "test-channel", ensure server URL is `wss://localhost/ws`
    8. Click Connect -- connection should succeed over WSS
    9. Open a second browser tab/window for User 2
    10. Paste User 2 token, same channel, click Connect
    11. Both panels should show "Connected" (green indicator)

    Test PTT functionality:
    12. User 1: Click and hold PTT button
       - EXPECTED: Button changes to transmitting state, audio tone plays
    13. User 2: Should hear User 1's microphone audio
       - EXPECTED: Audio plays, speaker indicator shows "Alice is speaking"
    14. User 1: Release PTT button
       - EXPECTED: Audio stops, stop tone plays, channel shows "free"
    15. While User 1 is transmitting: User 2 presses PTT
       - EXPECTED: Busy tone plays, "Alice is speaking" shown, PTT blocked

    Test toggle mode:
    16. Switch User 1 to toggle mode
    17. Single click PTT: should start transmitting
    18. Single click again: should stop transmitting

    Test latency:
    19. Check latency display on the test page
       - EXPECTED: Under 300ms from button press to audio heard

    Test reconnection:
    20. While connected, open Chrome DevTools -> Network -> Offline mode
    21. Wait 5 seconds, disable offline mode
       - EXPECTED: Connection indicator goes yellow (reconnecting), then green (reconnected)
       - EXPECTED: PTT still works after reconnection

    Cross-browser testing:
    22. Repeat steps 7-15 in Firefox
    23. Repeat steps 7-15 in Safari (macOS)
       - Note any differences or issues

    Verify Docker deployment:
    24. `docker compose ps` shows audio-server, nginx, redis, postgres all running
    25. `curl -k https://localhost/health` returns healthy status through nginx
    26. PTT works through Docker with WSS (same as above testing)
  </how-to-verify>
  <resume-signal>Type "approved" if all Phase 1 success criteria pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
Phase 1 Success Criteria from Roadmap:
1. User can press button to transmit audio and hear received audio in real-time
2. Audio transmission latency measures under 300ms from button press to hearing audio
3. Audio works across Chrome, Firefox, and Safari desktop browsers
4. User receives visual feedback when PTT is blocked due to busy channel
5. WebSocket connection automatically reconnects after temporary network loss

SEC-02 Verification:
6. WebSocket connections use WSS (TLS/SSL) via nginx reverse proxy -- verified by connecting to wss://localhost/ws through HTTPS
</verification>

<success_criteria>
- Docker builds and runs the mediasoup audio server
- Nginx reverse proxy terminates TLS and proxies WSS to audio server (SEC-02)
- Self-signed cert generator works for development testing
- Test demo page loads and enables two-user PTT testing over WSS
- Audio transmits from speaker to listener in real-time
- Latency under 300ms verified via test page measurement
- Busy channel correctly blocks with tone and speaker name
- WebSocket reconnects with exponential backoff after network loss
- PTT works in Chrome, Firefox, and Safari desktop browsers
</success_criteria>

<output>
After completion, create `.planning/phases/01-webrtc-audio-foundation/01-08-SUMMARY.md`
</output>
