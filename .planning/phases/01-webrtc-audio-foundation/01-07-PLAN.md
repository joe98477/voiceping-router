---
phase: 01-webrtc-audio-foundation
plan: 07
type: execute
wave: 4
depends_on: ["01-04", "01-05"]
files_modified:
  - src/client/signaling/reconnectingClient.ts
  - src/client/connectionManager.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket automatically reconnects after network loss"
    - "Reconnection uses exponential backoff (1s, 2s, 4s... up to 30s)"
    - "After reconnection, user session is restored (channels, transports)"
    - "User sees connection status indicator during reconnection"
  artifacts:
    - path: "src/client/signaling/reconnectingClient.ts"
      provides: "WebSocket reconnection wrapper with exponential backoff"
      exports: ["ReconnectingSignalingClient"]
      min_lines: 60
    - path: "src/client/connectionManager.ts"
      provides: "High-level connection lifecycle and recovery orchestration"
      exports: ["ConnectionManager"]
      min_lines: 80
  key_links:
    - from: "src/client/signaling/reconnectingClient.ts"
      to: "src/client/signaling/signalingClient.ts"
      via: "Wraps SignalingClient with reconnection"
      pattern: "SignalingClient"
    - from: "src/client/connectionManager.ts"
      to: "src/client/mediasoup/transportClient.ts"
      via: "Recreates transports after reconnection"
      pattern: "createSendTransport|createRecvTransport"
    - from: "src/client/connectionManager.ts"
      to: "src/client/pttController.ts"
      via: "Reinitializes PTT after reconnection"
      pattern: "PttController|init"
---

<objective>
Implement WebSocket reconnection with exponential backoff and session recovery after network loss. This ensures the PTT system remains operational through temporary network disruptions.

Purpose: Phase 1 success criteria #5 requires "WebSocket connection automatically reconnects after temporary network loss." PTT users are often on mobile devices at events with unreliable connectivity. Automatic recovery without user intervention is critical.

Output: Reconnecting WebSocket wrapper and connection manager that restores full PTT functionality after disconnection.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-webrtc-audio-foundation/01-RESEARCH.md
@.planning/phases/01-webrtc-audio-foundation/01-01-SUMMARY.md
@.planning/phases/01-webrtc-audio-foundation/01-05-SUMMARY.md
@src/shared/protocol.ts
@src/shared/types.ts
@src/client/signaling/signalingClient.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Reconnecting WebSocket client</name>
  <files>
    src/client/signaling/reconnectingClient.ts
  </files>
  <action>
    Create `src/client/signaling/reconnectingClient.ts`:

    Class `ReconnectingSignalingClient` that wraps `SignalingClient` with automatic reconnection.

    Per research Pattern 6: Exponential backoff with max delay cap.

    **Configuration:**
    - `initialDelay`: 1000ms (1 second)
    - `maxDelay`: 30000ms (30 seconds)
    - `maxAttempts`: Infinity (always try to reconnect -- PTT is critical)
    - `backoffMultiplier`: 2 (double each attempt)
    - `jitter`: true (add random 0-500ms to prevent thundering herd)

    **State tracking:**
    - `connectionState`: 'connected' | 'connecting' | 'reconnecting' | 'disconnected'
    - `reconnectAttempts`: number (resets to 0 on successful connect)
    - `currentDelay`: number (tracks current backoff delay)

    **Core reconnection logic:**
    - On WebSocket `close` event (non-clean close, i.e., `!event.wasClean`):
      1. Set state to 'reconnecting'
      2. Emit 'stateChange' event with new state
      3. Calculate delay: `min(initialDelay * 2^attempts + jitter, maxDelay)`
      4. Schedule reconnection after delay
      5. Log: "Reconnecting in {delay}ms (attempt {n})"

    - On WebSocket `close` event (clean close, user-initiated):
      1. Set state to 'disconnected'
      2. Do NOT attempt reconnection

    - On successful reconnection:
      1. Reset attempts to 0
      2. Reset delay to initialDelay
      3. Set state to 'connected'
      4. Emit 'reconnected' event (ConnectionManager listens to this for session recovery)

    **API (delegates to underlying SignalingClient):**
    - All SignalingClient methods are proxied through (request, joinChannel, pttStart, etc.)
    - `on('stateChange', callback)`: Notifies of connection state changes
    - `on('reconnected', callback)`: Fires when reconnection succeeds
    - `on('reconnectFailed', callback)`: Fires when max attempts reached (not used with Infinity, but available)
    - `disconnect()`: Intentional disconnect -- sets flag to prevent reconnection, closes WebSocket cleanly

    **Edge cases:**
    - If reconnection attempt fails (connect() throws): schedule another attempt with increased delay
    - If user calls disconnect() during reconnection: cancel pending reconnect timer
    - If multiple close events fire: deduplicate (only one reconnection cycle at a time)
    - Track reconnection timer ID for cancellation: `clearTimeout(this.reconnectTimer)`

    **Message queueing (optional but useful):**
    - Queue messages sent during reconnection
    - Replay queued messages on successful reconnect
    - Limit queue size (100 messages max) to prevent memory issues
    - Drop PTT_START/PTT_STOP messages older than 2 seconds (stale PTT state)
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - Backoff calculation: 1s, 2s, 4s, 8s, 16s, 30s, 30s... (capped at 30s)
    - Clean close does NOT trigger reconnection
    - Unclean close triggers reconnection with backoff
    - disconnect() cancels any pending reconnection
  </verify>
  <done>
    ReconnectingSignalingClient wraps SignalingClient with automatic reconnection using exponential backoff. Handles clean vs unclean disconnects, supports intentional disconnect, queues messages during reconnection, and emits state change events for UI feedback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Connection manager for full session recovery</name>
  <files>
    src/client/connectionManager.ts
  </files>
  <action>
    Create `src/client/connectionManager.ts`:

    Class `ConnectionManager` that orchestrates the full connection lifecycle including initial setup, reconnection recovery, and cleanup.

    **Constructor takes:**
    - WebSocket URL
    - JWT token
    - Options: `{ channelId, pttMode, onStateChange, onError }`

    **Initial connection flow (`async connect()`):**
    1. Create `ReconnectingSignalingClient` with URL and token
    2. Connect to server
    3. Create `MediasoupDevice` and load with server capabilities
    4. Create `MicrophoneManager` and request audio track
    5. Create `TransportClient` with device and signaling
    6. Create `AudioFeedback` and preload tones
    7. Create `PttButton` attached to provided container element
    8. Create `PttController` wiring everything together
    9. Initialize PttController (creates transports, produces audio)
    10. Join channel via signaling
    11. Register reconnection handler
    12. Set state to 'ready'

    **Reconnection recovery (`async onReconnected()`):**
    When the reconnecting client fires 'reconnected':
    1. Log: "Connection restored, recovering session..."
    2. Re-join channel (server may have lost session)
    3. Re-load device with router capabilities (router may have changed)
    4. Close old transports (they're invalid after reconnection)
    5. Create new send/recv transports
    6. Re-produce audio on new send transport
    7. Re-create consumers for active speakers
    8. If user was transmitting before disconnect: re-acquire PTT lock
    9. Log: "Session recovered successfully"
    10. Emit state change: 'connected'

    **Connection state callbacks:**
    - `onStateChange(state)` callback with states:
      - `connecting`: Initial connection in progress
      - `connected`: Connected and ready for PTT
      - `reconnecting`: Connection lost, attempting reconnection
      - `error`: Fatal error (e.g., auth failure, no microphone)
    - UI can use this to show connection indicator (green/yellow/red dot, or status text)

    **Error handling:**
    - Auth failure (401): Do NOT reconnect. Set state to 'error'. Prompt user to re-login.
    - Microphone denied: Set state to 'error'. Show guidance.
    - Transport creation failure: Retry once, then set state to 'error'.
    - Server error: Let reconnecting client handle via backoff.

    **Cleanup (`async disconnect()`):**
    1. Destroy PttController (stops PTT, releases microphone)
    2. Leave channel via signaling
    3. Disconnect signaling client (clean close, no reconnection)
    4. Set state to 'disconnected'

    **Public API (facade for the entire client system):**
    - `async connect()`: Start everything
    - `async disconnect()`: Stop everything
    - `getConnectionState()`: Return current state
    - `getPttController()`: Access PTT controller for mode changes
    - `getChannelState()`: Return current channel state (who's speaking)
    - `isTransmitting()`: Check if user is currently transmitting
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - ConnectionManager creates all subsystems in correct order
    - Reconnection handler recreates transports and rejoins channel
    - Disconnect stops reconnection and cleans up all resources
    - State change callback fires for all state transitions
  </verify>
  <done>
    ConnectionManager provides a single entry point for the entire client-side PTT system. Handles initial connection, automatic session recovery after network loss (rejoins channels, recreates transports, restores PTT state), and clean shutdown. Connection state events enable UI status indicators.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles all connection modules
2. Reconnection uses exponential backoff (1s -> 2s -> 4s -> ... -> 30s cap)
3. Session recovery rejoins channels and recreates transports
4. Clean disconnect does not trigger reconnection
5. Connection state changes are emitted for UI consumption
6. Auth failure (401) is treated as fatal, not retried
</verification>

<success_criteria>
- WebSocket reconnects automatically after unclean disconnect
- Backoff is exponential with 30s cap and jitter
- Full session recovery after reconnection (channel, transports, PTT state)
- ConnectionManager is a single-entry-point facade for the entire client system
- Connection state changes visible to UI layer
- Intentional disconnect is clean (no reconnection attempts)
- Auth errors are fatal (no infinite retry on expired token)
</success_criteria>

<output>
After completion, create `.planning/phases/01-webrtc-audio-foundation/01-07-SUMMARY.md`
</output>
