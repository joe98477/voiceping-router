---
phase: 01-webrtc-audio-foundation
plan: 06
type: execute
wave: 4
depends_on: ["01-04", "01-05"]
files_modified:
  - src/client/ui/PttButton.ts
  - src/client/audio/feedback.ts
  - src/client/audio/tones/README.md
  - src/client/pttController.ts
  - public/audio/transmit-start.mp3
  - public/audio/transmit-stop.mp3
  - public/audio/busy-tone.mp3
autonomous: true

must_haves:
  truths:
    - "PTT button changes visual state when pressed (walkie-talkie feel)"
    - "Audio confirmation tone plays when transmission starts"
    - "Audio confirmation tone plays when transmission stops"
    - "Busy tone plays when channel is occupied by another speaker"
    - "Visual message shows '[username] is speaking' when PTT is blocked"
    - "Both hold-to-talk and toggle modes work"
    - "User can select preferred PTT mode"
  artifacts:
    - path: "src/client/ui/PttButton.ts"
      provides: "PTT button component with hold-to-talk and toggle modes"
      exports: ["PttButton"]
      min_lines: 80
    - path: "src/client/audio/feedback.ts"
      provides: "Audio feedback tone playback system"
      exports: ["AudioFeedback"]
      min_lines: 40
    - path: "src/client/pttController.ts"
      provides: "PTT orchestration connecting button, audio, signaling, and state"
      exports: ["PttController"]
      min_lines: 100
  key_links:
    - from: "src/client/pttController.ts"
      to: "src/client/signaling/signalingClient.ts"
      via: "Sends PTT_START/PTT_STOP via signaling"
      pattern: "pttStart|pttStop"
    - from: "src/client/pttController.ts"
      to: "src/client/audio/feedback.ts"
      via: "Plays tones on PTT events"
      pattern: "feedback\\.play"
    - from: "src/client/pttController.ts"
      to: "src/client/mediasoup/transportClient.ts"
      via: "Controls audio producer pause/resume"
      pattern: "produceAudio|muteTrack|unmuteTrack"
    - from: "src/client/ui/PttButton.ts"
      to: "src/client/pttController.ts"
      via: "Button events trigger controller methods"
      pattern: "onPttStart|onPttStop"
---

<objective>
Implement the complete PTT user experience: the PTT button with hold-to-talk and toggle modes, audio feedback tones (start/stop/busy), busy state visual indicators, and the PTT controller that orchestrates everything. This implements ALL user-facing PTT behavior per locked decisions.

Purpose: This is the user-facing heart of the system. Per locked decisions, the button must feel like a physical walkie-talkie with immediate visual response, audio confirmation tones, and clear busy state feedback showing who is speaking.

Output: PTT button component, audio feedback system, and PTT controller that ties button input to signaling, audio, and visual feedback.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-webrtc-audio-foundation/01-CONTEXT.md
@.planning/phases/01-webrtc-audio-foundation/01-RESEARCH.md
@.planning/phases/01-webrtc-audio-foundation/01-01-SUMMARY.md
@.planning/phases/01-webrtc-audio-foundation/01-05-SUMMARY.md
@src/shared/types.ts
@src/shared/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audio feedback system and PTT button component</name>
  <files>
    src/client/audio/feedback.ts
    src/client/ui/PttButton.ts
    public/audio/transmit-start.mp3
    public/audio/transmit-stop.mp3
    public/audio/busy-tone.mp3
  </files>
  <action>
    1. Create `src/client/audio/feedback.ts`:

    Class `AudioFeedback` for playing PTT audio feedback tones.

    Per locked decision: Audio confirmation tones on transmission start, stop, and busy. Audio prompts configurable via audio files in specific folder/naming structure.

    **Tone configuration:**
    - Define tone file path pattern: `/audio/{toneName}.mp3`
    - Default tones: `transmit-start`, `transmit-stop`, `busy-tone`
    - Constructor accepts optional base path override (supports per-event/client customization per user's specific idea)

    **Preloading:**
    - `async preload()`: Create `HTMLAudioElement` for each tone, call `.load()`, set volume to 0.7
    - Store in Map<string, HTMLAudioElement>
    - Handle preload failures gracefully (log warning, don't crash -- audio feedback is nice-to-have)

    **Playback:**
    - `play(toneName: string)`: Reset to start (`currentTime = 0`), play. Use `.play().catch()` to handle autoplay restrictions
    - Handle browser autoplay policy: first user interaction unlocks audio context. If play() fails with NotAllowedError, queue for later
    - `setVolume(volume: number)`: Set volume 0-1 for all tones
    - `mute()` / `unmute()`: Toggle all tone playback

    **Custom tones:**
    - `registerTone(name: string, url: string)`: Add custom tone at runtime
    - Per user's specific idea: "admin-uploadable audio files with specific folder/naming convention"
    - Folder convention: `/audio/events/{eventId}/{toneName}.mp3` for event-specific overrides
    - Load from event-specific path first, fall back to default `/audio/{toneName}.mp3`

    2. Create placeholder audio files. Since we can't generate real MP3s, create a simple utility that generates placeholder tones:
    - Create `public/audio/` directory
    - Write a small script `scripts/generate-placeholder-tones.ts` that uses Web Audio API patterns (or just document the expected files)
    - For now, create empty placeholder files at `public/audio/transmit-start.mp3`, `public/audio/transmit-stop.mp3`, `public/audio/busy-tone.mp3` so the AudioFeedback class can attempt to load them
    - Add a README at `public/audio/README.md` documenting:
      - Expected file naming convention
      - How to add event-specific tones
      - Recommended tone duration (100-500ms) and format (MP3, 44.1kHz)

    3. Create `src/client/ui/PttButton.ts`:

    Class `PttButton` implementing the PTT button with both interaction modes.

    Per locked decisions:
    - Support hold-to-talk (press and hold) AND toggle (click on/off)
    - User preference setting to choose mode
    - Mouse/touch only (no keyboard shortcuts in Phase 1)
    - Button feels like physical walkie-talkie (tactile, immediate response)
    - Shows "[username] is speaking" when blocked

    **State machine:**
    - States (from shared types PttState): IDLE, TRANSMITTING, BLOCKED
    - Transitions:
      - IDLE -> TRANSMITTING: User activates PTT (press or toggle on)
      - TRANSMITTING -> IDLE: User deactivates PTT (release or toggle off)
      - IDLE -> BLOCKED: User activates PTT but channel busy
      - BLOCKED -> IDLE: Auto-return after brief display

    **Hold-to-talk mode:**
    - `mousedown` / `touchstart`: Fire `onPttStart` callback
    - `mouseup` / `touchend` / `mouseleave`: Fire `onPttStop` callback
    - Prevent default touch behavior to avoid scrolling during PTT
    - Handle edge case: mouse leaves button while held (treat as release)

    **Toggle mode:**
    - `click` / `touchend`: Toggle between start and stop
    - First click: Fire `onPttStart`
    - Second click: Fire `onPttStop`
    - Track toggle state internally

    **Visual state (CSS classes, not inline styles -- classes are defined, actual CSS in web-ui):**
    - IDLE: `ptt-idle` class (default button appearance)
    - TRANSMITTING: `ptt-transmitting` class (active/pressed appearance)
    - BLOCKED: `ptt-blocked` class (error/warning appearance)

    **API:**
    - Constructor takes container element and options `{ mode: PttMode, onPttStart, onPttStop }`
    - `setMode(mode: PttMode)`: Switch between hold and toggle
    - `setState(state: PttState, speakerInfo?: { name: string })`: Update visual state
    - `setEnabled(enabled: boolean)`: Enable/disable button
    - `getState()`: Return current PttState
    - `destroy()`: Remove all event listeners

    **Busy state display:**
    - When state set to BLOCKED with speakerInfo: show "[username] is speaking" text element below button
    - Auto-clear after 3 seconds (return to IDLE)
    - Per locked decision: "Visual message showing [username] is speaking"

    This is a vanilla TypeScript class, NOT a React component. It manages DOM directly. It will be wrapped in React for the web-ui in Phase 3. Keep it framework-agnostic for reusability.
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - AudioFeedback class exports and has play/preload/registerTone methods
    - PttButton handles mousedown/mouseup for hold mode and click for toggle mode
    - PttButton state machine covers IDLE, TRANSMITTING, BLOCKED transitions
    - `public/audio/` directory exists with placeholder files
  </verify>
  <done>
    AudioFeedback system plays configurable tones with preloading and autoplay handling. PTT button supports hold-to-talk and toggle modes with walkie-talkie visual feedback. Busy state shows "[username] is speaking". Both are framework-agnostic TypeScript classes.
  </done>
</task>

<task type="auto">
  <name>Task 2: PTT controller orchestrating all components</name>
  <files>
    src/client/pttController.ts
  </files>
  <action>
    Create `src/client/pttController.ts`:

    Class `PttController` that orchestrates the complete PTT flow, connecting the button UI, audio feedback, signaling client, transport client, and microphone manager.

    **Constructor takes:**
    - `SignalingClient` instance
    - `TransportClient` instance
    - `MicrophoneManager` instance
    - `AudioFeedback` instance
    - `PttButton` instance
    - Options: `{ channelId: string, pttMode: PttMode }`

    **Initialization:**
    - `async init()`:
      1. Preload audio feedback tones
      2. Request microphone permission (MicrophoneManager.checkPermission)
      3. If permission not granted: show guidance to user (via callback/event)
      4. Get audio track from microphone
      5. Create send transport via TransportClient
      6. Produce audio (paused) on send transport
      7. Create receive transport
      8. Wire PttButton callbacks to PTT start/stop handlers
      9. Subscribe to server push events (SPEAKER_CHANGED, PTT_DENIED)
      10. Enable PTT button

    **PTT Start flow (called when user activates button):**
    1. Immediately update button visual to TRANSMITTING (instant feedback per locked decision)
    2. Play transmit-start tone
    3. Send PTT_START via signaling
    4. If server responds success: unmute microphone track (audio flows)
    5. If server responds denied (PTT_DENIED):
       - Play busy tone
       - Update button to BLOCKED with speaker name
       - Show "[username] is speaking" (per locked decision)
       - Mute microphone track (ensure no audio leaks)
       - Auto-revert button to IDLE after 3 seconds

    **PTT Stop flow (called when user deactivates button):**
    1. Mute microphone track immediately (stop audio before server confirms)
    2. Play transmit-stop tone
    3. Send PTT_STOP via signaling
    4. Update button visual to IDLE

    **Server push event handlers:**
    - `SPEAKER_CHANGED`: Update local state, notify UI of new speaker
    - `PTT_DENIED`: Handle denial (busy tone, blocked state, speaker info)
    - `CHANNEL_STATE`: Update full channel state

    **Audio consumption (receiving audio from others):**
    - `async startListening()`:
      - On `SPEAKER_CHANGED` when another user starts: create consumer for their producer
      - Attach consumer's audio track to an HTML Audio element for playback
      - On `SPEAKER_CHANGED` when speaker stops: optionally cleanup consumer
    - Manage a Map of active consumers (producerId -> { consumer, audioElement })
    - Create audio elements dynamically, set autoplay, attach track via `srcObject`

    **Mode switching:**
    - `setMode(mode: PttMode)`: Update button mode and store preference
    - Read initial mode from options

    **Cleanup:**
    - `async destroy()`:
      - Stop PTT if active
      - Close all consumers and their audio elements
      - Release microphone
      - Close transports
      - Destroy button
      - Remove all event listeners

    **Error handling:**
    - Wrap all async operations in try/catch
    - On signaling error: revert button state, show error via callback
    - On transport error: attempt reconnection (basic -- Plan 07 adds robust reconnection)
    - On microphone error: disable PTT button, show guidance

    IMPORTANT: The PTT start flow must feel INSTANT. Visual feedback and audio tone happen BEFORE the server response. If the server denies, we revert. This "optimistic UI" approach makes the button feel like a physical walkie-talkie per the user's specific idea.
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - PttController wires button events to signaling + audio + feedback
    - PTT start plays tone and updates UI BEFORE server response (optimistic)
    - PTT denied reverts UI and plays busy tone
    - Audio consumption creates HTML Audio elements for playback
    - Cleanup releases all resources
  </verify>
  <done>
    PttController orchestrates the complete PTT flow: button press -> instant visual/audio feedback -> server signaling -> lock acquisition -> audio streaming -> button release -> cleanup. Handles both success and denial (busy) paths. Manages audio consumption from other speakers. Supports hold-to-talk and toggle modes per user preference.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles all PTT modules
2. AudioFeedback preloads and plays tones
3. PttButton supports hold and toggle modes
4. PttController connects button -> signaling -> audio pipeline
5. Busy state shows speaker name
6. Visual feedback is immediate (before server response)
7. Audio consumption plays received audio through HTML Audio elements
</verification>

<success_criteria>
- PTT button visual changes instantly on press (walkie-talkie feel)
- Audio tones play on start, stop, and busy
- Hold-to-talk works: press=start, release=stop
- Toggle works: click=start, click again=stop
- Busy channel shows "[username] is speaking"
- Busy channel plays distinct busy tone
- Audio from other speakers plays through browser
- Audio prompts use configurable file paths with naming convention
- All resources cleaned up on destroy
</success_criteria>

<output>
After completion, create `.planning/phases/01-webrtc-audio-foundation/01-06-SUMMARY.md`
</output>
