---
phase: 01-webrtc-audio-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/server/state/redisClient.ts
  - src/server/state/speakerLock.ts
  - src/server/state/channelState.ts
  - src/server/state/sessionStore.ts
autonomous: true

must_haves:
  truths:
    - "Redis client connects and performs basic operations"
    - "Speaker lock is acquired atomically with TTL expiration"
    - "Only one user can hold the speaker lock per channel"
    - "Lock auto-expires after TTL to prevent deadlocks"
    - "Channel state tracks current speaker and busy status"
  artifacts:
    - path: "src/server/state/redisClient.ts"
      provides: "Redis v4 async client connection"
      exports: ["redisClient", "connectRedis"]
      min_lines: 20
    - path: "src/server/state/speakerLock.ts"
      provides: "Distributed speaker lock with atomic NX/EX"
      exports: ["acquireSpeakerLock", "releaseSpeakerLock"]
      min_lines: 40
    - path: "src/server/state/channelState.ts"
      provides: "Channel busy state and speaker tracking"
      exports: ["ChannelStateManager"]
      min_lines: 40
    - path: "src/server/state/sessionStore.ts"
      provides: "User session tracking in Redis"
      exports: ["SessionStore"]
      min_lines: 30
  key_links:
    - from: "src/server/state/speakerLock.ts"
      to: "src/server/state/redisClient.ts"
      via: "Redis SET NX EX for atomic lock"
      pattern: "set.*NX.*EX|set.*{.*nx.*ex"
    - from: "src/server/state/channelState.ts"
      to: "src/server/state/speakerLock.ts"
      via: "Uses speaker lock for busy state"
      pattern: "acquireSpeakerLock|releaseSpeakerLock"
    - from: "src/server/state/speakerLock.ts"
      to: "src/shared/types.ts"
      via: "Returns SpeakerLockResult type"
      pattern: "SpeakerLockResult"
---

<objective>
Implement Redis-based real-time state management: async Redis client, distributed speaker lock with atomic acquisition, channel busy state tracking, and user session storage.

Purpose: PTT requires exclusive speaker access per channel -- only one person talks at a time. Redis distributed locks with atomic SET NX EX prevent race conditions where two users press PTT simultaneously. This is the state backbone for the entire PTT system.

Output: Four state management modules providing atomic speaker locks, channel state, and session tracking.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-webrtc-audio-foundation/01-RESEARCH.md
@.planning/phases/01-webrtc-audio-foundation/01-01-SUMMARY.md
@src/server/config.ts
@src/shared/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Redis client and distributed speaker lock</name>
  <files>
    src/server/state/redisClient.ts
    src/server/state/speakerLock.ts
  </files>
  <action>
    1. Create `src/server/state/redisClient.ts`:
       - Use Redis v4 async client (`import { createClient } from 'redis'`)
       - Export `redisClient` created with `createClient({ url: config.redis.url })`
       - Export `async connectRedis()` that calls `redisClient.connect()` with error handling
       - Handle `error` event with Winston logging (do NOT crash on transient errors)
       - Handle `reconnecting` event with logging
       - Export `async disconnectRedis()` for graceful shutdown
       - IMPORTANT: Redis v4 uses promises natively -- do NOT use callbacks (the old redis v2.8 in the codebase used callbacks)

    2. Create `src/server/state/speakerLock.ts`:
       - Import `redisClient` from redisClient.ts
       - Import `SpeakerLockResult` from shared/types

       - `async acquireSpeakerLock(channelId: string, userId: string, userName: string): Promise<SpeakerLockResult>`:
         - Key: `channel:${channelId}:speaker`
         - Value: JSON `{ userId, userName, timestamp: Date.now() }`
         - Use `redisClient.set(key, value, { NX: true, EX: config.ptt.lockTtlSeconds })` -- atomic "set if not exists" with TTL
         - If result is 'OK': return `{ acquired: true }`
         - If result is null (lock held): GET the current lock, parse JSON, return `{ acquired: false, currentSpeaker: userId, currentSpeakerName: userName }`
         - Handle errors gracefully -- if Redis fails, deny lock acquisition (fail-safe: nobody talks rather than two people talk)

       - `async releaseSpeakerLock(channelId: string, userId: string): Promise<boolean>`:
         - GET current lock value
         - Parse JSON and verify `userId` matches lock holder
         - Only DELETE if this user holds the lock (prevents user A from releasing user B's lock)
         - Use a Lua script or WATCH/MULTI for atomicity: `if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end`
         - Actually, use the simpler approach: GET, compare userId in JSON, then DEL. The tiny race window is acceptable for PTT (worst case: lock expires naturally after TTL)
         - Return true if released, false if not holder

       - `async refreshSpeakerLock(channelId: string, userId: string): Promise<boolean>`:
         - Extend TTL on existing lock (for long PTT sessions)
         - Only refresh if userId matches current holder
         - Use `EXPIRE` command to reset TTL

       - `async getCurrentSpeaker(channelId: string): Promise<{ userId: string; userName: string } | null>`:
         - GET lock key, parse JSON, return speaker info or null

       - `async forceReleaseLock(channelId: string): Promise<void>`:
         - Admin function: DEL the lock key regardless of holder
         - Log warning when used
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - If Redis is running locally: Write a test script that acquires lock, verifies second acquire fails, releases lock, verifies re-acquire succeeds
    - Verify lock key format: `channel:{id}:speaker`
  </verify>
  <done>
    Redis v4 async client connects. Speaker lock uses atomic SET NX EX for exclusive access. Lock auto-expires after 30s TTL. Only lock holder can release. Race conditions prevented by atomic Redis operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Channel state manager and session store</name>
  <files>
    src/server/state/channelState.ts
    src/server/state/sessionStore.ts
  </files>
  <action>
    1. Create `src/server/state/channelState.ts`:
       - Class `ChannelStateManager` that provides high-level channel state operations
       - Constructor takes reference to speaker lock module (dependency injection, not direct import -- makes testing easier)

       - `async startPtt(channelId: string, userId: string, userName: string): Promise<{ success: boolean; state: ChannelState }>`:
         - Attempt to acquire speaker lock
         - If acquired: publish `speaker-changed` event via Redis pub/sub to key `channel:${channelId}:events`
         - Return success with updated ChannelState
         - If denied: return failure with current ChannelState (showing who IS speaking)

       - `async stopPtt(channelId: string, userId: string): Promise<ChannelState>`:
         - Release speaker lock
         - Publish `speaker-changed` event (speaker now null)
         - Return updated ChannelState

       - `async getChannelState(channelId: string): Promise<ChannelState>`:
         - Get current speaker from lock module
         - Build and return ChannelState object

       - `async subscribeToChannel(channelId: string, callback: (state: ChannelState) => void): Promise<void>`:
         - Subscribe to Redis pub/sub for `channel:${channelId}:events`
         - Call callback when speaker changes
         - Use a SEPARATE Redis client for subscriptions (Redis v4 requires dedicated client for pub/sub)

       - `async unsubscribeFromChannel(channelId: string): Promise<void>`:
         - Unsubscribe from channel events

       - Import `ChannelState` type from shared/types

    2. Create `src/server/state/sessionStore.ts`:
       - Class `SessionStore` for tracking connected user sessions
       - Uses Redis hash: `sessions` key with field per userId

       - `async addSession(userId: string, session: UserSession): Promise<void>`:
         - HSET `sessions` userId JSON.stringify(session)
         - Also SET `session:${userId}` with EX for auto-expiry (1 hour)

       - `async removeSession(userId: string): Promise<void>`:
         - HDEL from sessions hash
         - DEL expiry key

       - `async getSession(userId: string): Promise<UserSession | null>`:
         - HGET and parse JSON

       - `async getActiveSessions(): Promise<UserSession[]>`:
         - HGETALL and parse all

       - `async getUsersInChannel(channelId: string): Promise<string[]>`:
         - SMEMBERS of `channel:${channelId}:users` set

       - `async addUserToChannel(userId: string, channelId: string): Promise<void>`:
         - SADD to `channel:${channelId}:users`

       - `async removeUserFromChannel(userId: string, channelId: string): Promise<void>`:
         - SREM from channel users set

       - `async removeUserFromAllChannels(userId: string): Promise<void>`:
         - Get user's session, iterate channels, SREM from each

       - Import `UserSession` type from shared/types
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - All exports resolve: `import { ChannelStateManager } from './channelState'; import { SessionStore } from './sessionStore';`
    - Types are consistent with shared/types.ts definitions
  </verify>
  <done>
    ChannelStateManager provides high-level PTT start/stop with automatic lock management and pub/sub notifications. SessionStore tracks connected users and channel memberships. Both use Redis v4 async operations.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles all state modules
2. Redis client uses v4 async API (no callbacks)
3. Speaker lock uses SET NX EX pattern (atomic acquisition)
4. Lock TTL is configurable (default 30s)
5. Channel state integrates with speaker lock for PTT start/stop
6. Session store tracks user-channel membership
</verification>

<success_criteria>
- Speaker lock is atomic (SET NX EX) preventing simultaneous speakers
- Lock auto-expires after TTL preventing deadlocks on client crash
- Only lock holder can release (ownership verified)
- Channel state publishes speaker changes via Redis pub/sub
- Session store tracks users per channel with add/remove
- All modules use Redis v4 async client (no callbacks, no sync operations)
</success_criteria>

<output>
After completion, create `.planning/phases/01-webrtc-audio-foundation/01-03-SUMMARY.md`
</output>
