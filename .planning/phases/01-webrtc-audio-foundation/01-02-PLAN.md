---
phase: 01-webrtc-audio-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/server/mediasoup/workerPool.ts
  - src/server/mediasoup/routerManager.ts
  - src/server/mediasoup/transportManager.ts
  - src/server/mediasoup/producerConsumerManager.ts
autonomous: true

must_haves:
  truths:
    - "mediasoup workers start successfully (one per CPU core)"
    - "Router is created with Opus codec configured for low-latency PTT"
    - "WebRTC transports can be created for both sending and receiving audio"
    - "Producers and consumers can be created on transports"
  artifacts:
    - path: "src/server/mediasoup/workerPool.ts"
      provides: "mediasoup worker lifecycle management"
      exports: ["WorkerPool"]
      min_lines: 40
    - path: "src/server/mediasoup/routerManager.ts"
      provides: "Router creation with Opus codec config"
      exports: ["RouterManager"]
      min_lines: 30
    - path: "src/server/mediasoup/transportManager.ts"
      provides: "WebRTC transport creation and DTLS connection"
      exports: ["TransportManager"]
      min_lines: 60
    - path: "src/server/mediasoup/producerConsumerManager.ts"
      provides: "Audio producer and consumer lifecycle"
      exports: ["ProducerConsumerManager"]
      min_lines: 50
  key_links:
    - from: "src/server/mediasoup/workerPool.ts"
      to: "mediasoup"
      via: "mediasoup.createWorker()"
      pattern: "createWorker"
    - from: "src/server/mediasoup/routerManager.ts"
      to: "src/server/config.ts"
      via: "imports mediaCodecs from config"
      pattern: "config\\.mediasoup"
    - from: "src/server/mediasoup/transportManager.ts"
      to: "src/server/mediasoup/routerManager.ts"
      via: "router.createWebRtcTransport()"
      pattern: "createWebRtcTransport"
---

<objective>
Implement the server-side mediasoup SFU core: worker pool, router management, WebRTC transport factory, and producer/consumer lifecycle. This is the audio routing engine that receives audio from speakers and forwards it to listeners.

Purpose: mediasoup is the core technology replacing the broken Opus-over-WebSocket system. This plan creates the SFU infrastructure that all audio flows through.

Output: Four server modules that manage the full mediasoup lifecycle from worker creation through audio forwarding.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-webrtc-audio-foundation/01-RESEARCH.md
@.planning/phases/01-webrtc-audio-foundation/01-01-SUMMARY.md
@src/server/config.ts
@src/shared/types.ts
@src/shared/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement mediasoup worker pool and router manager</name>
  <files>
    src/server/mediasoup/workerPool.ts
    src/server/mediasoup/routerManager.ts
  </files>
  <action>
    1. Create `src/server/mediasoup/workerPool.ts`:
       - Class `WorkerPool` that manages mediasoup worker lifecycle
       - `async init()`: Creates `config.mediasoup.numWorkers` workers (one per CPU core) using `mediasoup.createWorker()` with settings from config (logLevel, rtcMinPort, rtcMaxPort)
       - Each worker gets a `died` event handler that logs the error and exits process with code 1 after 2 seconds (per research Pattern 1 -- let process manager restart)
       - `getNextWorker()`: Round-robin worker selection (track index, wrap around). Do NOT use random selection (round-robin distributes load more evenly)
       - `async close()`: Gracefully close all workers
       - `getWorkerCount()`: Returns number of active workers
       - Export singleton instance and the class
       - Use Winston logger for all logging (import from a shared logger module or create inline)

    2. Create `src/server/mediasoup/routerManager.ts`:
       - Class `RouterManager` that creates and tracks mediasoup Routers
       - Constructor takes a `WorkerPool` reference
       - `async createRouter()`: Gets next worker from pool, creates Router with mediaCodecs from config. The Opus codec MUST be configured with:
         - kind: 'audio'
         - mimeType: 'audio/opus'
         - clockRate: 48000
         - channels: 1 (mono for PTT)
         - parameters: `{ 'sprop-stereo': 0, 'usedtx': 0, 'maxplaybackrate': 48000, 'ptime': 20 }`
         - DTX MUST be disabled (usedtx: 0) per locked decision and research -- prevents first-word cutoff
       - `async getOrCreateRouter(channelId: string)`: Returns existing router for channel or creates new one. Store in Map<string, Router>
       - `getRouter(channelId: string)`: Returns router or null
       - `async removeRouter(channelId: string)`: Close and remove router for channel
       - `getRtpCapabilities(channelId: string)`: Returns router's RTP capabilities (needed by client Device.load())
       - Export class (not singleton -- instantiated in server setup)
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - Write a quick test script: `tsx -e "import { workerPool } from './src/server/mediasoup/workerPool'; (async () => { await workerPool.init(); console.log('Workers:', workerPool.getWorkerCount()); process.exit(0); })();"` -- should print worker count matching CPU cores
  </verify>
  <done>
    Worker pool initializes mediasoup workers (one per core). Router manager creates Opus-configured routers per channel. Both compile and initialize successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement WebRTC transport and producer/consumer managers</name>
  <files>
    src/server/mediasoup/transportManager.ts
    src/server/mediasoup/producerConsumerManager.ts
  </files>
  <action>
    1. Create `src/server/mediasoup/transportManager.ts`:
       - Class `TransportManager` for creating and managing WebRTC transports
       - Constructor takes `RouterManager` reference
       - `async createWebRtcTransport(channelId: string, userId: string, direction: 'send' | 'recv')`:
         - Gets router for channel from RouterManager
         - Creates transport via `router.createWebRtcTransport()` with:
           - `listenIps` from config.webrtc.listenIps
           - `enableUdp: true`, `enableTcp: true`, `preferUdp: true`
           - `initialAvailableOutgoingBitrate: 100000`
         - Stores transport in Map keyed by `${userId}:${channelId}:${direction}`
         - Returns `TransportOptions` (id, iceParameters, iceCandidates, dtlsParameters) per shared types
       - `async connectTransport(transportId: string, dtlsParameters: object)`:
         - Finds transport by ID across all stored transports
         - Calls `transport.connect({ dtlsParameters })`
       - `getTransport(transportId: string)`: Lookup transport by its mediasoup ID
       - `async closeTransport(transportId: string)`: Close and remove transport
       - `async closeUserTransports(userId: string)`: Close all transports for a user (cleanup on disconnect)
       - Monitor transport `dtlsstatechange` event -- log state changes, close on `failed` state
       - Monitor transport `icestatechange` event -- log for debugging

    2. Create `src/server/mediasoup/producerConsumerManager.ts`:
       - Class `ProducerConsumerManager` for audio producer/consumer lifecycle
       - Constructor takes `TransportManager` reference
       - `async createProducer(transportId: string, kind: 'audio', rtpParameters: object, userId: string, channelId: string)`:
         - Gets transport from TransportManager
         - Creates producer via `transport.produce({ kind, rtpParameters })`
         - Initially pauses the producer (PTT is not transmitting by default)
         - Stores producer with metadata (userId, channelId)
         - Returns producer ID
       - `async createConsumer(transportId: string, producerId: string, rtpCapabilities: object, userId: string)`:
         - Gets transport and verifies router can consume (router.canConsume)
         - Creates consumer via `transport.consume({ producerId, rtpCapabilities, paused: true })`
         - Returns consumer info: `{ id, producerId, kind, rtpParameters }`
         - Consumer starts paused -- client resumes after setup
       - `async resumeProducer(producerId: string)`: Resume audio production (PTT start)
       - `async pauseProducer(producerId: string)`: Pause audio production (PTT stop)
       - `async resumeConsumer(consumerId: string)`: Resume audio consumption
       - `getProducersForChannel(channelId: string)`: Returns all active producers in a channel
       - `async closeProducer(producerId: string)`: Close and cleanup
       - `async closeConsumer(consumerId: string)`: Close and cleanup
       - `async closeUserProducersAndConsumers(userId: string)`: Cleanup all for user disconnect
       - Handle producer `transportclose` event for cleanup
       - Handle consumer `transportclose` and `producerclose` events for cleanup
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - All four mediasoup modules import cleanly: `import { WorkerPool } from './workerPool'; import { RouterManager } from './routerManager'; import { TransportManager } from './transportManager'; import { ProducerConsumerManager } from './producerConsumerManager';`
    - Type exports match what signaling handlers will need (TransportOptions, ProducerInfo)
  </verify>
  <done>
    Transport manager creates WebRTC transports with proper ICE/DTLS configuration. Producer/consumer manager handles audio stream lifecycle with pause/resume for PTT. Full mediasoup SFU pipeline is implemented server-side.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles all mediasoup modules
2. Worker pool initializes correct number of workers
3. Router created with Opus codec (usedtx: 0, ptime: 20, mono)
4. Transport creation returns valid TransportOptions
5. No circular dependencies between the four modules
</verification>

<success_criteria>
- WorkerPool creates one worker per CPU core with proper error handling
- RouterManager creates routers with PTT-optimized Opus configuration (DTX disabled)
- TransportManager creates WebRTC transports with ICE/DTLS support
- ProducerConsumerManager handles full audio lifecycle with pause/resume for PTT
- All modules compile cleanly under TypeScript strict mode
</success_criteria>

<output>
After completion, create `.planning/phases/01-webrtc-audio-foundation/01-02-SUMMARY.md`
</output>
