---
phase: 08-multi-channel-monitoring-scan-mode
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
  - android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
  - android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt
autonomous: true

must_haves:
  truths:
    - "User can join up to 5 channels simultaneously (6th channel returns failure)"
    - "First joined channel automatically becomes primary"
    - "User can change primary channel via setPrimaryChannel()"
    - "Muting a channel closes its consumers via mediasoupClient.closeConsumer(consumerId) (bandwidth savings)"
    - "Unmuting a channel immediately re-subscribes — if channel has active speaker, consumer is created on unmute"
    - "Leaving a channel cleans up its consumers and removes it from monitored map"
    - "setChannelVolume(channelId, volume) sets Consumer volume (0.0-1.0) for per-channel volume control"
    - "applyAudioMixMode() adjusts consumer volumes based on isPrimary and AudioMixMode setting"
    - "Service notification shows primary channel + monitoring count"
    - "Notification PTT action uses pttTargetMode setting to determine target channel"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt"
      provides: "Multi-channel monitoring with Map<String, ChannelMonitoringState>"
      contains: "monitoredChannels"
    - path: "android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt"
      provides: "Notification with monitoring count"
      contains: "EXTRA_MONITORING_COUNT"
  key_links:
    - from: "ChannelRepository.kt"
      to: "ChannelMonitoringService.kt"
      via: "startService with ACTION_UPDATE_CHANNEL and EXTRA_MONITORING_COUNT"
      pattern: "EXTRA_MONITORING_COUNT"
    - from: "ChannelRepository.kt"
      to: "SettingsRepository.kt"
      via: "persist monitored channels on join/leave"
      pattern: "settingsRepository\\.setMonitoredChannels"
    - from: "ChannelRepository.kt"
      to: "MediasoupClient"
      via: "per-channel consumer tracking and volume control via closeConsumer/setConsumerVolume"
      pattern: "channelConsumers"
    - from: "ChannelMonitoringService.kt"
      to: "SettingsRepository.kt"
      via: "notification PTT reads pttTargetMode to determine target channel"
      pattern: "pttTargetMode"
---

<objective>
Convert ChannelRepository from single-channel to multi-channel monitoring with per-channel consumer management, and update ChannelMonitoringService notification for multi-channel display.

Purpose: This is the core multi-channel engine. ChannelRepository currently manages a single joined channel. It must manage a Map of up to 5 monitored channels, each with independent speaker observation, consumer lifecycle, and mute state. The notification must show "Primary (monitoring N others)" format.

Output: Rewritten ChannelRepository with multi-channel support + updated notification service.
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/08-multi-channel-monitoring-scan-mode/08-RESEARCH.md
@.planning/phases/08-multi-channel-monitoring-scan-mode/08-01-SUMMARY.md
@android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
@android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt
@android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
@android/app/src/main/java/com/voiceping/android/data/network/SignalingClient.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert ChannelRepository to multi-channel monitoring</name>
  <files>
    android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
    android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
  </files>
  <action>
    Rewrite ChannelRepository to manage multiple channels simultaneously. Replace single-channel state with multi-channel Map. Also add `setConsumerVolume` to MediasoupClient.

    **Add setConsumerVolume to MediasoupClient.kt:**
    ```kotlin
    /**
     * Set volume for a specific consumer (0.0 to 1.0).
     * Used for per-channel volume control and audio mix mode.
     */
    fun setConsumerVolume(consumerId: String, volume: Float) {
        consumers[consumerId]?.let {
            // TODO: Integrate actual libmediasoup-android library
            // (it as Consumer).volume = volume.coerceIn(0f, 1f)
            Log.d(TAG, "Consumer volume set: $consumerId -> $volume")
        }
    }
    ```
    Place this after the existing `closeConsumer()` method. Follows the same pattern as `closeConsumer` with the TODO for actual library integration.

    **Replace single-channel fields:**
    - Remove `_joinedChannelId: MutableStateFlow<String?>` and its public `joinedChannelId`
    - Remove `_currentSpeaker: MutableStateFlow<User?>` (now per-channel in ChannelMonitoringState)
    - Remove `_lastSpeaker: MutableStateFlow<User?>` (now per-channel)
    - Remove single `currentConsumerId: String?`
    - Remove single `speakerObserverJob: Job?`
    - Remove single `lastSpeakerFadeJob: Job?`

    **Add multi-channel fields:**
    ```kotlin
    private val _monitoredChannels = MutableStateFlow<Map<String, ChannelMonitoringState>>(emptyMap())
    val monitoredChannels: StateFlow<Map<String, ChannelMonitoringState>> = _monitoredChannels.asStateFlow()

    private val _primaryChannelId = MutableStateFlow<String?>(null)
    val primaryChannelId: StateFlow<String?> = _primaryChannelId.asStateFlow()

    // Per-channel consumer tracking: channelId -> (producerId -> consumerId)
    private val channelConsumers = mutableMapOf<String, MutableMap<String, String>>()

    // Per-channel speaker observer jobs
    private val speakerObserverJobs = mutableMapOf<String, Job>()

    // Per-channel last speaker fade jobs
    private val lastSpeakerFadeJobs = mutableMapOf<String, Job>()
    ```

    **Inject SettingsRepository** — add to constructor:
    ```kotlin
    private val settingsRepository: SettingsRepository
    ```

    **Rewrite joinChannel(channelId: String, channelName: String, teamName: String):**
    Note: Signature changes to accept channelName and teamName (needed for ChannelMonitoringState).
    1. Guard: if `_monitoredChannels.value.size >= 5` and channel not already joined, return `Result.failure(Exception("Maximum 5 channels. Leave a channel to join another."))`
    2. If channel already joined, return success (no-op)
    3. Request JOIN_CHANNEL from server (same as before)
    4. If first channel (`_monitoredChannels.value.isEmpty()`):
       - Request audio focus, set earpiece mode
       - Create recv transport: `mediasoupClient.createRecvTransport(channelId)`
       - Start foreground service
       - Set as primary: `_primaryChannelId.value = channelId`
    5. Create ChannelMonitoringState with isPrimary = (_monitoredChannels.value.isEmpty())
    6. Add to monitored channels map
    7. Start observing speaker changes for this channel (new per-channel method)
    8. Persist monitored channels: `settingsRepository.setMonitoredChannels(_monitoredChannels.value.keys)`
    9. If primary, persist: `settingsRepository.setPrimaryChannel(channelId)`
    10. Update notification with primary channel name + monitoring count

    **Rewrite leaveChannel(channelId: String):**
    1. Cancel speaker observer for this channel
    2. Close all consumers for this channel from `channelConsumers[channelId]`
    3. Remove from `channelConsumers` map
    4. Remove from `_monitoredChannels` map
    5. If was primary and other channels remain, reassign primary to first remaining channel
    6. If last channel, clean up everything (release audio focus, reset audio mode, stop service, cleanup mediasoup)
    7. Send LEAVE_CHANNEL to server
    8. Persist updated monitored channels
    9. Update notification (or stop service if last channel)

    **Rewrite observeSpeakerChanges to be per-channel:**
    Create `observeSpeakerChangesForChannel(channelId: String)` that:
    1. Cancels any existing job for this channel
    2. Creates new coroutine collecting SPEAKER_CHANGED broadcasts filtered to this channelId
    3. On speaker start:
       - Update ChannelMonitoringState with currentSpeaker and speakerStartTime = System.currentTimeMillis()
       - Play RX squelch (only if not transmitting — same guard as before)
       - Close previous consumer if exists for this channel
       - If not muted: consume audio, track in channelConsumers
       - Cancel last speaker fade for this channel
    4. On speaker stop:
       - Clear currentSpeaker, set lastSpeaker
       - Play RX squelch close (same guard)
       - Start last speaker fade timer (2.5s) for this channel
       - Close consumer, clear from channelConsumers

    **Add setPrimaryChannel(channelId: String):**
    1. Guard: channel must be in monitored map
    2. Update `_primaryChannelId.value`
    3. Update all ChannelMonitoringState entries: set isPrimary true for target, false for others
    4. Persist via settingsRepository
    5. Update notification

    **Add muteChannel(channelId: String):**
    Per user decision: "Muting a channel triggers server-side unsubscribe"
    1. Close ALL consumers for this channel via `mediasoupClient.closeConsumer(consumerId)` for each entry in `channelConsumers[channelId]` (this calls `Consumer.close()` internally, which stops audio and releases server-side resources for bandwidth savings)
    2. Clear `channelConsumers[channelId]` map entries
    3. Update ChannelMonitoringState: isMuted = true, currentSpeaker = null
    4. No visual activity indicators when muted

    **Add unmuteChannel(channelId: String):**
    Per user decision: "Unmuting immediately re-subscribes — if someone is mid-transmission, user hears it"
    1. Update ChannelMonitoringState: isMuted = false
    2. **Explicit active speaker check:** Read `currentSpeaker` from the channel's monitoring state. If `currentSpeaker != null` (someone is currently speaking on this channel), immediately create a consumer by calling `mediasoupClient.consumeAudio(producerId, speakerId)` and track in `channelConsumers[channelId]`. The `consumerId` field on ChannelMonitoringState stores the producerId needed for this call.
    3. If no active speaker, the normal `observeSpeakerChangesForChannel` listener will create consumers when next speaker starts.

    **Add setChannelVolume(channelId: String, volume: Float):**
    Per user decision: "Per-channel volume control (0-100% slider)"
    1. Guard: volume must be in 0.0f..1.0f range, clamp if needed
    2. Update ChannelMonitoringState: volume = volume
    3. Apply volume to active consumers for this channel: for each consumerId in `channelConsumers[channelId]`, call `mediasoupClient.setConsumerVolume(consumerId, volume)`. Note: This requires adding a `setConsumerVolume(consumerId: String, volume: Float)` method to MediasoupClient that calls `(consumers[consumerId] as Consumer).volume = volume` (libmediasoup-android Consumer has a volume property, 0.0-1.0 range per research: "Audio volume control: WebRTC Consumer has volume setter (0.0-1.0 range)").
    4. If channel is muted, only update state (no consumers to adjust)

    **Add applyAudioMixMode(audioMixMode: AudioMixMode):**
    Per user decision: "Equal volume vs Primary priority"
    1. Read current `audioMixMode` parameter
    2. For each monitored channel, calculate target volume:
       - `EQUAL_VOLUME`: all channels get their stored `volume` value (default 1.0)
       - `PRIMARY_PRIORITY`: primary channel gets stored `volume`, non-primary channels get `volume * 0.5f` (50% reduction — discretion within "play quieter" requirement)
    3. Apply calculated volumes to all active consumers via `mediasoupClient.setConsumerVolume(consumerId, calculatedVolume)` for each consumer in `channelConsumers`
    4. Call this method: (a) when audioMixMode setting changes, (b) when primary channel changes, (c) when a new consumer is created in `observeSpeakerChangesForChannel`

    **Add muteAllExceptPrimary():**
    Per user decision: "Mute all except primary" quick action
    1. Iterate monitored channels, mute each that is not primary and not already muted

    **Add unmuteAllChannels():**
    1. Iterate monitored channels, unmute each that is muted

    **Update init block mute observation:**
    The existing ChannelMonitoringService.isMutedFlow observation needs updating. The notification mute button should now toggle the displayed/primary channel mute, not a global mute. For now, keep the existing pattern but apply it to primary channel only. The per-channel mute is managed by muteChannel/unmuteChannel methods.

    **Add init block audioMixMode observer:**
    Collect `settingsRepository.getAudioMixMode()` in the init block. When audioMixMode changes, call `applyAudioMixMode(newMode)` to adjust all active consumer volumes.
    ```kotlin
    viewModelScope.launch {
        settingsRepository.getAudioMixMode().collect { mode ->
            applyAudioMixMode(mode)
        }
    }
    ```
    Note: ChannelRepository needs SettingsRepository injected (already specified above) and a cached `currentAudioMixMode` field to use when creating new consumers.

    **Update observeSpeakerChangesForChannel — apply audio mix mode on new consumer:**
    After creating a new consumer in step 3 (on speaker start, if not muted), call `applyAudioMixMode(currentAudioMixMode)` to ensure the new consumer's volume respects the current audio mix mode setting. This ensures newly created consumers get correct volume immediately.

    **Update phone call handling:**
    On phone call start: force-release PTT + close consumers for ALL monitored channels (pause everything)
    On phone call end: consumers will be re-created by speaker change events (same pattern as before)

    **Update disconnectAll():**
    1. Stop service
    2. Cancel all speaker observer jobs
    3. Cancel all fade jobs
    4. Leave all channels (close consumers, cleanup)
    5. Clear all maps
    6. Clear persisted state

    **Helper method for updating channel state:**
    ```kotlin
    private fun updateChannelState(channelId: String, transform: (ChannelMonitoringState) -> ChannelMonitoringState) {
        _monitoredChannels.value[channelId]?.let { state ->
            _monitoredChannels.value = _monitoredChannels.value + (channelId to transform(state))
        }
    }
    ```

    **Helper for notification update:**
    ```kotlin
    private fun updateServiceNotification() {
        val primaryName = _monitoredChannels.value[_primaryChannelId.value]?.channelName ?: return
        val otherCount = _monitoredChannels.value.size - 1
        val serviceIntent = Intent(context, ChannelMonitoringService::class.java).apply {
            action = ChannelMonitoringService.ACTION_UPDATE_CHANNEL
            putExtra(ChannelMonitoringService.EXTRA_CHANNEL_NAME, primaryName)
            putExtra(ChannelMonitoringService.EXTRA_MONITORING_COUNT, otherCount)
        }
        context.startService(serviceIntent)
    }
    ```

    IMPORTANT: Single RecvTransport shared across all channels. Do NOT create separate transport per channel. The `createRecvTransport()` is called once on first join. Multiple consumers are created on the same transport for different channels' speakers.
  </action>
  <verify>
    Confirm ChannelRepository.kt contains:
    - `monitoredChannels: StateFlow<Map<String, ChannelMonitoringState>>`
    - `primaryChannelId: StateFlow<String?>`
    - `channelConsumers` map
    - Max 5 channel guard in joinChannel
    - `setPrimaryChannel()`, `muteChannel()`, `unmuteChannel()`, `muteAllExceptPrimary()` methods
    - `setChannelVolume(channelId, volume)` method calling `mediasoupClient.setConsumerVolume()`
    - `applyAudioMixMode(audioMixMode)` method adjusting volumes based on isPrimary
    - `unmuteChannel` explicitly creates consumer if channel has active currentSpeaker
    - `muteChannel` explicitly calls `mediasoupClient.closeConsumer(consumerId)` for each consumer
    - Per-channel speaker observation via `observeSpeakerChangesForChannel()`
    - `speakerStartTime` set on speaker start
    - settingsRepository persistence calls
    - updateServiceNotification helper
    - audioMixMode observer in init block calling applyAudioMixMode on changes

    Confirm MediasoupClient.kt contains:
    - `setConsumerVolume(consumerId: String, volume: Float)` method
  </verify>
  <done>
    ChannelRepository manages Map of up to 5 ChannelMonitoringState entries. Single RecvTransport shared across channels. Per-channel consumer tracking in channelConsumers map. Muting closes consumers via mediasoupClient.closeConsumer() for bandwidth savings. Unmuting immediately creates consumer if channel has active speaker. setChannelVolume adjusts individual consumer volume. applyAudioMixMode adjusts all consumer volumes based on isPrimary and AudioMixMode setting. Primary channel auto-assigned on first join, reassigned on leave. Speaker observation per-channel with speakerStartTime tracking. State persisted via SettingsRepository. MediasoupClient has setConsumerVolume method.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ChannelMonitoringService notification for multi-channel display</name>
  <files>
    android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt
  </files>
  <action>
    Update ChannelMonitoringService to display multi-channel monitoring information in the notification.

    **Add new intent extra constant:**
    ```kotlin
    const val EXTRA_MONITORING_COUNT = "monitoring_count"
    ```

    **Add field to track monitoring count:**
    ```kotlin
    private var monitoringCount: Int = 0
    ```

    **Update ACTION_START handler:**
    Also read EXTRA_MONITORING_COUNT from intent (default 0).

    **Update ACTION_UPDATE_CHANNEL handler:**
    Also read EXTRA_MONITORING_COUNT from intent. Update `monitoringCount` field. Update notification.

    **Update buildNotification:**
    Per user decision: "Shows primary channel name + monitoring count: 'Alpha (monitoring 3 others)'"

    Change content title to:
    ```kotlin
    val title = if (monitoringCount > 0) {
        "$channelName (monitoring $monitoringCount others)"
    } else {
        channelName ?: "VoicePing"
    }
    ```

    Use `title` for `setContentTitle()`.

    Keep existing Mute/Disconnect actions. The mute action from notification now applies to the primary channel (ChannelRepository handles this in its mute observation).

    **Update notification PTT action to respect pttTargetMode setting:**
    Per user decision: "Notification PTT follows the same setting as in-app PTT target"

    The notification PTT PendingIntent must route to the correct channel based on pttTargetMode:
    1. Add `EXTRA_PTT_TARGET_CHANNEL_ID = "ptt_target_channel_id"` constant
    2. When building the notification PTT action, read the target channel from the intent extras (ChannelRepository sets this when updating the notification)
    3. In `updateServiceNotification()` in ChannelRepository, determine PTT target using the same logic as ViewModel:
       ```kotlin
       val pttTargetChannelId = when (currentPttTargetMode) {
           PttTargetMode.ALWAYS_PRIMARY -> _primaryChannelId.value
           PttTargetMode.DISPLAYED_CHANNEL -> displayedChannelId  // Pass displayed channel from ViewModel or use primary as fallback
       }
       ```
       Since ChannelRepository doesn't know displayedChannelId (that's in ViewModel), pass it via the service intent:
       `putExtra(ChannelMonitoringService.EXTRA_PTT_TARGET_CHANNEL_ID, pttTargetChannelId)`
    4. ChannelMonitoringService stores the latest pttTargetChannelId and includes it in the PTT PendingIntent's extras
    5. When PTT is pressed from notification, the broadcast receiver reads EXTRA_PTT_TARGET_CHANNEL_ID from the intent and calls `channelRepository.startPtt(targetChannelId)`
  </action>
  <verify>
    Confirm ChannelMonitoringService.kt contains:
    - EXTRA_MONITORING_COUNT constant
    - EXTRA_PTT_TARGET_CHANNEL_ID constant
    - monitoringCount field
    - pttTargetChannelId field
    - Updated buildNotification with "(monitoring N others)" format
    - Both ACTION_START and ACTION_UPDATE_CHANNEL read EXTRA_MONITORING_COUNT and EXTRA_PTT_TARGET_CHANNEL_ID
    - PTT PendingIntent includes pttTargetChannelId in extras
  </verify>
  <done>
    Notification shows "Alpha (monitoring 3 others)" when multiple channels joined, or just "Alpha" for single channel. Notification PTT action targets correct channel based on pttTargetMode setting (always primary or displayed channel). Notification updates via same NOTIFICATION_ID (no service restart). Mute/Disconnect actions preserved.
  </done>
</task>

</tasks>

<verification>
1. ChannelRepository manages Map<String, ChannelMonitoringState> instead of single channel
2. Max 5 channel limit enforced with descriptive error message
3. First channel automatically becomes primary
4. Mute closes consumers via mediasoupClient.closeConsumer() (not just volume 0) per user decision
5. Unmute immediately creates consumer if channel has active speaker (not just waiting for next SPEAKER_CHANGED)
6. Single RecvTransport shared across all channels (no per-channel transport)
7. speakerStartTime tracked for "most recently started" scan logic
8. Notification shows "Primary (monitoring N others)" format
9. Notification PTT targets correct channel based on pttTargetMode setting
10. State persisted via SettingsRepository (monitored channels + primary)
11. Phone call handling pauses ALL channels
12. setChannelVolume adjusts consumer volume via mediasoupClient.setConsumerVolume()
13. applyAudioMixMode adjusts volumes based on isPrimary and AudioMixMode
14. MediasoupClient has setConsumerVolume method
</verification>

<success_criteria>
- Multi-channel join/leave works with proper consumer lifecycle
- Max 5 channel limit enforced
- Primary channel auto-assigned and reassignable
- Mute closes consumers via closeConsumer(); unmute re-creates consumers for active speakers
- setChannelVolume and applyAudioMixMode functional for per-channel volume and audio mix mode
- Notification displays multi-channel monitoring count
- Notification PTT respects pttTargetMode setting
- State persists across sessions via DataStore
- MediasoupClient.setConsumerVolume method exists
</success_criteria>

<output>
After completion, create `.planning/phases/08-multi-channel-monitoring-scan-mode/08-02-SUMMARY.md`
</output>
