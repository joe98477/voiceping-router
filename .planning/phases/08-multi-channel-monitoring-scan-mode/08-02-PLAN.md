---
phase: 08-multi-channel-monitoring-scan-mode
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
  - android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt
autonomous: true

must_haves:
  truths:
    - "User can join up to 5 channels simultaneously (6th channel returns failure)"
    - "First joined channel automatically becomes primary"
    - "User can change primary channel via setPrimaryChannel()"
    - "Muting a channel closes its consumers (bandwidth savings)"
    - "Leaving a channel cleans up its consumers and removes it from monitored map"
    - "Service notification shows primary channel + monitoring count"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt"
      provides: "Multi-channel monitoring with Map<String, ChannelMonitoringState>"
      contains: "monitoredChannels"
    - path: "android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt"
      provides: "Notification with monitoring count"
      contains: "EXTRA_MONITORING_COUNT"
  key_links:
    - from: "ChannelRepository.kt"
      to: "ChannelMonitoringService.kt"
      via: "startService with ACTION_UPDATE_CHANNEL and EXTRA_MONITORING_COUNT"
      pattern: "EXTRA_MONITORING_COUNT"
    - from: "ChannelRepository.kt"
      to: "SettingsRepository.kt"
      via: "persist monitored channels on join/leave"
      pattern: "settingsRepository\\.setMonitoredChannels"
    - from: "ChannelRepository.kt"
      to: "MediasoupClient"
      via: "per-channel consumer tracking"
      pattern: "channelConsumers"
---

<objective>
Convert ChannelRepository from single-channel to multi-channel monitoring with per-channel consumer management, and update ChannelMonitoringService notification for multi-channel display.

Purpose: This is the core multi-channel engine. ChannelRepository currently manages a single joined channel. It must manage a Map of up to 5 monitored channels, each with independent speaker observation, consumer lifecycle, and mute state. The notification must show "Primary (monitoring N others)" format.

Output: Rewritten ChannelRepository with multi-channel support + updated notification service.
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/08-multi-channel-monitoring-scan-mode/08-RESEARCH.md
@.planning/phases/08-multi-channel-monitoring-scan-mode/08-01-SUMMARY.md
@android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
@android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt
@android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
@android/app/src/main/java/com/voiceping/android/data/network/SignalingClient.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert ChannelRepository to multi-channel monitoring</name>
  <files>
    android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
  </files>
  <action>
    Rewrite ChannelRepository to manage multiple channels simultaneously. Replace single-channel state with multi-channel Map.

    **Replace single-channel fields:**
    - Remove `_joinedChannelId: MutableStateFlow<String?>` and its public `joinedChannelId`
    - Remove `_currentSpeaker: MutableStateFlow<User?>` (now per-channel in ChannelMonitoringState)
    - Remove `_lastSpeaker: MutableStateFlow<User?>` (now per-channel)
    - Remove single `currentConsumerId: String?`
    - Remove single `speakerObserverJob: Job?`
    - Remove single `lastSpeakerFadeJob: Job?`

    **Add multi-channel fields:**
    ```kotlin
    private val _monitoredChannels = MutableStateFlow<Map<String, ChannelMonitoringState>>(emptyMap())
    val monitoredChannels: StateFlow<Map<String, ChannelMonitoringState>> = _monitoredChannels.asStateFlow()

    private val _primaryChannelId = MutableStateFlow<String?>(null)
    val primaryChannelId: StateFlow<String?> = _primaryChannelId.asStateFlow()

    // Per-channel consumer tracking: channelId -> (producerId -> consumerId)
    private val channelConsumers = mutableMapOf<String, MutableMap<String, String>>()

    // Per-channel speaker observer jobs
    private val speakerObserverJobs = mutableMapOf<String, Job>()

    // Per-channel last speaker fade jobs
    private val lastSpeakerFadeJobs = mutableMapOf<String, Job>()
    ```

    **Inject SettingsRepository** — add to constructor:
    ```kotlin
    private val settingsRepository: SettingsRepository
    ```

    **Rewrite joinChannel(channelId: String, channelName: String, teamName: String):**
    Note: Signature changes to accept channelName and teamName (needed for ChannelMonitoringState).
    1. Guard: if `_monitoredChannels.value.size >= 5` and channel not already joined, return `Result.failure(Exception("Maximum 5 channels. Leave a channel to join another."))`
    2. If channel already joined, return success (no-op)
    3. Request JOIN_CHANNEL from server (same as before)
    4. If first channel (`_monitoredChannels.value.isEmpty()`):
       - Request audio focus, set earpiece mode
       - Create recv transport: `mediasoupClient.createRecvTransport(channelId)`
       - Start foreground service
       - Set as primary: `_primaryChannelId.value = channelId`
    5. Create ChannelMonitoringState with isPrimary = (_monitoredChannels.value.isEmpty())
    6. Add to monitored channels map
    7. Start observing speaker changes for this channel (new per-channel method)
    8. Persist monitored channels: `settingsRepository.setMonitoredChannels(_monitoredChannels.value.keys)`
    9. If primary, persist: `settingsRepository.setPrimaryChannel(channelId)`
    10. Update notification with primary channel name + monitoring count

    **Rewrite leaveChannel(channelId: String):**
    1. Cancel speaker observer for this channel
    2. Close all consumers for this channel from `channelConsumers[channelId]`
    3. Remove from `channelConsumers` map
    4. Remove from `_monitoredChannels` map
    5. If was primary and other channels remain, reassign primary to first remaining channel
    6. If last channel, clean up everything (release audio focus, reset audio mode, stop service, cleanup mediasoup)
    7. Send LEAVE_CHANNEL to server
    8. Persist updated monitored channels
    9. Update notification (or stop service if last channel)

    **Rewrite observeSpeakerChanges to be per-channel:**
    Create `observeSpeakerChangesForChannel(channelId: String)` that:
    1. Cancels any existing job for this channel
    2. Creates new coroutine collecting SPEAKER_CHANGED broadcasts filtered to this channelId
    3. On speaker start:
       - Update ChannelMonitoringState with currentSpeaker and speakerStartTime = System.currentTimeMillis()
       - Play RX squelch (only if not transmitting — same guard as before)
       - Close previous consumer if exists for this channel
       - If not muted: consume audio, track in channelConsumers
       - Cancel last speaker fade for this channel
    4. On speaker stop:
       - Clear currentSpeaker, set lastSpeaker
       - Play RX squelch close (same guard)
       - Start last speaker fade timer (2.5s) for this channel
       - Close consumer, clear from channelConsumers

    **Add setPrimaryChannel(channelId: String):**
    1. Guard: channel must be in monitored map
    2. Update `_primaryChannelId.value`
    3. Update all ChannelMonitoringState entries: set isPrimary true for target, false for others
    4. Persist via settingsRepository
    5. Update notification

    **Add muteChannel(channelId: String):**
    Per user decision: "Muting a channel triggers server-side unsubscribe"
    1. Close ALL consumers for this channel (bandwidth savings)
    2. Clear channelConsumers[channelId]
    3. Update ChannelMonitoringState: isMuted = true, currentSpeaker = null
    4. No visual activity indicators when muted

    **Add unmuteChannel(channelId: String):**
    1. Update ChannelMonitoringState: isMuted = false
    2. If speaker is currently active (server will send SPEAKER_CHANGED), new consumer will be created by observer

    **Add muteAllExceptPrimary():**
    Per user decision: "Mute all except primary" quick action
    1. Iterate monitored channels, mute each that is not primary and not already muted

    **Add unmuteAllChannels():**
    1. Iterate monitored channels, unmute each that is muted

    **Update init block mute observation:**
    The existing ChannelMonitoringService.isMutedFlow observation needs updating. The notification mute button should now toggle the displayed/primary channel mute, not a global mute. For now, keep the existing pattern but apply it to primary channel only. The per-channel mute is managed by muteChannel/unmuteChannel methods.

    **Update phone call handling:**
    On phone call start: force-release PTT + close consumers for ALL monitored channels (pause everything)
    On phone call end: consumers will be re-created by speaker change events (same pattern as before)

    **Update disconnectAll():**
    1. Stop service
    2. Cancel all speaker observer jobs
    3. Cancel all fade jobs
    4. Leave all channels (close consumers, cleanup)
    5. Clear all maps
    6. Clear persisted state

    **Helper method for updating channel state:**
    ```kotlin
    private fun updateChannelState(channelId: String, transform: (ChannelMonitoringState) -> ChannelMonitoringState) {
        _monitoredChannels.value[channelId]?.let { state ->
            _monitoredChannels.value = _monitoredChannels.value + (channelId to transform(state))
        }
    }
    ```

    **Helper for notification update:**
    ```kotlin
    private fun updateServiceNotification() {
        val primaryName = _monitoredChannels.value[_primaryChannelId.value]?.channelName ?: return
        val otherCount = _monitoredChannels.value.size - 1
        val serviceIntent = Intent(context, ChannelMonitoringService::class.java).apply {
            action = ChannelMonitoringService.ACTION_UPDATE_CHANNEL
            putExtra(ChannelMonitoringService.EXTRA_CHANNEL_NAME, primaryName)
            putExtra(ChannelMonitoringService.EXTRA_MONITORING_COUNT, otherCount)
        }
        context.startService(serviceIntent)
    }
    ```

    IMPORTANT: Single RecvTransport shared across all channels. Do NOT create separate transport per channel. The `createRecvTransport()` is called once on first join. Multiple consumers are created on the same transport for different channels' speakers.
  </action>
  <verify>
    Confirm ChannelRepository.kt contains:
    - `monitoredChannels: StateFlow<Map<String, ChannelMonitoringState>>`
    - `primaryChannelId: StateFlow<String?>`
    - `channelConsumers` map
    - Max 5 channel guard in joinChannel
    - `setPrimaryChannel()`, `muteChannel()`, `unmuteChannel()`, `muteAllExceptPrimary()` methods
    - Per-channel speaker observation via `observeSpeakerChangesForChannel()`
    - `speakerStartTime` set on speaker start
    - settingsRepository persistence calls
    - updateServiceNotification helper
  </verify>
  <done>
    ChannelRepository manages Map of up to 5 ChannelMonitoringState entries. Single RecvTransport shared across channels. Per-channel consumer tracking in channelConsumers map. Muting closes consumers for bandwidth savings. Primary channel auto-assigned on first join, reassigned on leave. Speaker observation per-channel with speakerStartTime tracking. State persisted via SettingsRepository.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ChannelMonitoringService notification for multi-channel display</name>
  <files>
    android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt
  </files>
  <action>
    Update ChannelMonitoringService to display multi-channel monitoring information in the notification.

    **Add new intent extra constant:**
    ```kotlin
    const val EXTRA_MONITORING_COUNT = "monitoring_count"
    ```

    **Add field to track monitoring count:**
    ```kotlin
    private var monitoringCount: Int = 0
    ```

    **Update ACTION_START handler:**
    Also read EXTRA_MONITORING_COUNT from intent (default 0).

    **Update ACTION_UPDATE_CHANNEL handler:**
    Also read EXTRA_MONITORING_COUNT from intent. Update `monitoringCount` field. Update notification.

    **Update buildNotification:**
    Per user decision: "Shows primary channel name + monitoring count: 'Alpha (monitoring 3 others)'"

    Change content title to:
    ```kotlin
    val title = if (monitoringCount > 0) {
        "$channelName (monitoring $monitoringCount others)"
    } else {
        channelName ?: "VoicePing"
    }
    ```

    Use `title` for `setContentTitle()`.

    Keep existing Mute/Disconnect actions. The mute action from notification now applies to the primary channel (ChannelRepository handles this in its mute observation).
  </action>
  <verify>
    Confirm ChannelMonitoringService.kt contains:
    - EXTRA_MONITORING_COUNT constant
    - monitoringCount field
    - Updated buildNotification with "(monitoring N others)" format
    - Both ACTION_START and ACTION_UPDATE_CHANNEL read EXTRA_MONITORING_COUNT
  </verify>
  <done>
    Notification shows "Alpha (monitoring 3 others)" when multiple channels joined, or just "Alpha" for single channel. Notification updates via same NOTIFICATION_ID (no service restart). Mute/Disconnect actions preserved.
  </done>
</task>

</tasks>

<verification>
1. ChannelRepository manages Map<String, ChannelMonitoringState> instead of single channel
2. Max 5 channel limit enforced with descriptive error message
3. First channel automatically becomes primary
4. Mute closes consumers (not just volume 0) per user decision
5. Single RecvTransport shared across all channels (no per-channel transport)
6. speakerStartTime tracked for "most recently started" scan logic
7. Notification shows "Primary (monitoring N others)" format
8. State persisted via SettingsRepository (monitored channels + primary)
9. Phone call handling pauses ALL channels
</verification>

<success_criteria>
- Multi-channel join/leave works with proper consumer lifecycle
- Max 5 channel limit enforced
- Primary channel auto-assigned and reassignable
- Mute/unmute properly closes/re-creates consumers
- Notification displays multi-channel monitoring count
- State persists across sessions via DataStore
</success_criteria>

<output>
After completion, create `.planning/phases/08-multi-channel-monitoring-scan-mode/08-02-SUMMARY.md`
</output>
