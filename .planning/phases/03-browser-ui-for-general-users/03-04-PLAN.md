---
phase: 03-browser-ui-for-general-users
plan: 04
type: execute
wave: 4
depends_on: ["03-03"]
files_modified:
  - web-ui/src/hooks/usePermissionUpdates.js
  - web-ui/src/pages/Channels.jsx
  - web-ui/src/context/ChannelContext.jsx
autonomous: true

must_haves:
  truths:
    - "When admin adds a channel to user, the new channel appears without page refresh"
    - "When admin removes a channel from user, the removed channel disappears without page refresh"
    - "Global permission WebSocket does not interfere with per-channel audio WebSockets"
    - "Permission WebSocket reconnects automatically after brief network loss"
  artifacts:
    - path: "web-ui/src/hooks/usePermissionUpdates.js"
      provides: "Hook managing a global WebSocket for PERMISSION_UPDATE messages"
      exports: ["usePermissionUpdates"]
    - path: "web-ui/src/pages/Channels.jsx"
      provides: "Updated Channels page that uses usePermissionUpdates"
      contains: "usePermissionUpdates"
    - path: "web-ui/src/context/ChannelContext.jsx"
      provides: "Updated ChannelContext that handles dynamic channel additions/removals"
      contains: "setChannels"
  key_links:
    - from: "web-ui/src/hooks/usePermissionUpdates.js"
      to: "ws(s)://host/ws"
      via: "dedicated lightweight WebSocket connection (NOT ConnectionManager)"
      pattern: "new WebSocket"
    - from: "web-ui/src/hooks/usePermissionUpdates.js"
      to: "web-ui/src/context/ChannelContext.jsx"
      via: "calls setChannels on PERMISSION_UPDATE"
      pattern: "setChannels"
    - from: "web-ui/src/pages/Channels.jsx"
      to: "web-ui/src/hooks/usePermissionUpdates.js"
      via: "activates permission update listening inside ChannelProvider"
      pattern: "usePermissionUpdates"
---

<objective>
Add real-time channel list updates via PERMISSION_UPDATE messages using a dedicated global WebSocket.

Purpose: When an admin or dispatch user adds or removes channel assignments, the general user's UI should reflect these changes without requiring a page refresh. This completes the real-time sync story for UI-01 (channel list) and directly implements AUTHZ-006 (PERMISSION_UPDATE messages).

**Architecture (explicit):**
- **Per-channel ConnectionManager** (Plan 03-02): Each channel has its own ConnectionManager with WebSocket + WebRTC for audio/PTT. These handle SPEAKER_CHANGED, CHANNEL_STATE events for that specific channel.
- **Global permission WebSocket** (this plan): ONE separate lightweight WebSocket connection that only listens for PERMISSION_UPDATE messages. Uses raw WebSocket (not ConnectionManager) because it has no audio/WebRTC needs. Connects to the same `/ws` endpoint but only cares about permission-update messages.

These are two distinct connection types. The global WebSocket is fire-and-forget for listening; it does not join channels or create transports.

Output: usePermissionUpdates hook and updated Channels page wiring.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-browser-ui-for-general-users/03-RESEARCH.md
@.planning/phases/03-browser-ui-for-general-users/03-01-SUMMARY.md
@.planning/phases/03-browser-ui-for-general-users/03-02-SUMMARY.md
@.planning/phases/03-browser-ui-for-general-users/03-03-SUMMARY.md
@web-ui/src/context/ChannelContext.jsx
@web-ui/src/pages/Channels.jsx
@web-ui/src/hooks/useAuth.js
@src/shared/protocol.ts
@src/server/signaling/signalingHandlers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: usePermissionUpdates hook with global WebSocket</name>
  <files>
    web-ui/src/hooks/usePermissionUpdates.js
  </files>
  <action>
Create `web-ui/src/hooks/usePermissionUpdates.js` that manages a single global WebSocket connection for receiving PERMISSION_UPDATE messages.

This hook is intentionally separate from per-channel ConnectionManager connections. It uses a raw WebSocket because:
- No audio/WebRTC setup needed
- No channel join needed
- Only listens for PERMISSION_UPDATE messages
- Lightweight and independent

Hook signature: `usePermissionUpdates(wsUrl, token, onPermissionUpdate)`

Where:
- `wsUrl` is the full WebSocket URL (e.g., `wss://host/ws`) -- same as per-channel connections
- `token` is the raw JWT string
- `onPermissionUpdate` is a callback: `({ added: string[], removed: string[] }) => void`

Implementation:
1. Use `useRef` to hold WebSocket instance
2. Use `useState` for connection status (for debugging, not rendered)
3. In `useEffect` (deps: [wsUrl, token]):
   - If no token, skip
   - Create WebSocket: `new WebSocket(wsUrl, ['voiceping', token])` (same sub-protocol auth as SignalingClient, per SIG-002)
   - On message:
     - Parse JSON
     - Check message type against AUTHZ-006 format. The server sends PERMISSION_UPDATE via the signaling protocol. Check `src/shared/protocol.ts` for the exact message type string -- it should be `'permission-update'` (from SignalingType enum).
     - If type matches, extract `{ added, removed }` arrays and call `onPermissionUpdate`
     - Ignore all other message types (this WS will also receive heartbeat pings, etc.)
   - On close (abnormal): Auto-reconnect with simple backoff (2s, 4s, 8s, max 30s)
   - On error: Log warning, let close handler trigger reconnect
   - Cleanup: Close WebSocket on unmount (clean close, code 1000)
4. Return: `{ connected: boolean }` (for optional status display)

IMPORTANT: The server's heartbeat mechanism (SIG-003, 30-second interval) will send pings. The browser WebSocket API handles pong responses automatically, so no explicit ping/pong handling needed. However, the server may close stale connections. The auto-reconnect handles this.

NOTE: This WebSocket will authenticate via the JWT token sub-protocol. The server will accept the connection. However, since we don't send a `join-channel` message, the server won't create any transports or producers -- the connection is purely a listener. The PERMISSION_UPDATE message is sent by the heartbeat permission refresh (from PermissionSyncManager, Plan 02-03) to all connected clients whose permissions changed.
  </action>
  <verify>
    1. usePermissionUpdates creates a WebSocket with ['voiceping', token] sub-protocol
    2. Parses incoming messages and filters for PERMISSION_UPDATE type
    3. Calls onPermissionUpdate callback with { added, removed } arrays
    4. Auto-reconnects on abnormal close with backoff
    5. Cleans up WebSocket on unmount (code 1000)
    6. Does NOT join any channel or create any audio infrastructure
  </verify>
  <done>
    usePermissionUpdates hook manages a lightweight global WebSocket that listens for PERMISSION_UPDATE messages. Auto-reconnects on connection loss. Calls provided callback with added/removed channel arrays. Independent from per-channel ConnectionManager connections.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire permission updates into Channels page and ChannelContext</name>
  <files>
    web-ui/src/pages/Channels.jsx
    web-ui/src/context/ChannelContext.jsx
  </files>
  <action>
**Update `web-ui/src/pages/Channels.jsx`:**
Add the usePermissionUpdates hook inside the ChannelProvider tree so it has access to ChannelContext.

Since usePermissionUpdates needs `setChannels` from ChannelContext, and Channels.jsx renders ChannelProvider as a wrapper, we need a small inner component or restructure:

Option A (preferred -- simple inner component):
```jsx
function ChannelListWithPermissions({ wsUrl, token }) {
  const { setChannels } = useChannels();

  const handlePermissionUpdate = useCallback(({ added, removed }) => {
    setChannels(prev => {
      // Remove revoked channels
      const filtered = prev.filter(ch => !(removed || []).includes(ch.id));
      // Add new channels (with channelId as name for now)
      const newChannels = (added || []).map(id => ({ id, name: id }));
      return [...filtered, ...newChannels];
    });
  }, [setChannels]);

  usePermissionUpdates(wsUrl, token, handlePermissionUpdate);

  return <ChannelList wsUrl={wsUrl} token={token} />;
}
```

Then in the Channels page render:
```jsx
<ChannelProvider user={authUser}>
  <ChannelListWithPermissions wsUrl={wsUrl} token={token} />
</ChannelProvider>
```

This ensures usePermissionUpdates is called inside ChannelProvider so it can access setChannels.

**Update `web-ui/src/context/ChannelContext.jsx`** (minor):
Ensure `setChannels` accepts a function updater pattern (not just a new array). The existing implementation should already support this if it uses `useState`. Verify that `setChannels` is the raw state setter or wraps it to support both patterns:
- `setChannels([...newList])` -- direct value
- `setChannels(prev => [...filtered, ...newChannels])` -- function updater

If ChannelContext's `setChannels` was wrapped with `useCallback` in Plan 03-01, ensure the wrapper passes through function updaters correctly. The simplest approach: expose the raw `useState` setter for channels (React's setState natively supports function updaters).

Build and verify: `cd web-ui && npm run build`
  </action>
  <verify>
    1. Channels.jsx imports and uses usePermissionUpdates inside ChannelProvider tree
    2. PERMISSION_UPDATE with `added` channels causes new ChannelCards to appear
    3. PERMISSION_UPDATE with `removed` channels causes ChannelCards to disappear
    4. setChannels in ChannelContext supports function updater pattern
    5. Build succeeds: `cd web-ui && npm run build`
  </verify>
  <done>
    PERMISSION_UPDATE messages dynamically update the channel list in ChannelContext. New channels appear (as {id, name: id} objects) and removed channels disappear without page refresh. Global permission WebSocket operates independently from per-channel audio connections. Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. Permission update handler wired inside ChannelProvider tree
2. Adding a channel via admin/dispatch causes it to appear in user's UI
3. Removing a channel causes it to disappear from user's UI
4. Global WebSocket reconnects after temporary disconnection
5. Per-channel audio connections are unaffected by permission WebSocket
6. Build succeeds: `cd web-ui && npm run build`
</verification>

<success_criteria>
- PERMISSION_UPDATE dynamically adds/removes channels in the UI
- Global WebSocket is independent from per-channel ConnectionManager instances
- Auto-reconnect on connection loss
- No modifications to server-side code
- Build succeeds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-browser-ui-for-general-users/03-04-SUMMARY.md`
</output>
