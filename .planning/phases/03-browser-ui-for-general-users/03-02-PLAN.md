---
phase: 03-browser-ui-for-general-users
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - web-ui/src/hooks/useChannelConnection.js
  - web-ui/src/components/ChannelCard.jsx
autonomous: true

must_haves:
  truths:
    - "User sees a PTT button on each assigned channel card"
    - "User sees connection status per channel (connecting/connected/error)"
    - "User sees who is currently speaking on a channel"
    - "User sees visual busy indicator when someone is transmitting"
    - "All audio/WebSocket resources are cleaned up when leaving a channel"
  artifacts:
    - path: "web-ui/src/hooks/useChannelConnection.js"
      provides: "React hook wrapping ConnectionManager lifecycle for a single channel"
      exports: ["useChannelConnection"]
    - path: "web-ui/src/components/ChannelCard.jsx"
      provides: "Channel card component with PTT button and speaker status"
      exports: ["default"]
  key_links:
    - from: "web-ui/src/hooks/useChannelConnection.js"
      to: "@client/connectionManager"
      via: "imports and instantiates ConnectionManager (one per channel)"
      pattern: "ConnectionManager"
    - from: "web-ui/src/components/ChannelCard.jsx"
      to: "web-ui/src/hooks/useChannelConnection.js"
      via: "uses hook for connection lifecycle"
      pattern: "useChannelConnection"
    - from: "web-ui/src/components/ChannelCard.jsx"
      to: "web-ui/src/context/ChannelContext.jsx"
      via: "reads channelStates and calls updateChannelState"
      pattern: "useChannels"
    - from: "web-ui/src/components/ChannelCard.jsx"
      to: "@client/pttController"
      via: "creates PttController in useEffect with DOM container ref"
      pattern: "PttController"
---

<objective>
Build the per-channel connection hook and channel card component that wraps the existing vanilla TypeScript PTT modules in React.

Purpose: This is the core integration layer -- connecting React UI to the Phase 1 mediasoup-based audio system. Each ChannelCard manages its own ConnectionManager instance (one per channel) and PttController, enabling multi-channel PTT for general users.

**Architecture (explicit):**
- **Per-channel ConnectionManager**: Each channel gets its own ConnectionManager instance, which internally creates its own ReconnectingSignalingClient (WebSocket), MediasoupDevice, and TransportClient. This is the audio/PTT path.
- **Global WebSocket for PERMISSION_UPDATE**: A separate lightweight WebSocket connection (Plan 03-04) handles real-time permission changes. This is NOT managed by ConnectionManager.
- These are two distinct connection types with different purposes and lifecycles.

Output: useChannelConnection hook (one ConnectionManager per channel) and ChannelCard component (visual card with PTT button, busy indicator, and speaker display).
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-browser-ui-for-general-users/03-RESEARCH.md
@.planning/phases/03-browser-ui-for-general-users/03-01-SUMMARY.md
@src/client/connectionManager.ts
@src/client/pttController.ts
@src/client/ui/PttButton.ts
@src/client/audio/microphone.ts
@src/client/audio/feedback.ts
@src/client/mediasoup/device.ts
@src/client/mediasoup/transportClient.ts
@src/client/signaling/reconnectingClient.ts
@src/shared/protocol.ts
@src/shared/types.ts
@web-ui/vite.config.js
@web-ui/src/context/ChannelContext.jsx
@web-ui/src/hooks/useAuth.js
@web-ui/src/utils/tokenStorage.js
@web-ui/src/styles.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: useChannelConnection hook wrapping ConnectionManager</name>
  <files>web-ui/src/hooks/useChannelConnection.js</files>
  <action>
Create `web-ui/src/hooks/useChannelConnection.js` that wraps `ConnectionManager` from `@client/connectionManager` in a React hook. Use the @client alias configured in Plan 03-01.

IMPORTANT: The existing codebase has TWO audio systems:
1. Legacy `VoicePingAudioClient` (web-ui/src/utils/voicepingAudio.js) -- uses raw WebSocket + Opus encoding, used by Console.jsx
2. Phase 1 mediasoup-based system (`ConnectionManager`, `PttController`, etc. in src/client/) -- uses WebRTC with mediasoup SFU

Phase 3 must use the mediasoup-based system (Phase 1 modules). ConnectionManager takes a single channelId and manages one channel. For multi-channel, we create one ConnectionManager instance per channel (one per ChannelCard).

Import using the @client alias (from Plan 03-01 Vite config):
```javascript
import { ConnectionManager } from "@client/connectionManager";
```

The hook signature: `useChannelConnection(channelId, wsUrl, token)`

Where `wsUrl` is the full WebSocket URL: `ws(s)://${window.location.host}/ws` (per SIG-001, confirmed in Plan 03-01).

Returns: `{ connectionState, error, connectionManager }`

Implementation:
1. Use `useRef` to hold ConnectionManager instance (persists across renders)
2. Use `useState` for connectionState ('disconnected' | 'connecting' | 'connected' | 'reconnecting' | 'error')
3. Use `useState` for error (string | null)
4. Get `{ updateChannelState }` from `useChannels()` context
5. In `useEffect` (deps: [channelId, wsUrl, token]):
   - If no token, skip (not authenticated yet)
   - Create ConnectionManager with:
     - url: wsUrl (full WebSocket URL, e.g., `wss://host/ws`)
     - token: token (raw JWT string -- ConnectionManager's internal SignalingClient passes it as sub-protocol)
     - channelId: channelId
     - onStateChange: updates connectionState useState
     - onError: updates error useState
     - onChannelStateUpdate: calls updateChannelState from useChannels context with `{ isBusy: channelState.isBusy, speakerId: channelState.speakerId, speakerName: channelState.speakerName }`
     - onSpeakerChanged: calls updateChannelState with `{ isBusy: !!userId, speakerId: userId, speakerName: userName }`
   - Call `manager.connect()` (async, catch errors and set error state)
   - Store in ref
   - Return cleanup function that calls `manager.disconnect()`
6. Expose `connectionManager` ref value for PttController in ChannelCard -- ChannelCard needs access to the internal signalingClient, transportClient, microphoneManager. ConnectionManager exposes these via public getters: `getMicrophoneManager()`, `getTransportClient()`.

IMPORTANT - React 18 StrictMode: The cleanup function MUST properly call disconnect() on the ConnectionManager. In development, React 18 StrictMode will mount-unmount-mount, so the cleanup must be symmetric with setup. The second mount should create a fresh ConnectionManager instance.
  </action>
  <verify>
    1. useChannelConnection imports from @client/connectionManager (not relative path to src/client/)
    2. useEffect has proper cleanup calling disconnect()
    3. connectionState updates flow correctly via onStateChange callback
    4. useRef used for ConnectionManager instance (not useState)
    5. updateChannelState called on SPEAKER_CHANGED and CHANNEL_STATE events
  </verify>
  <done>
    useChannelConnection hook creates and manages a ConnectionManager instance per channel. Imports via @client alias. Connection state and errors exposed as React state. Cleanup symmetric with setup for StrictMode compatibility. Speaker/channel state updates flow to ChannelContext via updateChannelState.
  </done>
</task>

<task type="auto">
  <name>Task 2: ChannelCard component with PTT button and speaker display</name>
  <files>web-ui/src/components/ChannelCard.jsx</files>
  <action>
Create `web-ui/src/components/ChannelCard.jsx` that renders a single channel with:
- Channel name display (from props -- uses {id, name} from ChannelContext)
- Connection status indicator (connecting/connected/reconnecting/error)
- PTT button (via PttController DOM injection into a ref container)
- Busy state indicator (UI-03)
- Active speaker name display (UI-04)

Implementation:
1. Accept props: `{ channel, wsUrl, token }` where `channel` is `{ id, name }` from ChannelContext
2. Use `useChannelConnection(channel.id, wsUrl, token)` for connection lifecycle
3. Use `useChannels()` from ChannelContext to read `channelStates[channel.id]`
4. Create `containerRef = useRef(null)` for PttButton DOM injection
5. Create `controllerRef = useRef(null)` for PttController instance

PttController integration via useEffect (deps: [connectionState]):
- Only create PttController when connectionState === 'connected'
- If already have a controller, destroy it first (cleanup from previous)
- Get the ConnectionManager instance from the hook (connectionManager ref)
- Get microphoneManager via `connectionManager.getMicrophoneManager()`
- Get transportClient via `connectionManager.getTransportClient()`
- Import PttController from `@client/pttController`
- Create PttController with the ConnectionManager's internal components:
  ```javascript
  import { PttController } from "@client/pttController";
  // Check PttController constructor signature in src/client/pttController.ts
  // It needs: signalingClient, transportClient, microphoneManager, audioFeedback, and options
  ```
- Call controller.init() (async, catch errors and log)
- Store in controllerRef
- Cleanup: call controller.destroy() in useEffect cleanup

IMPORTANT per UX-002 and UX-005 decisions:
- DO NOT modify PttButton or PttController source code
- PttController creates its own PttButton internally (UX-005)
- Pass buttonContainer as the ref div so PttButton renders into it
- PttMode 'hold' is default (press and hold to talk, release to stop)

Render structure:
```jsx
<div className={`channel-card ${isBusy ? "channel-card--busy" : ""}`}>
  <div className="channel-card__header">
    <h3 className="channel-card__name">{channel.name}</h3>
    <span className={`channel-card__status pill pill--${statusClass}`}>
      {connectionState}
    </span>
  </div>
  {isBusy && (
    <div className="channel-card__speaker">
      <span className="channel-card__speaker-icon">Speaking:</span>
      <span className="channel-card__speaker-name">{speakerName}</span>
    </div>
  )}
  <div className="channel-card__ptt" ref={containerRef}>
    {/* PttButton renders here via PttController */}
  </div>
  {error && <div className="channel-card__error">{error}</div>}
</div>
```

Where `isBusy` and `speakerName` come from `channelStates[channel.id]` via useChannels().
Where `statusClass` maps connectionState to CSS: connected -> 'ok', connecting -> 'info', reconnecting -> 'warn', error -> 'error', disconnected -> 'muted'.
  </action>
  <verify>
    1. ChannelCard.jsx accepts `channel` prop as `{ id, name }` object (not bare channelId)
    2. Renders channel.name (not channelId) in the header
    3. PttController created only when connected, destroyed on unmount
    4. Busy state and speaker name read from ChannelContext via channelStates[channel.id]
    5. containerRef div exists for PttButton DOM injection
    6. Imports use @client alias for PttController
    7. Component handles connection errors gracefully (shows error message)
  </verify>
  <done>
    ChannelCard component renders channel name (from {id, name} prop), connection status, PTT button (via PttController DOM injection), busy indicator (UI-03), and active speaker name (UI-04). All resources properly cleaned up on unmount. Imports use @client aliases.
  </done>
</task>

</tasks>

<verification>
1. useChannelConnection hook manages ConnectionManager lifecycle with proper cleanup
2. ChannelCard component renders PTT button via PttController integration
3. Speaker changes update channelStates in ChannelContext
4. Busy state visually indicated on channel card
5. Speaker name displayed when someone is transmitting
6. React 18 StrictMode double-mount does not cause errors or resource leaks
7. All imports use @client alias (not relative paths to src/client/)
</verification>

<success_criteria>
- useChannelConnection creates one ConnectionManager per channel with automatic reconnection
- ChannelCard renders channel name, PTT button, busy state, and speaker name
- PttController integrates via useRef + useEffect with proper cleanup
- Channel state updates flow from ConnectionManager events to ChannelContext to UI
- No modifications to existing src/client/ TypeScript modules (UX-002 decision)
- All TypeScript imports via @client/@shared aliases
</success_criteria>

<output>
After completion, create `.planning/phases/03-browser-ui-for-general-users/03-02-SUMMARY.md`
</output>
