---
phase: 03-browser-ui-for-general-users
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - web-ui/src/hooks/useChannelConnection.js
  - web-ui/src/components/ChannelCard.jsx
autonomous: true

must_haves:
  truths:
    - "Each channel card creates its own ConnectionManager with WebSocket + WebRTC lifecycle"
    - "PTT button renders inside channel card via PttController DOM injection"
    - "Channel busy state updates when SPEAKER_CHANGED event received"
    - "Active speaker name displays on the channel card"
    - "All resources are cleaned up on component unmount"
  artifacts:
    - path: "web-ui/src/hooks/useChannelConnection.js"
      provides: "React hook wrapping ConnectionManager lifecycle for a single channel"
      exports: ["useChannelConnection"]
    - path: "web-ui/src/components/ChannelCard.jsx"
      provides: "Channel card component with PTT button and speaker status"
      exports: ["default"]
  key_links:
    - from: "web-ui/src/hooks/useChannelConnection.js"
      to: "src/client/connectionManager.ts"
      via: "imports and instantiates ConnectionManager"
      pattern: "ConnectionManager"
    - from: "web-ui/src/components/ChannelCard.jsx"
      to: "web-ui/src/hooks/useChannelConnection.js"
      via: "uses hook for connection lifecycle"
      pattern: "useChannelConnection"
    - from: "web-ui/src/components/ChannelCard.jsx"
      to: "web-ui/src/context/ChannelContext.jsx"
      via: "reads channelStates and calls updateChannelState"
      pattern: "useChannels"
    - from: "web-ui/src/components/ChannelCard.jsx"
      to: "src/client/pttController.ts"
      via: "creates PttController in useEffect with DOM container ref"
      pattern: "PttController"
---

<objective>
Build the per-channel connection hook and channel card component that wraps the existing vanilla TypeScript PTT modules in React.

Purpose: This is the core integration layer -- connecting React UI to the Phase 1 mediasoup-based audio system. Each ChannelCard manages its own connection lifecycle and PTT button, enabling multi-channel PTT for general users.

Output: useChannelConnection hook (one ConnectionManager per channel) and ChannelCard component (visual card with PTT button, busy indicator, and speaker display).
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-browser-ui-for-general-users/03-RESEARCH.md
@.planning/phases/03-browser-ui-for-general-users/03-01-SUMMARY.md
@src/client/connectionManager.ts
@src/client/pttController.ts
@src/client/ui/PttButton.ts
@src/client/audio/microphone.ts
@src/client/audio/feedback.ts
@src/client/mediasoup/device.ts
@src/client/mediasoup/transportClient.ts
@src/client/signaling/reconnectingClient.ts
@src/shared/protocol.ts
@src/shared/types.ts
@web-ui/src/context/ChannelContext.jsx
@web-ui/src/hooks/useAuth.js
@web-ui/src/utils/tokenStorage.js
@web-ui/src/styles.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: useChannelConnection hook wrapping ConnectionManager</name>
  <files>web-ui/src/hooks/useChannelConnection.js</files>
  <action>
Create `web-ui/src/hooks/useChannelConnection.js` that wraps `ConnectionManager` from `src/client/connectionManager.ts` in a React hook.

IMPORTANT: The existing codebase has TWO audio systems:
1. Legacy `VoicePingAudioClient` (web-ui/src/utils/voicepingAudio.js) -- uses raw WebSocket + Opus encoding, used by Console.jsx
2. Phase 1 mediasoup-based system (`ConnectionManager`, `PttController`, etc. in src/client/) -- uses WebRTC with mediasoup SFU

Phase 3 must use the mediasoup-based system (Phase 1 modules). However, ConnectionManager currently takes a single channelId and manages one channel. For multi-channel, we need one ConnectionManager instance per channel.

CRITICAL: Before importing from src/client/, check whether Vite can resolve these TypeScript imports. The web-ui uses Vite and the src/client/ modules are TypeScript. We need to verify the Vite config handles this. If the existing Vite config does NOT support importing from src/client/ TypeScript modules, the hook should note that the import paths may need adjustment. Read `web-ui/vite.config.js` or `web-ui/vite.config.ts` first.

The hook signature: `useChannelConnection(channelId, wsUrl, token)`

Returns: `{ connectionState, error, signalingClient, transportClient, microphoneManager, audioFeedback }`

Implementation:
1. Use `useRef` to hold ConnectionManager instance (persists across renders)
2. Use `useState` for connectionState ('disconnected' | 'connecting' | 'connected' | 'reconnecting' | 'error')
3. Use `useState` for error (string | null)
4. In `useEffect` (deps: [channelId, wsUrl, token]):
   - If no token, skip (not authenticated yet)
   - Create ConnectionManager with:
     - url: wsUrl
     - token: token
     - channelId: channelId
     - onStateChange: updates connectionState state
     - onError: updates error state
     - onChannelStateUpdate: calls updateChannelState from useChannels context
     - onSpeakerChanged: calls updateChannelState with speaker info
   - Call `manager.connect()` (async, catch errors)
   - Store in ref
   - Return cleanup function that calls `manager.disconnect()`
5. Also expose the internal sub-components (signalingClient, transportClient, etc.) via ConnectionManager's public getters. This is needed for PttController in ChannelCard.

IMPORTANT - React 18 StrictMode: The cleanup function MUST properly call disconnect() on the ConnectionManager. In development, React 18 StrictMode will mount-unmount-mount, so the cleanup must be symmetric with setup. The second mount should create a fresh ConnectionManager instance.

If importing TypeScript modules from src/client/ is not feasible with the current Vite config, create a lightweight wrapper that uses the SAME patterns as ConnectionManager but in plain JS. However, prefer direct import if Vite supports it.
  </action>
  <verify>
    1. Read web-ui/vite.config.js to confirm TypeScript import support
    2. Check that useEffect has proper cleanup calling disconnect()
    3. Verify connectionState updates flow correctly
    4. Confirm useRef used for ConnectionManager instance (not useState)
  </verify>
  <done>
    useChannelConnection hook creates and manages a ConnectionManager instance per channel. Connection state and errors exposed as React state. Cleanup symmetric with setup for StrictMode compatibility. Speaker/channel state updates flow to ChannelContext.
  </done>
</task>

<task type="auto">
  <name>Task 2: ChannelCard component with PTT button and speaker display</name>
  <files>web-ui/src/components/ChannelCard.jsx</files>
  <action>
Create `web-ui/src/components/ChannelCard.jsx` that renders a single channel with:
- Channel name/ID display
- Connection status indicator (connecting/connected/reconnecting/error)
- PTT button (via PttController DOM injection into a ref container)
- Busy state indicator (UI-03)
- Active speaker name display (UI-04)

Implementation:
1. Accept props: `{ channelId, channelName, wsUrl, token }`
2. Use `useChannelConnection(channelId, wsUrl, token)` for connection lifecycle
3. Use `useChannels()` from ChannelContext to read `channelStates[channelId]`
4. Create `containerRef = useRef(null)` for PttButton DOM injection
5. Create `controllerRef = useRef(null)` for PttController instance

PttController integration via useEffect (deps: [connectionState, channelId]):
- Only create PttController when connectionState === 'connected'
- If already have a controller, destroy it first (cleanup from previous)
- Get signalingClient, transportClient, microphoneManager, audioFeedback from the connection hook return values
- Create PttController with: signalingClient, transportClient, microphoneManager, audioFeedback, and options { channelId, pttMode: 'hold', buttonContainer: containerRef.current }
- Call controller.init() (async, catch errors and log)
- Store in controllerRef
- Cleanup: call controller.destroy() in useEffect cleanup

IMPORTANT per UX-002 and UX-005 decisions:
- DO NOT modify PttButton or PttController source code
- PttController creates its own PttButton internally (UX-005)
- Pass buttonContainer as the ref div so PttButton renders into it
- PttMode 'hold' is default (press and hold to talk, release to stop)

Render structure:
```jsx
<div className="channel-card {busy ? 'channel-card--busy' : ''}">
  <div className="channel-card__header">
    <h3 className="channel-card__name">{channelName || channelId}</h3>
    <span className="channel-card__status pill pill--{statusClass}">
      {connectionState}
    </span>
  </div>
  {isBusy && (
    <div className="channel-card__speaker">
      <span className="channel-card__speaker-icon">Speaking:</span>
      <span className="channel-card__speaker-name">{speakerName}</span>
    </div>
  )}
  <div className="channel-card__ptt" ref={containerRef}>
    {/* PttButton renders here via PttController */}
  </div>
  {error && <div className="channel-card__error">{error}</div>}
</div>
```

NOTE: If direct TypeScript imports from src/client/ don't work with Vite, this component may need to take connection objects as props instead of using the hook directly. Adapt based on findings from Task 1.
  </action>
  <verify>
    1. ChannelCard.jsx renders with channel name and connection status
    2. PttController created only when connected, destroyed on unmount
    3. Busy state and speaker name read from ChannelContext
    4. containerRef div exists for PttButton DOM injection
    5. Component handles connection errors gracefully (shows error message)
  </verify>
  <done>
    ChannelCard component renders channel info, connection status, PTT button (via PttController DOM injection), busy indicator (UI-03), and active speaker name (UI-04). All resources properly cleaned up on unmount.
  </done>
</task>

</tasks>

<verification>
1. useChannelConnection hook manages ConnectionManager lifecycle with proper cleanup
2. ChannelCard component renders PTT button via PttController integration
3. Speaker changes update channelStates in ChannelContext
4. Busy state visually indicated on channel card
5. Speaker name displayed when someone is transmitting
6. React 18 StrictMode double-mount does not cause errors or resource leaks
</verification>

<success_criteria>
- useChannelConnection creates one ConnectionManager per channel with automatic reconnection
- ChannelCard renders channel name, PTT button, busy state, and speaker name
- PttController integrates via useRef + useEffect with proper cleanup
- Channel state updates flow from ConnectionManager events to ChannelContext to UI
- No modifications to existing src/client/ TypeScript modules (UX-002 decision)
</success_criteria>

<output>
After completion, create `.planning/phases/03-browser-ui-for-general-users/03-02-SUMMARY.md`
</output>
