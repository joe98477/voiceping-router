---
phase: 03-browser-ui-for-general-users
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - web-ui/src/utils/tokenStorage.js
  - web-ui/src/hooks/useAuth.js
  - web-ui/src/context/ChannelContext.jsx
autonomous: true

must_haves:
  truths:
    - "JWT token persists in sessionStorage across page refresh"
    - "JWT token is cleared when browser tab closes"
    - "User authentication state is available to all components via hook"
    - "Channel list state is available globally via Context API"
  artifacts:
    - path: "web-ui/src/utils/tokenStorage.js"
      provides: "sessionStorage helpers for JWT persistence"
      exports: ["saveToken", "getToken", "removeToken", "TOKEN_KEY"]
    - path: "web-ui/src/hooks/useAuth.js"
      provides: "Authentication hook with login/logout/user state"
      exports: ["useAuth"]
    - path: "web-ui/src/context/ChannelContext.jsx"
      provides: "Global channel and speaker state via Context API"
      exports: ["ChannelProvider", "useChannels"]
  key_links:
    - from: "web-ui/src/hooks/useAuth.js"
      to: "web-ui/src/utils/tokenStorage.js"
      via: "import getToken/saveToken/removeToken"
      pattern: "import.*tokenStorage"
    - from: "web-ui/src/context/ChannelContext.jsx"
      to: "web-ui/src/hooks/useAuth.js"
      via: "channel list derived from authenticated user data"
      pattern: "useAuth|user"
---

<objective>
Create the session management foundation and shared state layer for the general user UI.

Purpose: SEC-04 requires session persistence across page refresh. All downstream components need auth state and channel list. This plan establishes the foundation that Plans 02 and 03 build on.

Output: tokenStorage utility, useAuth hook, and ChannelContext provider -- the three building blocks every Phase 3 component depends on.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-browser-ui-for-general-users/03-RESEARCH.md
@web-ui/src/api.js
@web-ui/src/App.jsx
@web-ui/src/pages/Login.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Token storage utility and useAuth hook</name>
  <files>
    web-ui/src/utils/tokenStorage.js
    web-ui/src/hooks/useAuth.js
  </files>
  <action>
Create `web-ui/src/utils/tokenStorage.js` with sessionStorage helpers for JWT persistence (SEC-04 requirement). Export:
- `TOKEN_KEY = 'voiceping_session_token'`
- `saveToken(token)` - stores in sessionStorage
- `getToken()` - retrieves from sessionStorage
- `removeToken()` - removes from sessionStorage

Use sessionStorage (NOT localStorage) because SEC-04 requires "session persists across page refresh" but should clear on tab close.

Create `web-ui/src/hooks/useAuth.js` with a React hook that:
1. On mount, checks sessionStorage for existing token via `getToken()`
2. If token exists, decodes it to extract user info (userId, displayName, role, channelIds, eventId). Use manual base64 JSON decode of JWT payload (split on '.', atob middle segment, JSON.parse) -- do NOT add jwt-decode dependency since it's not in package.json
3. Checks token expiry (exp claim * 1000 > Date.now()). If expired, removes token and sets user to null
4. Exports `{ user, token, login(token), logout(), isAuthenticated }` where:
   - `login(token)` saves to sessionStorage and decodes user
   - `logout()` removes from sessionStorage and clears user state
   - `user` contains decoded JWT payload (userId, displayName, globalRole, channelIds, etc.)
   - `token` is the raw JWT string for passing to WebSocket connections
   - `isAuthenticated` is boolean (user !== null)

IMPORTANT: The existing app uses cookie-based auth via `/api/auth/login` (see Login.jsx calling `apiPost("/api/auth/login")`). The useAuth hook needs to work alongside the existing cookie auth. For Phase 3, the router token comes from `apiPost("/api/router/token", { eventId })` (see Console.jsx line 163). The useAuth hook stores THIS router token (not the cookie session), which contains the channelIds and is used for WebSocket auth. The existing cookie auth flow stays untouched.

Do NOT modify Login.jsx or the existing cookie auth flow. The useAuth hook is specifically for the ROUTER JWT token that contains channel assignments.
  </action>
  <verify>
    Manually verify:
    1. `tokenStorage.js` exports all 4 named exports
    2. `useAuth.js` exports useAuth hook
    3. No new dependencies added to package.json
    4. Token decode handles base64url (replace - with +, _ with /) before atob
  </verify>
  <done>
    tokenStorage.js provides sessionStorage CRUD for JWT. useAuth.js decodes JWT payload, checks expiry, and provides user/token/login/logout interface. No new npm dependencies added.
  </done>
</task>

<task type="auto">
  <name>Task 2: Channel Context provider for global state</name>
  <files>web-ui/src/context/ChannelContext.jsx</files>
  <action>
Create `web-ui/src/context/ChannelContext.jsx` that provides global channel state to all child components. This context manages:

1. `channels` - Array of channel IDs the user is assigned to (from JWT channelIds claim)
2. `channelStates` - Object mapping channelId to `{ isBusy: boolean, speakerId: string|null, speakerName: string|null }`
3. `updateChannelState(channelId, stateUpdate)` - Merges partial state update for a channel
4. `setChannels(channelIds)` - Updates the full channel list (used when PERMISSION_UPDATE arrives)

Export:
- `ChannelProvider` component - wraps children with context, accepts `user` prop (decoded JWT)
- `useChannels()` hook - returns `{ channels, channelStates, updateChannelState, setChannels }`
- Throws descriptive error if useChannels is called outside ChannelProvider

The ChannelProvider should:
- Initialize channels from `user.channelIds` (or empty array if not present) via useEffect on user change
- Initialize channelStates as empty object `{}`
- Use `useState` for both channels and channelStates
- Use `useCallback` for updateChannelState and setChannels to prevent re-render cascades

This context does NOT manage WebSocket connections or audio -- it's purely state. Connection hooks (Plan 02) will call `updateChannelState` when receiving SPEAKER_CHANGED and CHANNEL_STATE events from the server.
  </action>
  <verify>
    Manually verify:
    1. ChannelContext.jsx exports ChannelProvider and useChannels
    2. useChannels throws error when used outside provider
    3. updateChannelState merges partial state (not replaces)
    4. useCallback used for callback functions
  </verify>
  <done>
    ChannelContext.jsx provides global channel state management via React Context API. ChannelProvider accepts user prop and initializes channel list from JWT. useChannels hook provides channels, channelStates, and updater functions.
  </done>
</task>

</tasks>

<verification>
1. All three files exist and export correctly
2. No new npm dependencies in web-ui/package.json
3. sessionStorage used (not localStorage) for token
4. JWT decode handles standard JWT format without external library
5. Context throws descriptive error when used outside provider
</verification>

<success_criteria>
- tokenStorage.js provides save/get/remove for sessionStorage JWT
- useAuth.js decodes JWT, checks expiry, exposes user/token/login/logout
- ChannelContext.jsx provides ChannelProvider with channels and channelStates
- Zero new dependencies added
- Code follows existing web-ui patterns (functional components, hooks, .jsx extension)
</success_criteria>

<output>
After completion, create `.planning/phases/03-browser-ui-for-general-users/03-01-SUMMARY.md`
</output>
