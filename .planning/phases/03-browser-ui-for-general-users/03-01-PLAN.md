---
phase: 03-browser-ui-for-general-users
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - web-ui/vite.config.js
  - web-ui/src/utils/tokenStorage.js
  - web-ui/src/hooks/useAuth.js
  - web-ui/src/context/ChannelContext.jsx
autonomous: true

must_haves:
  truths:
    - "User stays logged in after page refresh (session token persists in sessionStorage)"
    - "User session clears when browser tab is closed (sessionStorage, not localStorage)"
    - "User authentication state is available to all components via useAuth hook"
    - "Channel list derived from JWT is available globally via ChannelContext"
    - "Vite can build web-ui code that imports TypeScript modules from src/client/"
  artifacts:
    - path: "web-ui/vite.config.js"
      provides: "Vite config updated to resolve TypeScript imports from src/client/"
      contains: "resolve"
    - path: "web-ui/src/utils/tokenStorage.js"
      provides: "sessionStorage helpers for JWT persistence"
      exports: ["saveToken", "getToken", "removeToken", "TOKEN_KEY"]
    - path: "web-ui/src/hooks/useAuth.js"
      provides: "Authentication hook with login/logout/user state"
      exports: ["useAuth"]
    - path: "web-ui/src/context/ChannelContext.jsx"
      provides: "Global channel and speaker state via Context API"
      exports: ["ChannelProvider", "useChannels"]
  key_links:
    - from: "web-ui/src/hooks/useAuth.js"
      to: "web-ui/src/utils/tokenStorage.js"
      via: "import getToken/saveToken/removeToken"
      pattern: "import.*tokenStorage"
    - from: "web-ui/src/context/ChannelContext.jsx"
      to: "web-ui/src/hooks/useAuth.js"
      via: "channel list derived from authenticated user data"
      pattern: "useAuth|user"
---

<objective>
Create the session management foundation, shared state layer, and Vite build configuration for the general user UI.

Purpose: SEC-04 requires session persistence across page refresh. All downstream components need auth state and channel list. The Vite config must be updated to resolve TypeScript imports from src/client/ (ConnectionManager, PttController, etc.) since the existing config has no such support. This plan establishes the foundation that Plans 02-05 build on.

Output: Updated Vite config for TypeScript imports, tokenStorage utility, useAuth hook, and ChannelContext provider -- the building blocks every Phase 3 component depends on.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-browser-ui-for-general-users/03-RESEARCH.md
@web-ui/vite.config.js
@web-ui/src/api.js
@web-ui/src/App.jsx
@web-ui/src/pages/Login.jsx
@web-ui/src/pages/Console.jsx
@src/client/connectionManager.ts
@src/client/pttController.ts
@src/shared/protocol.ts
@src/shared/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Vite config for TypeScript imports and WebSocket URL discovery</name>
  <files>
    web-ui/vite.config.js
  </files>
  <action>
Update `web-ui/vite.config.js` to support importing TypeScript modules from `src/client/` and `src/shared/`.

The current Vite config is minimal (just React plugin, port 5173). Plans 02-04 need to import ConnectionManager from `src/client/connectionManager.ts`, PttController from `src/client/pttController.ts`, and types from `src/shared/`. Without config changes, Vite cannot resolve these TypeScript imports from outside the web-ui directory.

Steps:
1. Read the current `web-ui/vite.config.js` to confirm its structure
2. Add the following to the Vite config:
   - `resolve.alias`: Map `@client` to the absolute path of `src/client/` and `@shared` to `src/shared/`
   - OR use `resolve.alias` to allow bare `../../src/client/` imports to resolve correctly
3. Ensure TypeScript files (.ts) outside web-ui/ can be processed by Vite's esbuild transform

The recommended approach (simplest):
```javascript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@client": path.resolve(__dirname, "../src/client"),
      "@shared": path.resolve(__dirname, "../src/shared"),
    },
  },
  server: {
    port: 5173,
  },
});
```

After updating, verify the config works by running `cd web-ui && npx vite build --mode development 2>&1 | head -20` (just check it doesn't error on the config itself).

Also verify the WebSocket URL format. Read `src/server/index.ts` line ~234 to confirm the server logs `ws://host:port/ws`. Read `src/client/signaling/signalingClient.ts` to confirm the client connects with `new WebSocket(url, ['voiceping', token])` where url is the full WebSocket URL (e.g., `ws://localhost:3000/ws`).

**Document findings for downstream plans:**
- The WebSocket URL for the mediasoup signaling server is: `ws(s)://${window.location.host}/ws` (in production behind nginx) or `ws://localhost:3000/ws` (in development). This matches SIG-001 decision.
- The SignalingClient passes the token as a WebSocket sub-protocol: `['voiceping', token]` (per SIG-002 decision).
- ConnectionManager takes `{ url, token, channelId, ... }` where `url` is the full WebSocket URL.
  </action>
  <verify>
    1. `web-ui/vite.config.js` contains resolve.alias for @client and @shared
    2. `cd web-ui && npx vite build --mode development` does not error on config parsing
    3. Documented: WebSocket URL is `ws(s)://${host}/ws`, token passed as sub-protocol
  </verify>
  <done>
    Vite config updated with path aliases for @client (src/client/) and @shared (src/shared/). WebSocket URL format confirmed: full URL to /ws path, token as sub-protocol. Downstream plans can import from @client/connectionManager, @client/pttController, etc.
  </done>
</task>

<task type="auto">
  <name>Task 2: Token storage utility, useAuth hook, and ChannelContext</name>
  <files>
    web-ui/src/utils/tokenStorage.js
    web-ui/src/hooks/useAuth.js
    web-ui/src/context/ChannelContext.jsx
  </files>
  <action>
**Create `web-ui/src/utils/tokenStorage.js`** with sessionStorage helpers for JWT persistence (SEC-04 requirement). Export:
- `TOKEN_KEY = 'voiceping_session_token'`
- `saveToken(token)` - stores in sessionStorage
- `getToken()` - retrieves from sessionStorage
- `removeToken()` - removes from sessionStorage

Use sessionStorage (NOT localStorage) because SEC-04 requires "session persists across page refresh" but should clear on tab close.

**Create `web-ui/src/hooks/useAuth.js`** with a React hook that:
1. On mount, checks sessionStorage for existing token via `getToken()`
2. If token exists, decodes it to extract user info (userId, displayName, role, channelIds, eventId). Use manual base64 JSON decode of JWT payload (split on '.', atob middle segment, JSON.parse) -- do NOT add jwt-decode dependency since it's not in package.json
3. Checks token expiry (exp claim * 1000 > Date.now()). If expired, removes token and sets user to null
4. Exports `{ user, token, login(token), logout(), isAuthenticated }` where:
   - `login(token)` saves to sessionStorage and decodes user
   - `logout()` removes from sessionStorage and clears user state
   - `user` contains decoded JWT payload (userId, displayName, globalRole, channelIds, etc.)
   - `token` is the raw JWT string for passing to WebSocket connections
   - `isAuthenticated` is boolean (user !== null)

IMPORTANT: The existing app uses cookie-based auth via `/api/auth/login` (see Login.jsx calling `apiPost("/api/auth/login")`). The useAuth hook needs to work alongside the existing cookie auth. For Phase 3, the router token comes from `apiPost("/api/router/token", { eventId })` (see Console.jsx line 163). The useAuth hook stores THIS router token (not the cookie session), which contains the channelIds and is used for WebSocket auth. The existing cookie auth flow stays untouched.

Do NOT modify Login.jsx or the existing cookie auth flow. The useAuth hook is specifically for the ROUTER JWT token that contains channel assignments.

**Create `web-ui/src/context/ChannelContext.jsx`** that provides global channel state to all child components. This context manages:

1. `channels` - Array of objects: `[{ id: channelId, name: channelName || channelId }]`. Initialize from JWT channelIds (names populated later if API available, otherwise use channelId as display name).
2. `channelStates` - Object mapping channelId to `{ isBusy: boolean, speakerId: string|null, speakerName: string|null }`
3. `updateChannelState(channelId, stateUpdate)` - Merges partial state update for a channel
4. `setChannels(channelList)` - Updates the full channel list (used when PERMISSION_UPDATE arrives)

**Channel name handling (UI-01):**
The JWT from `/api/router/token` only contains channelIds (no names). The `/api/events/:eventId/overview` returns full channel objects with names, BUT it requires DISPATCH/ADMIN role and is too heavy for general users.

Approach: In the Channels page (Plan 03-03), after getting the router token, make a lightweight call to fetch channel metadata. The control-plane has `/api/events/:eventId/overview` but it's role-restricted. For MVP: use channelId as display name. Add a comment noting this is a known limitation -- a future `/api/events/:eventId/my-channels` endpoint could return channel names for general users. The ChannelContext stores `{ id, name }` objects to be ready for when names become available.

Export:
- `ChannelProvider` component - wraps children with context, accepts `user` prop (decoded JWT)
- `useChannels()` hook - returns `{ channels, channelStates, updateChannelState, setChannels }`
- Throws descriptive error if useChannels is called outside ChannelProvider

The ChannelProvider should:
- Initialize channels from `user.channelIds` mapped to `[{ id, name: id }]` via useEffect on user change
- Initialize channelStates as empty object `{}`
- Use `useState` for both channels and channelStates
- Use `useCallback` for updateChannelState and setChannels to prevent re-render cascades

This context does NOT manage WebSocket connections or audio -- it's purely state. Connection hooks (Plan 02) will call `updateChannelState` when receiving SPEAKER_CHANGED and CHANNEL_STATE events from the server.
  </action>
  <verify>
    Manually verify:
    1. `tokenStorage.js` exports all 4 named exports
    2. `useAuth.js` exports useAuth hook
    3. `ChannelContext.jsx` exports ChannelProvider and useChannels
    4. No new dependencies added to package.json
    5. Token decode handles base64url (replace - with +, _ with /) before atob
    6. useChannels throws error when used outside provider
    7. channels array contains `{ id, name }` objects (not bare strings)
    8. useCallback used for callback functions
  </verify>
  <done>
    tokenStorage.js provides sessionStorage CRUD for JWT. useAuth.js decodes JWT payload, checks expiry, and provides user/token/login/logout interface. ChannelContext.jsx provides ChannelProvider with channels as `[{id, name}]` objects and channelStates. Channel names default to channelId (known MVP limitation; ready for name API when available). Zero new dependencies added.
  </done>
</task>

</tasks>

<verification>
1. All four files exist and export correctly
2. No new npm dependencies in web-ui/package.json
3. sessionStorage used (not localStorage) for token
4. JWT decode handles standard JWT format without external library
5. Context throws descriptive error when used outside provider
6. Vite config has resolve.alias for @client and @shared
7. `cd web-ui && npx vite build --mode development` completes without config errors
</verification>

<success_criteria>
- Vite config enables TypeScript imports from src/client/ and src/shared/ via @client/@shared aliases
- tokenStorage.js provides save/get/remove for sessionStorage JWT
- useAuth.js decodes JWT, checks expiry, exposes user/token/login/logout
- ChannelContext.jsx provides ChannelProvider with channels as {id, name} objects and channelStates
- Zero new dependencies added
- Code follows existing web-ui patterns (functional components, hooks, .jsx extension)
- WebSocket URL format documented: ws(s)://host/ws with token as sub-protocol
</success_criteria>

<output>
After completion, create `.planning/phases/03-browser-ui-for-general-users/03-01-SUMMARY.md`
</output>
