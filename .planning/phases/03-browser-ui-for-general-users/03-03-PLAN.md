---
phase: 03-browser-ui-for-general-users
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - web-ui/src/components/ChannelList.jsx
  - web-ui/src/pages/Channels.jsx
  - web-ui/src/App.jsx
  - web-ui/src/styles.css
autonomous: true

must_haves:
  truths:
    - "User navigating to /event/:eventId/channels sees their assigned channel list"
    - "Each channel in the list has a working PTT button"
    - "Empty state shown when user has no assigned channels"
    - "Unauthenticated users are redirected to /login"
    - "Page displays channel busy state and active speaker per channel"
  artifacts:
    - path: "web-ui/src/components/ChannelList.jsx"
      provides: "List component rendering ChannelCard for each assigned channel"
      exports: ["default"]
    - path: "web-ui/src/pages/Channels.jsx"
      provides: "Main page for general users with channel list and auth"
      exports: ["default"]
    - path: "web-ui/src/App.jsx"
      provides: "Updated routing with /event/:eventId/channels route"
      contains: "Channels"
    - path: "web-ui/src/styles.css"
      provides: "Styles for channel cards, channel list, and channels page"
      contains: "channel-card"
  key_links:
    - from: "web-ui/src/App.jsx"
      to: "web-ui/src/pages/Channels.jsx"
      via: "Route element at /event/:eventId/channels"
      pattern: "channels.*Channels"
    - from: "web-ui/src/pages/Channels.jsx"
      to: "web-ui/src/components/ChannelList.jsx"
      via: "renders ChannelList inside ChannelProvider"
      pattern: "ChannelList|ChannelProvider"
    - from: "web-ui/src/components/ChannelList.jsx"
      to: "web-ui/src/components/ChannelCard.jsx"
      via: "maps channels array to ChannelCard components"
      pattern: "ChannelCard"
    - from: "web-ui/src/pages/Channels.jsx"
      to: "web-ui/src/hooks/useAuth.js"
      via: "gets router token and stores via useAuth"
      pattern: "useAuth"
---

<objective>
Assemble the complete Channels page by combining ChannelList, ChannelCard, and wiring into the React Router. Add PERMISSION_UPDATE handling and CSS styling.

Purpose: This plan delivers the user-facing page that satisfies all four UI requirements (UI-01 through UI-04) and SEC-04. After this plan, general users have a working PTT interface.

Output: ChannelList component, Channels page, updated App.jsx routing, PERMISSION_UPDATE handler in ChannelContext, and CSS for channel cards.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-browser-ui-for-general-users/03-RESEARCH.md
@.planning/phases/03-browser-ui-for-general-users/03-01-SUMMARY.md
@.planning/phases/03-browser-ui-for-general-users/03-02-SUMMARY.md
@web-ui/src/App.jsx
@web-ui/src/styles.css
@web-ui/src/api.js
@web-ui/src/pages/Events.jsx
@web-ui/src/pages/Console.jsx
@web-ui/src/context/ChannelContext.jsx
@web-ui/src/hooks/useAuth.js
@web-ui/src/hooks/useChannelConnection.js
@web-ui/src/components/ChannelCard.jsx
@web-ui/src/utils/tokenStorage.js
@src/shared/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: ChannelList component and Channels page</name>
  <files>
    web-ui/src/components/ChannelList.jsx
    web-ui/src/pages/Channels.jsx
  </files>
  <action>
Create `web-ui/src/components/ChannelList.jsx`:
- Import `useChannels` from ChannelContext
- Import `ChannelCard` component
- Accept props: `{ wsUrl, token }` (passed down from Channels page)
- Read `channels` array from useChannels()
- If channels is empty, render empty state: `<div className="channel-list__empty">No channels assigned. Contact your dispatch operator to get channel access.</div>`
- Otherwise, render channels in a grid: `<div className="channel-list">{channels.map(channelId => <ChannelCard key={channelId} channelId={channelId} channelName={channelId} wsUrl={wsUrl} token={token} />)}</div>`
- Use channelId as both key and channelName (the JWT only has IDs; channel names require an API call that can be added later)

Create `web-ui/src/pages/Channels.jsx`:
- This is the main page for general users (the Phase 3 deliverable)
- Accept props: `{ user, onLogout }` (same pattern as existing Console.jsx and Dispatch.jsx)
- Use `useParams()` to get `eventId` from URL
- Use `useAuth()` hook to manage router token
- On mount (useEffect with [eventId]):
  1. Call `apiPost("/api/router/token", { eventId })` to get a router JWT (same pattern as Console.jsx line 163)
  2. Store the token via useAuth's login() method
  3. Handle errors (403 = not active in event, show message)
- Compute wsUrl: Use `getRouterWsUrl()` from existing `web-ui/src/utils/voicepingAudio.js` (reuse existing utility, don't duplicate). But use the NEW mediasoup WebSocket URL which is at `/ws` path (per SIG-001 decision). So: `const wsUrl = getRouterWsUrl() + '/ws'` OR derive from window.location. Check what ConnectionManager expects -- it takes a full WebSocket URL.

IMPORTANT: The WebSocket URL for the mediasoup signaling server is different from the legacy VoicePingAudioClient. The mediasoup server runs on the main server port with `/ws` path (SIG-001). Check the existing test page (src/client/test/pttDemo.ts) to see what URL format ConnectionManager expects. Read the file to confirm.

- Wrap ChannelList in ChannelProvider:
```jsx
<ChannelProvider user={decodedUser}>
  <ChannelList wsUrl={wsUrl} token={routerToken} />
</ChannelProvider>
```

Where `decodedUser` comes from useAuth().user (the decoded JWT payload containing channelIds).

Page layout (follow existing page patterns from Dispatch.jsx):
```jsx
<div className="channels-page">
  <header className="channels-page__topbar panel">
    <div className="channels-page__brand">
      <span>ConnectVoice</span>
      <h1>My Channels</h1>
    </div>
    <div className="channels-page__actions">
      <button className="btn" onClick={onLogout}>Log out</button>
    </div>
  </header>
  {error && <div className="alert">{error}</div>}
  {loading ? (
    <div className="screen screen--center">Loading channels...</div>
  ) : (
    <ChannelProvider user={authUser}>
      <ChannelList wsUrl={wsUrl} token={token} />
    </ChannelProvider>
  )}
</div>
```

Handle the case where router token request fails: show error with retry button.
  </action>
  <verify>
    1. ChannelList.jsx renders ChannelCard for each channel from context
    2. ChannelList.jsx shows empty state when no channels
    3. Channels.jsx fetches router token on mount
    4. Channels.jsx wraps content in ChannelProvider
    5. Channels.jsx handles token fetch errors gracefully
  </verify>
  <done>
    ChannelList renders a ChannelCard per assigned channel with empty state handling. Channels page fetches router token, initializes auth context, and renders the channel list with proper error handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Route wiring and CSS styling</name>
  <files>
    web-ui/src/App.jsx
    web-ui/src/styles.css
  </files>
  <action>
**Update App.jsx:**
1. Import the new Channels page: `import Channels from "./pages/Channels.jsx";`
2. Add a new route for general users at `/event/:eventId/channels`:
```jsx
<Route
  path="/event/:eventId/channels"
  element={
    user ? (
      needsSetup ? (
        <Navigate to="/first-run" replace />
      ) : (
        <Channels user={user} onLogout={handleLogout} />
      )
    ) : (
      <Navigate to="/login" replace />
    )
  }
/>
```
3. Place this route alongside the existing `/event/:eventId/dispatch` and `/event/:eventId/admin` routes
4. Do NOT modify any existing routes or components

**Also update Events.jsx** to add a "Channels" link for general users:
- In the event card actions section, add a link to `/event/${event.id}/channels` labeled "My Channels"
- This link should be visible to ALL users (not just ADMIN/DISPATCH)
- Place it before or alongside the existing "Dispatch View" link

**Add CSS to styles.css:**
Append styles at the end of the existing styles.css file. Follow the existing design language (use existing CSS variables: --ink, --muted, --paper, --surface, --accent, --accent-2, --shadow, --border, --radius-info-card, etc.). Style:

1. `.channels-page` - Full viewport page layout, same padding as `.screen`
2. `.channels-page__topbar` - Header bar, same pattern as `.control-plane__topbar`
3. `.channels-page__brand` - Brand text, same as `.control-plane__brand`
4. `.channels-page__actions` - Action buttons right-aligned

5. `.channel-list` - CSS grid, responsive: 1 column on mobile (<600px), 2 columns on medium (600-900px), 3 columns on large (>900px). Gap: 16px.
6. `.channel-list__empty` - Centered text, muted color, padding

7. `.channel-card` - Card with white background, border-radius from --radius-info-card, box-shadow, padding. Transition on border color for busy state.
8. `.channel-card--busy` - Left border accent color (--accent) to indicate busy
9. `.channel-card__header` - Flex row, space-between, channel name and status pill
10. `.channel-card__name` - Channel name, truncate with ellipsis if long
11. `.channel-card__status` - Connection status pill (reuse existing .pill classes)
12. `.channel-card__speaker` - Speaker info row, subtle background, small text. Only shown when busy.
13. `.channel-card__speaker-name` - Bold text for speaker name
14. `.channel-card__ptt` - Container for PttButton, centered, min-height to prevent layout shift. The PttButton class from Phase 1 already has its own styling (see src/client/ui/PttButton.ts). Make sure the container gives it room.
15. `.channel-card__error` - Error message in red/accent, small text

Also check if `.ptt-button` styles already exist in styles.css (they do - see the footer button). The PttButton class adds its own class names to the button element. Verify compatibility or add overrides if needed.

IMPORTANT: Do NOT use Tailwind (not in the project). Use plain CSS following the existing convention in styles.css.
  </action>
  <verify>
    Run `cd web-ui && npm run build` to verify:
    1. Build succeeds without import errors
    2. No TypeScript/JSX compilation errors
    3. Route to /event/:eventId/channels is registered in App.jsx
    4. CSS validates (no syntax errors)
  </verify>
  <done>
    App.jsx has /event/:eventId/channels route pointing to Channels page. Events.jsx has "My Channels" link for all users. styles.css has responsive grid layout for channel list, card styling with busy/speaker states, and proper styling for the PTT button container. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 3: PERMISSION_UPDATE handler for real-time channel sync</name>
  <files>
    web-ui/src/context/ChannelContext.jsx
    web-ui/src/pages/Channels.jsx
  </files>
  <action>
Update `web-ui/src/context/ChannelContext.jsx` to handle PERMISSION_UPDATE messages:

The PERMISSION_UPDATE message (per AUTHZ-006 decision) is sent by the server via WebSocket when a user's channel permissions change. It contains `{ added: [channelId, ...], removed: [channelId, ...] }`.

Add to ChannelProvider:
1. Accept optional `signalingClient` prop (will be provided after WebSocket connection is established)
2. Add useEffect that subscribes to PERMISSION_UPDATE events on the signalingClient:
   ```javascript
   useEffect(() => {
     if (!signalingClient) return;

     const handlePermissionUpdate = (data) => {
       setChannels(prev => {
         const updated = prev.filter(id => !(data.removed || []).includes(id));
         return [...updated, ...(data.added || [])];
       });
     };

     signalingClient.on('permission-update', handlePermissionUpdate);

     return () => {
       signalingClient.off('permission-update', handlePermissionUpdate);
     };
   }, [signalingClient]);
   ```

HOWEVER: There's a challenge. The ChannelProvider wraps the ChannelList, but the signalingClient is created per-channel inside useChannelConnection. For PERMISSION_UPDATE, we need a global WebSocket connection (not per-channel).

ALTERNATIVE APPROACH: Instead of per-channel ConnectionManager (which is designed for single-channel use), create a lightweight global WebSocket connection in the Channels page just for receiving PERMISSION_UPDATE messages. This connection uses the ReconnectingSignalingClient directly (not ConnectionManager) and only listens for permission updates.

Update `web-ui/src/pages/Channels.jsx`:
1. After getting the router token, create a ReconnectingSignalingClient (or a simple WebSocket) for receiving PERMISSION_UPDATE messages
2. Pass the client (or a callback) to ChannelProvider
3. When PERMISSION_UPDATE arrives with added/removed channels, update the channel list in ChannelContext
4. Clean up the connection on unmount

If importing ReconnectingSignalingClient from src/client/ is not feasible (depends on Task 02-01 findings about Vite TypeScript imports), use a simple WebSocket connection instead:
```javascript
// Simple WebSocket for permission updates
const ws = new WebSocket(wsUrl, [token]);
ws.onmessage = (event) => {
  const msg = JSON.parse(event.data);
  if (msg.type === 'permission-update') {
    // update channels
  }
};
```

The key point: when channels are added or removed by admin/dispatch, the user's UI should update without requiring a page refresh. This is the "nice to have" from the research but directly supports UI-01 (seeing assigned channels).
  </action>
  <verify>
    1. ChannelContext accepts mechanism to update channels dynamically
    2. PERMISSION_UPDATE messages cause channel list to update (new channels appear, removed channels disappear)
    3. WebSocket connection for permission updates has proper cleanup on unmount
    4. Build still succeeds: `cd web-ui && npm run build`
  </verify>
  <done>
    PERMISSION_UPDATE messages dynamically update the channel list in ChannelContext. New channels appear and removed channels disappear without page refresh. Global WebSocket connection for permission updates is properly cleaned up on unmount.
  </done>
</task>

</tasks>

<verification>
1. Navigate to /event/{eventId}/channels -- see channel list
2. Each channel card shows PTT button, connection status, and channel name
3. Empty state displayed when no channels assigned
4. Unauthenticated access redirects to /login
5. Events page has "My Channels" link
6. CSS is responsive (1/2/3 columns at different widths)
7. Build succeeds: `cd web-ui && npm run build`
</verification>

<success_criteria>
- /event/:eventId/channels route exists and renders Channels page
- ChannelList renders ChannelCard per assigned channel
- Empty state shown when no channels
- Events page links to My Channels
- PERMISSION_UPDATE dynamically adds/removes channels
- CSS follows existing design language, responsive grid
- Build succeeds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-browser-ui-for-general-users/03-03-SUMMARY.md`
</output>
