---
phase: 05-android-setup-webrtc
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - android/app/src/main/java/com/voiceping/android/data/network/SignalingClient.kt
  - android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
  - android/app/src/main/java/com/voiceping/android/data/network/dto/SignalingMessage.kt
  - android/app/src/main/java/com/voiceping/android/data/audio/AudioRouter.kt
  - android/app/src/main/java/com/voiceping/android/di/NetworkModule.kt
autonomous: true

must_haves:
  truths:
    - "SignalingClient connects to WebSocket at /ws with JWT in Sec-WebSocket-Protocol header"
    - "SignalingClient supports request-response correlation via UUID message IDs"
    - "SignalingClient exposes connection state as StateFlow and broadcasts as SharedFlow"
    - "MediasoupClient can create Device, load router capabilities, and create receive transport"
    - "AudioRouter configures earpiece mode by default (MODE_IN_COMMUNICATION, speakerphone off)"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/data/network/SignalingClient.kt"
      provides: "WebSocket signaling client matching server protocol"
      contains: "Sec-WebSocket-Protocol"
    - path: "android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt"
      provides: "mediasoup Device + receive transport wrapper"
      contains: "createRecvTransport"
    - path: "android/app/src/main/java/com/voiceping/android/data/network/dto/SignalingMessage.kt"
      provides: "Message DTOs matching src/shared/protocol.ts"
      contains: "SignalingType"
    - path: "android/app/src/main/java/com/voiceping/android/data/audio/AudioRouter.kt"
      provides: "Audio routing to earpiece by default"
      contains: "MODE_IN_COMMUNICATION"
  key_links:
    - from: "SignalingClient.kt"
      to: "server /ws endpoint"
      via: "OkHttp WebSocket with JWT subprotocol"
      pattern: "voiceping.*token"
    - from: "MediasoupClient.kt"
      to: "SignalingClient.kt"
      via: "request() for GET_ROUTER_CAPABILITIES, CREATE_TRANSPORT, etc."
      pattern: "signalingClient.request"
    - from: "SignalingMessage.kt"
      to: "src/shared/protocol.ts"
      via: "Matching SignalingType enum values"
      pattern: "join-channel|leave-channel|get-router-capabilities"
---

<objective>
Build the networking layer: WebSocket signaling client (OkHttp), mediasoup client wrapper (Device + receive transport + consumer), audio router (earpiece default), and signaling message DTOs matching the server's protocol.ts. These are headless data-layer components with no UI — they expose StateFlows that UI layers consume.

Purpose: Establish the real-time communication infrastructure that enables WebSocket signaling and mediasoup audio receive.
Output: Networking clients ready for channel join and audio playback integration in Plan 05.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-android-setup-webrtc/05-RESEARCH.md
@.planning/phases/05-android-setup-webrtc/05-01-SUMMARY.md
@src/shared/protocol.ts

Reference research Pattern 3 (OkHttp WebSocket), Pattern 4 (mediasoup Receive Transport), Pattern 5 (Audio Routing), and Pitfall 2 (JWT in WebSocket subprotocol).

CRITICAL: Read src/shared/protocol.ts to match the Android SignalingType enum values EXACTLY with the server's SignalingType enum. The server uses kebab-case string values (e.g., "join-channel", "get-router-capabilities").
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SignalingClient and message DTOs</name>
  <files>
    android/app/src/main/java/com/voiceping/android/data/network/SignalingClient.kt
    android/app/src/main/java/com/voiceping/android/data/network/dto/SignalingMessage.kt
  </files>
  <action>
    **SignalingMessage.kt:** DTOs matching src/shared/protocol.ts.

    SignalingType enum with @SerializedName annotations for Gson serialization. The server uses kebab-case:
    ```
    @SerializedName("join-channel") JOIN_CHANNEL,
    @SerializedName("leave-channel") LEAVE_CHANNEL,
    @SerializedName("get-router-capabilities") GET_ROUTER_CAPABILITIES,
    @SerializedName("create-transport") CREATE_TRANSPORT,
    @SerializedName("connect-transport") CONNECT_TRANSPORT,
    @SerializedName("produce") PRODUCE,
    @SerializedName("consume") CONSUME,
    @SerializedName("ptt-start") PTT_START,
    @SerializedName("ptt-stop") PTT_STOP,
    @SerializedName("ptt-denied") PTT_DENIED,
    @SerializedName("speaker-changed") SPEAKER_CHANGED,
    @SerializedName("channel-state") CHANNEL_STATE,
    @SerializedName("error") ERROR,
    @SerializedName("ping") PING,
    @SerializedName("pong") PONG,
    @SerializedName("permission-update") PERMISSION_UPDATE,
    @SerializedName("channel-list") CHANNEL_LIST,
    @SerializedName("force-disconnect") FORCE_DISCONNECT,
    @SerializedName("priority-ptt-start") PRIORITY_PTT_START,
    @SerializedName("priority-ptt-stop") PRIORITY_PTT_STOP,
    @SerializedName("emergency-broadcast-start") EMERGENCY_BROADCAST_START,
    @SerializedName("emergency-broadcast-stop") EMERGENCY_BROADCAST_STOP,
    @SerializedName("ptt-interrupted") PTT_INTERRUPTED,
    @SerializedName("role-info") ROLE_INFO,
    @SerializedName("ban-user") BAN_USER,
    @SerializedName("unban-user") UNBAN_USER
    ```

    SignalingMessage data class:
    - type: SignalingType
    - id: String? = null
    - data: Map<String, Any>? = null  (use JsonElement or Any for flexible JSON)
    - error: String? = null

    **SignalingClient.kt:** OkHttp WebSocket client per research Pattern 3.

    @Singleton class with @Inject constructor. Inject TokenManager and Gson.

    Properties:
    - private var webSocket: WebSocket? = null
    - private val pendingRequests = ConcurrentHashMap<String, CompletableDeferred<SignalingMessage>>()
    - _connectionState: MutableStateFlow<ConnectionState>(DISCONNECTED) — exposed as StateFlow
    - _messages: MutableSharedFlow<SignalingMessage>() — exposed as SharedFlow (for broadcasts)
    - private val client = OkHttpClient.Builder().readTimeout(0, TimeUnit.MILLISECONDS).build()
    - private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO) — for emitting messages

    Methods:
    - connect(serverUrl: String): Build Request with `.header("Sec-WebSocket-Protocol", "voiceping, $token")` per Pitfall 2. Create WebSocket with listener. On onOpen: set CONNECTED. On onMessage: parse JSON, check for correlation ID in pendingRequests (complete deferred), otherwise emit to _messages SharedFlow. On onFailure: set FAILED, complete all pending requests exceptionally. On onClosing: set DISCONNECTED.
    - request(type: SignalingType, data: Map<String, Any> = emptyMap()): Create message with UUID.randomUUID().toString() as id. Create CompletableDeferred, store in pendingRequests. Send JSON via webSocket.send(). Return deferred.await() with 10-second timeout (withTimeout).
    - send(type: SignalingType, data: Map<String, Any> = emptyMap()): Fire-and-forget send (no correlation ID, no response expected). Used for PING.
    - disconnect(): Close WebSocket with code 1000, clear pending requests, set DISCONNECTED.
    - startHeartbeat(): Launch coroutine that sends PING every 25 seconds while connected. Cancel on disconnect.

    Important: Use `withContext(Dispatchers.IO)` for connect. Use `withTimeout(10_000)` in request() to prevent hanging on unresponsive server. On timeout, remove from pendingRequests and throw TimeoutException.
  </action>
  <verify>
    SignalingType enum has all values from protocol.ts with correct @SerializedName kebab-case annotations. SignalingClient exposes connectionState as StateFlow and messages as SharedFlow. JWT is passed via Sec-WebSocket-Protocol header. Request-response uses UUID correlation. Heartbeat sends PING every 25 seconds.
  </verify>
  <done>
    SignalingClient provides WebSocket communication matching server protocol exactly. Request-response correlation, broadcast handling, heartbeat, and connection state management are all implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MediasoupClient, AudioRouter, and NetworkModule</name>
  <files>
    android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
    android/app/src/main/java/com/voiceping/android/data/audio/AudioRouter.kt
    android/app/src/main/java/com/voiceping/android/di/NetworkModule.kt
  </files>
  <action>
    **MediasoupClient.kt:** mediasoup Device wrapper per research Pattern 4.

    @Singleton class with @Inject constructor. Inject SignalingClient and @ApplicationContext context.

    Properties:
    - private var device: Device? = null (from io.github.aspect-build.mediasoup — check exact import from libmediasoup-android 0.7.0 library)
    - private var recvTransport: RecvTransport? = null
    - private val consumers = mutableMapOf<String, Consumer>()
    - private val _isInitialized = MutableStateFlow(false)
    - val isInitialized: StateFlow<Boolean>

    IMPORTANT NOTE about libmediasoup-android API: The exact API surface of version 0.7.0 may differ from the research examples. The research provides the conceptual pattern but the actual class names, method signatures, and parameter types need to be verified against the library's actual API. If the import paths or method signatures differ:
    - Check the library's GitHub README and source code for correct usage
    - The core flow is always: create Device -> load capabilities -> create RecvTransport -> consume
    - Adapt method calls to match the actual 0.7.0 API

    Methods:
    - initialize(): Request GET_ROUTER_CAPABILITIES from server via signalingClient.request(). Extract routerRtpCapabilities from response. Create Device instance, call device.load(routerRtpCapabilities). Set _isInitialized to true. Wrap in try/catch — if loading fails, log error and leave uninitialized.
    - createRecvTransport(channelId: String): Request CREATE_TRANSPORT with channelId and direction="recv". Extract transport parameters (id, iceParameters, iceCandidates, dtlsParameters) from response. Call device.createRecvTransport() with listener that handles onConnect (sends CONNECT_TRANSPORT to server) and onConnectionStateChange (logs state). Store recvTransport.
    - consumeAudio(producerId: String, peerId: String): Request CONSUME from server with producerId + rtpCapabilities from device. Extract consumer parameters (id, kind, rtpParameters) from response. Call recvTransport.consume() with listener. Store consumer. Call consumer.resume() to start audio playback. The WebRTC AudioTrack automatically plays through the device audio output.
    - closeConsumer(consumerId: String): Get consumer from map, call consumer.close(), remove from map.
    - cleanup(): Close all consumers in order, close recvTransport, null out device. Per Pitfall 4: close consumers FIRST, then transport, then device.

    **AudioRouter.kt:** Audio output routing per research Pattern 5.

    @Singleton class with @Inject constructor. Inject @ApplicationContext context.

    Properties:
    - private val audioManager = context.getSystemService(AudioManager::class.java)
    - private var audioFocusRequest: AudioFocusRequest? = null

    Methods:
    - setEarpieceMode(): Set MODE_IN_COMMUNICATION, isSpeakerphoneOn = false. Default mode for Phase 5.
    - setSpeakerMode(): Set MODE_IN_COMMUNICATION, isSpeakerphoneOn = true. (Exposed for future Phase 6 toggle.)
    - requestAudioFocus(): Build AudioFocusRequest with AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK, USAGE_VOICE_COMMUNICATION, CONTENT_TYPE_SPEECH. Call audioManager.requestAudioFocus(). Store request for later abandonment.
    - releaseAudioFocus(): Call audioManager.abandonAudioFocusRequest() if request exists.
    - resetAudioMode(): Set audioManager.mode = AudioManager.MODE_NORMAL. Call on disconnect/cleanup.

    **NetworkModule.kt:** Hilt @Module @InstallIn(SingletonComponent::class)
    - Provide SignalingClient as @Singleton
    - Provide MediasoupClient as @Singleton
    - Provide AudioRouter as @Singleton

    NOTE: SignalingClient, MediasoupClient, AudioRouter all use @Inject constructor, so Hilt can construct them automatically. NetworkModule may only need to provide external objects (like the WebSocket URL). If @Inject constructor is sufficient, NetworkModule can be minimal or only provide configuration values. The key point is: ensure all three are @Singleton scoped.
  </action>
  <verify>
    MediasoupClient has initialize(), createRecvTransport(), consumeAudio(), closeConsumer(), cleanup() methods. AudioRouter defaults to earpiece mode (MODE_IN_COMMUNICATION + speakerphone off). Cleanup follows correct disposal order: consumers -> transport -> device (per Pitfall 4). All networking classes are @Singleton scoped.
  </verify>
  <done>
    mediasoup Device wrapper can load capabilities, create receive transport, and consume audio. AudioRouter defaults to earpiece. Networking layer is ready for channel join integration in Plan 05.
  </done>
</task>

</tasks>

<verification>
1. SignalingType enum matches ALL values from src/shared/protocol.ts with @SerializedName kebab-case
2. SignalingClient passes JWT via `Sec-WebSocket-Protocol: voiceping, <token>` header
3. Request-response correlation uses UUID message IDs with 10-second timeout
4. Heartbeat sends PING every 25 seconds while connected
5. MediasoupClient flow: Device.load() -> createRecvTransport() -> consume() -> audio plays
6. Consumer disposal order: consumers first, then transport (per Pitfall 4)
7. AudioRouter sets earpiece by default (MODE_IN_COMMUNICATION, speakerphoneOn=false)
8. All networking classes expose state via StateFlow for UI reactivity
</verification>

<success_criteria>
- SignalingClient compiles and matches server protocol exactly
- MediasoupClient implements receive-only transport pattern
- AudioRouter configures earpiece as default audio output
- All classes are Hilt-injectable singletons
</success_criteria>

<output>
After completion, create `.planning/phases/05-android-setup-webrtc/05-03-SUMMARY.md`
</output>
