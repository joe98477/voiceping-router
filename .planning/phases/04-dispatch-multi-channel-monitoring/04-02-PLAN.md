---
phase: 04-dispatch-multi-channel-monitoring
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - web-ui/src/pages/DispatchConsole.jsx
  - web-ui/src/components/ChannelGrid.jsx
  - web-ui/src/components/AdminDrawer.jsx
  - web-ui/src/App.jsx
  - web-ui/src/pages/Events.jsx
  - web-ui/src/styles.css
  - control-plane/src/index.js
autonomous: true

must_haves:
  truths:
    - "Dispatch user sees all channels grouped by team in collapsible sections at /event/:eventId/dispatch"
    - "Dispatch user can expand/collapse team sections (all start expanded)"
    - "Dispatch user can mute/unmute individual channels and per-team mute toggles work"
    - "Dispatch user can transmit PTT on any monitored channel"
    - "Dispatch user sees stats bar with total channels, muted count, active speakers, event name, user info, uptime, connection health"
    - "Dispatch user can access admin controls via collapsible side drawer (slides from right)"
    - "Events page shows 'Dispatch Console' link instead of 'Dispatch View'"
    - "Logo/brand in header links back to Events page"
    - "Dispatch user's mute settings are restored when returning to the console"
    - "General users see channel names instead of channel IDs on the Channels page"
  artifacts:
    - path: "web-ui/src/pages/DispatchConsole.jsx"
      provides: "Full dispatch monitoring page"
      min_lines: 150
    - path: "web-ui/src/components/ChannelGrid.jsx"
      provides: "Team-grouped channel grid with collapsible sections"
      min_lines: 60
    - path: "web-ui/src/components/AdminDrawer.jsx"
      provides: "Right-sliding admin drawer for control-plane features"
      min_lines: 30
    - path: "web-ui/src/App.jsx"
      provides: "Updated route for dispatch page"
      contains: "DispatchConsole"
  key_links:
    - from: "web-ui/src/pages/DispatchConsole.jsx"
      to: "web-ui/src/components/ChannelGrid.jsx"
      via: "import and render"
      pattern: "ChannelGrid"
    - from: "web-ui/src/pages/DispatchConsole.jsx"
      to: "web-ui/src/components/DispatchChannelCard.jsx"
      via: "via ChannelGrid"
      pattern: "DispatchChannelCard"
    - from: "web-ui/src/pages/DispatchConsole.jsx"
      to: "/api/events/:eventId/overview"
      via: "apiGet fetch on mount"
      pattern: "api/events.*overview"
    - from: "web-ui/src/App.jsx"
      to: "web-ui/src/pages/DispatchConsole.jsx"
      via: "Route import"
      pattern: "DispatchConsole"
---

<objective>
Build the complete Dispatch Console page with team-grouped channel grid, stats bar, admin side drawer, navigation updates, mute persistence, and channel name resolution for general users.

Purpose: Replace the existing dispatch page with a full monitoring console that enables DISPATCH/ADMIN users to monitor 10-50 channels simultaneously, and give general users channel names.
Output: DispatchConsole page, ChannelGrid component, AdminDrawer component, route wiring, navigation updates, CSS, localStorage mute persistence, and channel name API for general users.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-dispatch-multi-channel-monitoring/04-CONTEXT.md
@.planning/phases/04-dispatch-multi-channel-monitoring/04-RESEARCH.md
@.planning/phases/04-dispatch-multi-channel-monitoring/04-01-SUMMARY.md
@web-ui/src/App.jsx
@web-ui/src/pages/Events.jsx
@web-ui/src/pages/Console.jsx
@web-ui/src/pages/Channels.jsx
@web-ui/src/components/ChannelCard.jsx
@web-ui/src/components/SettingsDrawer.jsx
@web-ui/src/context/ChannelContext.jsx
@web-ui/src/hooks/useAuth.js
@web-ui/src/hooks/useChannelConnection.js
@web-ui/src/hooks/usePermissionUpdates.js
@web-ui/src/styles.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: ChannelGrid component with team grouping and collapsible sections</name>
  <files>web-ui/src/components/ChannelGrid.jsx, web-ui/src/components/AdminDrawer.jsx, web-ui/src/styles.css</files>
  <action>
**ChannelGrid component (`web-ui/src/components/ChannelGrid.jsx`):**

Creates a team-grouped layout with collapsible sections and per-team mute toggles.

**Props:**
- `teams` — Array of { id, name } team objects (from overview API)
- `channels` — Array of { id, name, teamId } channel objects (from overview API)
- `wsUrl` — WebSocket URL
- `token` — JWT token
- `mutedChannels` — Set of muted channel IDs
- `onToggleMute` — (channelId) => void
- `onMuteTeam` — (teamId, channelIds) => void — mutes all channels in team
- `onUnmuteTeam` — (teamId, channelIds) => void — unmutes all channels in team
- `channelStates` — channelStates object from ChannelContext (passed down for stats)

**Behavior:**
1. Group channels by teamId. Channels without a teamId go into an "Event" group.
2. Sort teams alphabetically by name. Within each team, sort channels alphabetically by name (per LOCKED decision: active channels stay in alphabetical order).
3. Each team section has:
   - Collapsible header with team name and chevron icon (click to expand/collapse)
   - Per-team mute toggle button in the header: shows "unmuted" unless ALL channels in team are muted
   - When team mute is clicked: if any channel unmuted -> mute ALL in team. If all muted -> unmute ALL in team.
4. All team sections start expanded by default (per LOCKED decision).
5. Track expanded/collapsed state in local React state (no persistence needed for collapse state).
6. Inside each team section, render channels in a CSS grid using DispatchChannelCard components.
7. Grid uses `grid-template-columns: repeat(auto-fill, minmax(220px, 1fr))` (per LOCKED decision: ~220px minimum card width).

**AdminDrawer component (`web-ui/src/components/AdminDrawer.jsx`):**

A right-sliding side drawer for admin control-plane features. This replaces the existing SettingsDrawer modal pattern with a slide-from-right drawer.

**Props:**
- `isOpen` — boolean
- `onClose` — function
- `user` — user object
- `eventId` — string
- `overview` — overview data
- `onReload` — reload overview callback

**Behavior:**
1. When `isOpen` is false, render nothing (return null).
2. When `isOpen` is true, render a semi-transparent overlay + right-sliding drawer panel.
3. The drawer slides in from the right side of the screen (CSS transform: translateX).
4. Drawer contains the existing SettingsDrawer tabs content (import and render SettingsDrawer internally, passing all props, or render the same tab structure). The simplest approach: render the existing SettingsDrawer component but styled as a right-side panel instead of a centered modal.
   - Actually, the simplest clean approach: Create AdminDrawer as a thin wrapper. It renders a right-side drawer container with the existing settings tabs. Import the tab components from `./SettingsTabs/` directly (ViewSettings, EventSettings, TeamsSettings, ChannelsSettings, UsersSettings, InvitesSettings, SystemSettings) and render them in a tab UI inside the right drawer.
   - OR, even simpler: Just re-use `SettingsDrawer` component but override its styling for right-slide position via a wrapper class. The SettingsDrawer already has tabs and all admin functionality.
   - **Recommended approach:** Create AdminDrawer as a new component that uses a `.admin-drawer` CSS class for right-side positioning. Internally, import and render the SettingsDrawer's tab structure. The key difference from SettingsDrawer is the CSS positioning (right-side slide vs center modal).

Here is the recommended implementation:
```jsx
import React from 'react';
import SettingsDrawer from './SettingsDrawer.jsx';

const AdminDrawer = ({ isOpen, onClose, user, eventId, overview, onReload }) => {
  if (!isOpen) return null;

  return (
    <div className="admin-drawer-overlay" onClick={onClose}>
      <div className="admin-drawer" onClick={(e) => e.stopPropagation()}>
        <SettingsDrawer
          isOpen={true}
          onClose={onClose}
          user={user}
          eventId={eventId}
          overview={overview}
          onReload={onReload}
          viewSettings={{ showRoster: true, showTeams: true, showChannels: true, density: 'comfortable', sound: true }}
          onViewSettingsChange={() => {}}
        />
      </div>
    </div>
  );
};

export default AdminDrawer;
```

Wait — SettingsDrawer renders its own overlay. Since we want to wrap it in a right-side drawer, it's cleaner to NOT use the overlay from SettingsDrawer. Instead, AdminDrawer should directly render the drawer-overlay + drawer content with right-side positioning, and embed the SettingsDrawer content inside (but SettingsDrawer already renders its own overlay).

**Simplest approach:** AdminDrawer is a right-positioned overlay that, when opened, renders the SettingsDrawer as a child. Override the SettingsDrawer's `.drawer-overlay` and `.drawer` CSS via a parent `.admin-drawer-wrapper` class that positions the drawer on the right instead of center.

Actually, the cleanest approach: Don't nest SettingsDrawer. Instead, just re-export the tabs content directly. But that's more work.

**Final decision:** Use the simplest approach: AdminDrawer renders a right-positioned container. Inside, it re-imports the individual tab components (same as SettingsDrawer) and renders them in a tabbed UI. This avoids CSS override conflicts.

```jsx
import React, { useMemo, useState } from 'react';
import ViewSettings from './SettingsTabs/ViewSettings.jsx';
import EventSettings from './SettingsTabs/EventSettings.jsx';
import TeamsSettings from './SettingsTabs/TeamsSettings.jsx';
import ChannelsSettings from './SettingsTabs/ChannelsSettings.jsx';
import UsersSettings from './SettingsTabs/UsersSettings.jsx';
import InvitesSettings from './SettingsTabs/InvitesSettings.jsx';
import SystemSettings from './SettingsTabs/SystemSettings.jsx';

const AdminDrawer = ({ isOpen, onClose, user, eventId, overview, onReload }) => {
  const isAdmin = user && user.globalRole === 'ADMIN';
  const tabs = useMemo(() => {
    const items = [];
    if (isAdmin) {
      items.push(
        { id: 'event', label: 'Event', component: EventSettings },
        { id: 'teams', label: 'Teams', component: TeamsSettings },
        { id: 'channels', label: 'Channels', component: ChannelsSettings },
        { id: 'users', label: 'Users', component: UsersSettings },
        { id: 'invites', label: 'Invites', component: InvitesSettings },
        { id: 'system', label: 'System', component: SystemSettings }
      );
    }
    return items;
  }, [isAdmin]);
  const [activeTab, setActiveTab] = useState(tabs[0]?.id || '');

  if (!isOpen || tabs.length === 0) return null;

  const ActiveComponent = tabs.find(t => t.id === activeTab)?.component || tabs[0].component;

  return (
    <div className="admin-drawer-overlay" onClick={onClose}>
      <div className="admin-drawer" onClick={(e) => e.stopPropagation()}>
        <header className="admin-drawer__header">
          <div>
            <div className="badge">Admin</div>
            <h3>Control Plane</h3>
          </div>
          <button className="btn btn--secondary" onClick={onClose}>Close</button>
        </header>
        <div className="admin-drawer__tabs">
          {tabs.map(tab => (
            <button
              key={tab.id}
              className={`drawer__tab ${tab.id === activeTab ? 'drawer__tab--active' : ''}`}
              onClick={() => setActiveTab(tab.id)}
            >
              {tab.label}
            </button>
          ))}
        </div>
        <div className="admin-drawer__content">
          <ActiveComponent
            eventId={eventId}
            overview={overview}
            onReload={onReload}
          />
        </div>
      </div>
    </div>
  );
};

export default AdminDrawer;
```

**CSS additions to web-ui/src/styles.css** (add at end of file):

```css
/* Dispatch Console - Channel Grid */
.channel-grid {
  display: grid;
  gap: 16px;
}

.channel-grid__team-section {
  display: grid;
  gap: 8px;
}

.channel-grid__team-header {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 12px;
  background: var(--surface);
  border-radius: 10px;
  cursor: pointer;
  user-select: none;
  border: 1px solid var(--border);
}

.channel-grid__team-name {
  font-weight: 700;
  font-size: 0.85rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--muted);
  flex: 1;
}

.channel-grid__team-chevron {
  font-size: 0.75rem;
  color: var(--muted);
  transition: transform 0.2s ease;
}

.channel-grid__team-chevron--collapsed {
  transform: rotate(-90deg);
}

.channel-grid__team-mute-btn {
  padding: 4px 10px;
  border-radius: 6px;
  border: 1px solid var(--border);
  background: white;
  cursor: pointer;
  font-size: 0.7rem;
  font-weight: 600;
}

.channel-grid__team-mute-btn--all-muted {
  background: #f7c2b6;
  border-color: #f2b6ae;
  color: #7f2c20;
}

.channel-grid__cards {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  gap: 10px;
}

.channel-grid__cards--collapsed {
  display: none;
}

/* Admin Drawer (right-slide) */
.admin-drawer-overlay {
  position: fixed;
  inset: 0;
  background: rgba(17, 20, 24, 0.4);
  z-index: 30;
  display: flex;
  justify-content: flex-end;
}

.admin-drawer {
  width: min(480px, 90vw);
  height: 100vh;
  background: var(--surface);
  box-shadow: -8px 0 30px var(--shadow);
  display: grid;
  grid-template-rows: auto auto 1fr;
  overflow: hidden;
  animation: admin-drawer-slide-in 0.25s ease-out;
}

@keyframes admin-drawer-slide-in {
  from { transform: translateX(100%); }
  to { transform: translateX(0); }
}

.admin-drawer__header {
  padding: 20px 24px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--border);
}

.admin-drawer__tabs {
  display: flex;
  gap: 6px;
  padding: 12px 24px;
  overflow-x: auto;
  border-bottom: 1px solid var(--border);
}

.admin-drawer__content {
  padding: 16px 24px;
  overflow: auto;
}

/* Dispatch Console - Stats Bar */
.dispatch-stats {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 10px 16px;
  background: var(--surface);
  border-radius: 12px;
  box-shadow: 0 4px 12px var(--shadow);
  flex-wrap: wrap;
}

.dispatch-stats__item {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 0.8rem;
  white-space: nowrap;
}

.dispatch-stats__item strong {
  font-weight: 700;
}

.dispatch-stats__divider {
  width: 1px;
  height: 20px;
  background: var(--border);
  flex-shrink: 0;
}

/* Dispatch Console - Page Layout */
.dispatch-console {
  min-height: 100vh;
  padding: 16px 20px 40px;
  display: grid;
  grid-template-rows: auto auto 1fr;
  gap: 14px;
}

.dispatch-console__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  padding: 12px 16px;
  background: var(--surface);
  border-radius: 14px;
  box-shadow: 0 8px 24px var(--shadow);
}

.dispatch-console__brand {
  display: grid;
  gap: 2px;
}

.dispatch-console__brand a {
  font-size: 0.7rem;
  letter-spacing: 0.28em;
  text-transform: uppercase;
  color: var(--muted);
  text-decoration: none;
}

.dispatch-console__brand a:hover {
  color: var(--accent-2);
}

.dispatch-console__brand h1 {
  margin: 0;
  font-size: 1rem;
  letter-spacing: 0.1em;
  text-transform: uppercase;
}

.dispatch-console__event-name {
  font-size: 0.8rem;
  color: var(--muted);
}

.dispatch-console__actions {
  display: flex;
  gap: 10px;
  align-items: center;
}
```
  </action>
  <verify>Run `npx vite build` from web-ui/ to confirm components compile. Grep for "ChannelGrid" in ChannelGrid.jsx, "AdminDrawer" in AdminDrawer.jsx, "channel-grid" in styles.css.</verify>
  <done>ChannelGrid renders channels grouped by team in collapsible sections with per-team mute toggles and alphabetical sorting. AdminDrawer slides from right with admin tabs. CSS for grid, drawer, stats bar, and page layout added.</done>
</task>

<task type="auto">
  <name>Task 2: DispatchConsole page, route wiring, navigation updates, mute persistence, and channel name API</name>
  <files>web-ui/src/pages/DispatchConsole.jsx, web-ui/src/App.jsx, web-ui/src/pages/Events.jsx, web-ui/src/pages/Channels.jsx, web-ui/src/context/ChannelContext.jsx, control-plane/src/index.js</files>
  <action>
**DispatchConsole page (`web-ui/src/pages/DispatchConsole.jsx`):**

This is the main dispatch monitoring page. It REPLACES the old Console.jsx at the same route `/event/:eventId/dispatch`.

**Data flow:**
1. On mount, fetch `/api/events/${eventId}/overview` (same as old Dispatch.jsx) to get teams, channels, roster, event info.
2. Fetch router token via `apiPost('/api/router/token', { eventId })` for WebSocket connections.
3. Construct wsUrl (same pattern as Channels.jsx: check VITE_ROUTER_WS env var, fallback to window.location).
4. Store token in useAuth hook for session persistence.
5. Pass teams and channels to ChannelGrid component.
6. Wrap channel grid in ChannelProvider (like Channels.jsx does).
7. Use usePermissionUpdates hook for real-time permission updates.

**Mute state management:**
- Initialize mutedChannels from localStorage key `cv.dispatch.muted.${eventId}` (returns JSON array of channel IDs, or empty array).
- When mute state changes, save to localStorage immediately.
- Provide `toggleMute(channelId)`, `muteTeam(teamId, channelIds)`, `unmuteTeam(teamId, channelIds)` functions.
- Pass `mutedChannels` (as a Set for fast lookup) and toggle/mute/unmute functions to ChannelGrid.

**Stats bar (at top, below header):**
Render a stats bar using the `.dispatch-stats` CSS class with these items:
- Event name (from overview.event.name)
- Dispatch user info: "User: {user.displayName || user.email}"
- Total channels: number of channels
- Muted: count of muted channels
- Active speakers: count of channels where channelStates[id].isBusy === true (read from ChannelContext)
- Uptime: time since page loaded (update every second with setInterval, format as "Xh Ym")
- Connection health: "Online" / "Offline" based on navigator.onLine (use online/offline event listeners)

**Header:**
- Left: Brand section. "ConnectVoice" text links to `/events` page (per LOCKED decision: logo/brand links back to Events page). Below: "Dispatch Console" as h1. Below: event name.
- Right: Actions. Admin gear icon button (opens AdminDrawer). Logout button.

**AdminDrawer integration:**
- State variable `drawerOpen` controls AdminDrawer visibility.
- Only show admin gear button if user.globalRole === 'ADMIN' (both DISPATCH and ADMIN can VIEW the monitoring page, but only ADMIN gets the settings drawer — per existing SettingsDrawer pattern which checks isAdmin).
- Actually, the existing Console.jsx shows SettingsDrawer for both — let Admin users access it. Dispatch users who aren't global ADMIN won't see admin tabs (handled inside AdminDrawer already).
- Show the gear button for all users who reach this page. AdminDrawer internally shows tabs only for ADMIN role.

**Page structure:**
```
[Header: brand (link to /events) | event name | actions (gear, logout)]
[Stats bar: event | user | channels | muted | active | uptime | health]
[ChannelGrid: team sections with DispatchChannelCards]
[AdminDrawer: slides from right when gear clicked]
```

**Route wiring (`web-ui/src/App.jsx`):**
1. Import DispatchConsole: `import DispatchConsole from './pages/DispatchConsole.jsx';`
2. Replace the existing `/event/:eventId/dispatch` route. Currently it renders `<Console user={user} onLogout={handleLogout} />`.
3. Change it to render `<DispatchConsole user={user} onLogout={handleLogout} />`.
4. Keep Console.jsx in the codebase (don't delete it) but it's no longer routed to. It serves as reference/backup.

**Navigation updates (`web-ui/src/pages/Events.jsx`):**
1. Find the "Dispatch View" link text (currently: `<Link ... to={'/event/${event.id}/dispatch'}>Dispatch View</Link>`).
2. Change text from "Dispatch View" to "Dispatch Console" (per LOCKED decision).

**Channel name resolution for general users (`web-ui/src/pages/Channels.jsx`):**
Per LOCKED decision: ALL users should see channel names, not channel IDs.

Currently, general users see channel IDs because the JWT only contains channelIds (no names), and ChannelContext sets `name: channelId`.

**Implementation approach (Claude's Discretion — lightweight API for general users):**
After fetching the router token in Channels.jsx, also fetch channel names. The simplest approach that works with existing APIs:
1. After getting the router token, make a GET request to `/api/events/${eventId}/channels` (this endpoint likely exists in the control-plane for returning channel list).
2. If that endpoint doesn't exist or isn't accessible to general users, create a simple mapping: fetch `/api/events/${eventId}/overview` — but this is DISPATCH/ADMIN only.

Actually, look at the existing code. The control-plane has routes for events/channels. Let me check what's available. The Channels page currently gets channelIds from the router JWT token.

**Simplest approach:** Add a lightweight API call in Channels.jsx. After getting the token and decoding channelIds, fetch channel details. The control-plane likely has a `/api/channels` or similar endpoint. If not available for general users, we can use the existing `/api/events/${eventId}/overview` endpoint if the user has DISPATCH/ADMIN access, otherwise fall back to channel IDs.

**Even simpler approach:** Modify the Channels.jsx component to attempt fetching `/api/events/${eventId}/overview` (which returns channel names). If it succeeds (DISPATCH/ADMIN users), use the channel names. If it fails with 403 (general users), fall back to channelIds. BUT the LOCKED decision says ALL users should see names.

**Recommended approach:** Add a new lightweight endpoint or use an existing one. Check if there's a general-user-accessible endpoint that returns channel names for channels the user is assigned to. The router token endpoint (`/api/router/token`) returns a JWT with channelIds. We could enhance the token response to include channel names, or add a new endpoint.

**IMPORTANT: Do NOT modify the control-plane server code.** The control-plane (Express/Prisma) is in `src/lib/` (legacy) and has its own route structure. Instead, the simplest approach is:

1. In Channels.jsx, after fetching the router token, also try to fetch `/api/events/${eventId}/overview`.
2. If it succeeds, build a name map from the channels array.
3. If it fails (403 for general users), fall back to using channelIds as names.
4. Pass the channel name map to ChannelProvider.

Wait, checking the overview API access: the Dispatch.jsx and Console.jsx pages both call it, and they're accessible by DISPATCH/ADMIN users. General users likely get 403. So this approach won't work for general users.

**Alternative approach (works for ALL users):** Modify the router token response to include channel names. But this requires control-plane changes.

**Simplest working approach for ALL users:** Create a new lightweight API endpoint in the ROUTER server (not control-plane). The router server (`src/server/index.ts`) could add a `/api/channels/names` endpoint that queries Prisma (the router server has access to the same database). But the router server may not have Prisma set up.

**FINAL approach (minimal change, works NOW):** In the control-plane, there's likely an existing channels query. Check if `/api/events/${eventId}/channels` or `/api/channels` exists and is accessible to general users. The events routes often have RBAC.

Since modifying the control-plane backend is risky and out of scope, the safest approach:
- In `Channels.jsx`, try to fetch channel names from `/api/events/${eventId}/overview`.
- If successful, extract channel name mapping.
- If 403, keep using channelIds as names.
- This means: DISPATCH/ADMIN users on the Channels page will see names, GENERAL users will still see IDs.
- Add a comment noting this limitation.

Actually, re-reading the LOCKED decision: "General users also get channel name resolution in this phase (lightweight API or endpoint)". This means we MUST implement something for general users too.

**Solution:** The control-plane has middleware for auth. Add a simple endpoint that any authenticated user can access to get their channel names. Looking at the existing routes, the `/api/router/token` endpoint is accessible to all active users. Enhance the token response to include a `channelNames` map: `{ channelId: channelName }`.

The `/api/router/token` endpoint is defined in the control-plane. Let me check — it's at `src/lib/routes/router.js` or similar. Since we're building the plan, instruct the executor to:

1. Find the `/api/router/token` endpoint in the control-plane codebase.
2. Enhance its response to include `channelNames: { [channelId]: channelName }` alongside the existing `token` field.
3. In `Channels.jsx`, read `response.channelNames` from the token response and use it to set channel names in ChannelProvider.

Steps for channel name resolution:
1. The `/api/router/token` POST endpoint is in `control-plane/src/index.js` (around line 1282).
2. In that endpoint handler, after building the channelIds array, also query channel names using Prisma: `prisma.channel.findMany({ where: { id: { in: channelIds } }, select: { id: true, name: true } })`.
3. Build a `channelNames` map: `Object.fromEntries(channels.map(c => [c.id, c.name]))`.
4. Include `channelNames` in the response JSON alongside the existing `token` field.
5. In `web-ui/src/pages/Channels.jsx`, after getting the token response, use `response.channelNames` to create channel objects with real names: `channelIds.map(id => ({ id, name: response.channelNames?.[id] || id }))`.
6. Pass these named channels to ChannelProvider by calling `setChannels(namedChannels)` after login.
7. In `web-ui/src/context/ChannelContext.jsx`, no changes needed — the existing `setChannels` function already accepts `{ id, name }` objects.

But wait — ChannelProvider currently initializes channels from `user.channelIds` in a useEffect. If we call `setChannels` with named channels AFTER the provider initializes with unnamed ones, there will be a brief flash of ID-based names. Better approach: pass named channels directly to ChannelProvider instead of having it derive from `user.channelIds`.

**Updated approach:**
1. In Channels.jsx, after getting the token response with channelNames, create the named channel list.
2. Pass a `namedChannels` prop to ChannelProvider (or set channels via setChannels immediately after mount).
3. In ChannelContext.jsx, add support for an `initialChannels` prop that takes precedence over `user.channelIds`.

OR, simpler: After `login(response.token)` is called (which sets `user` state in useAuth, which feeds ChannelProvider's user prop), immediately call the ChannelContext's `setChannels` with the named channels. But ChannelProvider needs to be mounted first.

**Simplest clean approach:**
1. In `Channels.jsx` ChannelListWithPermissions component (which is inside ChannelProvider), use a useEffect to call `setChannels(namedChannels)` on mount.
2. Pass `namedChannels` as a prop from the Channels component to ChannelListWithPermissions.

Implementation:
- In `Channels.jsx`, store `channelNames` from the token response in state.
- Pass `channelNames` to `ChannelListWithPermissions`.
- In `ChannelListWithPermissions`, on mount, use `setChannels` to replace the channel list with named channels:
```javascript
useEffect(() => {
  if (channelNames && Object.keys(channelNames).length > 0) {
    setChannels(prev => prev.map(ch => ({
      ...ch,
      name: channelNames[ch.id] || ch.id
    })));
  }
}, [channelNames, setChannels]);
```

This way, channels first load with IDs (from ChannelProvider init), then immediately update with names (from the channelNames map). The flash is imperceptible since both happen in the same render cycle.
  </action>
  <verify>Run `npx vite build` from web-ui/ to confirm all pages and components compile. Verify App.jsx imports DispatchConsole. Verify Events.jsx contains "Dispatch Console" text. Verify Channels.jsx references channelNames.</verify>
  <done>DispatchConsole page renders at /event/:eventId/dispatch with stats bar, team-grouped channel grid, admin drawer, and mute persistence via localStorage. Events page shows "Dispatch Console" link. General users see channel names. All components build without errors.</done>
</task>

</tasks>

<verification>
1. `npx vite build` from web-ui/ passes
2. App.jsx route `/event/:eventId/dispatch` renders DispatchConsole
3. Events.jsx link text says "Dispatch Console" (not "Dispatch View")
4. DispatchConsole.jsx fetches overview API and renders ChannelGrid with team-grouped sections
5. ChannelGrid has collapsible team sections (all expanded by default)
6. ChannelGrid has per-team mute toggles
7. AdminDrawer slides from right
8. Mute state persists to localStorage with key `cv.dispatch.muted.${eventId}`
9. Stats bar shows total channels, muted count, active speakers, event name, user info, uptime, connection health
10. Brand/logo links to /events
11. Channel name resolution available via enhanced router token response
</verification>

<success_criteria>
- Dispatch user at /event/:eventId/dispatch sees all channels grouped by team
- Team sections are collapsible with expand/collapse toggle (all start expanded)
- Per-team mute toggle mutes/unmutes all channels in team
- Stats bar shows real-time counts (channels, muted, active, uptime, health)
- Admin gear button opens right-sliding drawer with control-plane tabs
- Brand link navigates back to Events page
- Mute preferences persist across page refreshes via localStorage
- Events page shows "Dispatch Console" instead of "Dispatch View"
- General users see channel names (not IDs) on the Channels page
</success_criteria>

<output>
After completion, create `.planning/phases/04-dispatch-multi-channel-monitoring/04-02-SUMMARY.md`
</output>
