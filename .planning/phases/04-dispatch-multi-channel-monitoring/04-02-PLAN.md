---
phase: 04-dispatch-multi-channel-monitoring
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - web-ui/src/pages/DispatchMonitoring.jsx
  - web-ui/src/components/ChannelGrid.jsx
  - web-ui/src/App.jsx
  - web-ui/src/pages/Events.jsx
  - web-ui/src/pages/Dispatch.jsx
  - web-ui/src/styles.css
autonomous: true

must_haves:
  truths:
    - "Dispatch user can navigate to multi-channel monitoring page"
    - "Dispatch user sees all assigned channels in a responsive grid"
    - "Dispatch user can mute/unmute individual channels"
    - "Dispatch user can transmit PTT on any monitored channel"
    - "Dispatch user sees visual activity indicators on active channels"
    - "Audio from muted channels is silenced, unmuted channels play audio"
  artifacts:
    - path: "web-ui/src/pages/DispatchMonitoring.jsx"
      provides: "Multi-channel monitoring page for DISPATCH users"
      min_lines: 80
    - path: "web-ui/src/components/ChannelGrid.jsx"
      provides: "Responsive grid layout rendering compact ChannelCards"
      min_lines: 20
    - path: "web-ui/src/App.jsx"
      provides: "Route for /event/:eventId/monitoring"
      contains: "monitoring"
    - path: "web-ui/src/styles.css"
      provides: "Grid layout CSS for dispatch monitoring"
      contains: "dispatch-monitoring"
  key_links:
    - from: "web-ui/src/pages/DispatchMonitoring.jsx"
      to: "web-ui/src/components/ChannelGrid.jsx"
      via: "import and render ChannelGrid"
      pattern: "ChannelGrid"
    - from: "web-ui/src/components/ChannelGrid.jsx"
      to: "web-ui/src/components/ChannelCard.jsx"
      via: "renders compact ChannelCard per channel"
      pattern: 'variant.*compact'
    - from: "web-ui/src/pages/DispatchMonitoring.jsx"
      to: "web-ui/src/hooks/usePermissionUpdates.js"
      via: "real-time permission sync for channel list"
      pattern: "usePermissionUpdates"
    - from: "web-ui/src/App.jsx"
      to: "web-ui/src/pages/DispatchMonitoring.jsx"
      via: "Route path /event/:eventId/monitoring"
      pattern: "monitoring"
---

<objective>
DispatchMonitoring page with responsive channel grid, per-channel mute/unmute, and audio management for multi-channel monitoring.

Purpose: Deliver the core dispatch multi-channel monitoring UI that enables DISPATCH users to see all assigned channels in a compact grid, selectively mute/unmute channels, transmit PTT on any channel, and see real-time activity indicators.

Output: DispatchMonitoring page, ChannelGrid component, route wiring, navigation links, and grid layout CSS.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-dispatch-multi-channel-monitoring/04-RESEARCH.md
@.planning/phases/04-dispatch-multi-channel-monitoring/04-01-SUMMARY.md
@web-ui/src/pages/Channels.jsx
@web-ui/src/components/ChannelCard.jsx
@web-ui/src/components/ChannelList.jsx
@web-ui/src/hooks/useChannelConnection.js
@web-ui/src/hooks/usePermissionUpdates.js
@web-ui/src/hooks/useAuth.js
@web-ui/src/context/ChannelContext.jsx
@web-ui/src/App.jsx
@web-ui/src/pages/Events.jsx
@web-ui/src/pages/Dispatch.jsx
@web-ui/src/styles.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: ChannelGrid component and DispatchMonitoring page with audio muting</name>
  <files>web-ui/src/components/ChannelGrid.jsx, web-ui/src/pages/DispatchMonitoring.jsx</files>
  <action>
**1. Create `web-ui/src/components/ChannelGrid.jsx`:**

A responsive grid component that renders compact ChannelCards:

```jsx
import React from 'react';
import ChannelCard from './ChannelCard.jsx';

const ChannelGrid = ({ channels, wsUrl, token, mutedChannels, onToggleMute }) => {
  if (!channels || channels.length === 0) {
    return (
      <div className="channel-grid__empty">
        No channels assigned. Contact an administrator for channel access.
      </div>
    );
  }

  return (
    <div className="channel-grid">
      {channels.map((channel) => (
        <ChannelCard
          key={channel.id}
          channel={channel}
          wsUrl={wsUrl}
          token={token}
          variant="compact"
          isMuted={mutedChannels.has(channel.id)}
          onToggleMute={() => onToggleMute(channel.id)}
        />
      ))}
    </div>
  );
};

export default ChannelGrid;
```

**2. Create `web-ui/src/pages/DispatchMonitoring.jsx`:**

Full monitoring page for DISPATCH users. Follow the same patterns as Channels.jsx (token fetching, ChannelProvider, permission updates) but with grid layout and mute state management.

Structure:
- Import useParams, apiPost, useAuth, ChannelProvider, useChannels, usePermissionUpdates, ChannelGrid
- Use the same `getWsUrl()` function pattern as Channels.jsx
- Fetch router token on mount via `apiPost('/api/router/token', { eventId })`
- Manage mute state with `useState(new Set())` -- a Set of muted channel IDs
- Mute all / Unmute all bulk action buttons
- Stats bar showing: total channels, muted count, active count (channels with isBusy)
- Render ChannelGrid inside ChannelProvider

Inner component pattern (same as Channels.jsx ChannelListWithPermissions):

```jsx
const MonitoringWithPermissions = ({ wsUrl, token, mutedChannels, onToggleMute }) => {
  const { channels, channelStates, setChannels } = useChannels();

  // Permission updates (same pattern as Channels.jsx)
  const handlePermissionUpdate = useCallback(({ added, removed }) => {
    setChannels((prevChannels) => {
      const filtered = prevChannels.filter((ch) => !(removed || []).includes(ch.id));
      const newChannels = (added || []).map((id) => ({ id, name: id }));
      return [...filtered, ...newChannels];
    });
  }, [setChannels]);

  usePermissionUpdates(wsUrl, token, handlePermissionUpdate);

  // Count active channels
  const activeCount = channels.filter((ch) => channelStates[ch.id]?.isBusy).length;

  return (
    <>
      <div className="dispatch-monitoring__stats">
        <span className="dispatch-monitoring__stat">
          Monitoring: <strong>{channels.length}</strong> channels
        </span>
        <span className="dispatch-monitoring__stat">
          Muted: <strong>{mutedChannels.size}</strong>
        </span>
        <span className="dispatch-monitoring__stat">
          Active: <strong>{activeCount}</strong>
        </span>
      </div>
      <ChannelGrid
        channels={channels}
        wsUrl={wsUrl}
        token={token}
        mutedChannels={mutedChannels}
        onToggleMute={onToggleMute}
      />
    </>
  );
};
```

Outer DispatchMonitoring component:
```jsx
const DispatchMonitoring = ({ user, onLogout }) => {
  const { eventId } = useParams();
  const { user: authUser, login } = useAuth();

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [token, setToken] = useState(null);
  const [wsUrl] = useState(getWsUrl());
  const [mutedChannels, setMutedChannels] = useState(new Set());

  // Fetch router token on mount (same as Channels.jsx)
  useEffect(() => {
    const fetchToken = async () => {
      setLoading(true);
      setError('');
      try {
        const response = await apiPost('/api/router/token', { eventId });
        if (!response || !response.token) throw new Error('Invalid token response');
        login(response.token);
        setToken(response.token);
      } catch (err) {
        if (err.status === 403) {
          setError('You are not active in this event. Contact an administrator for access.');
        } else {
          setError(err.message || 'Failed to load channels');
        }
      } finally {
        setLoading(false);
      }
    };
    fetchToken();
  }, [eventId, login]);

  const toggleMute = useCallback((channelId) => {
    setMutedChannels((prev) => {
      const next = new Set(prev);
      if (next.has(channelId)) {
        next.delete(channelId);
      } else {
        next.add(channelId);
      }
      return next;
    });
  }, []);

  const muteAll = useCallback(() => {
    // We need to get the current channel list -- but we can't access ChannelContext here
    // since MonitoringWithPermissions is inside the ChannelProvider.
    // Instead, set a flag and let the inner component handle it.
    // Actually, simpler: just mute all known channels by collecting them from authUser
    if (authUser && authUser.channelIds) {
      setMutedChannels(new Set(authUser.channelIds));
    }
  }, [authUser]);

  const unmuteAll = useCallback(() => {
    setMutedChannels(new Set());
  }, []);

  return (
    <div className="dispatch-monitoring">
      <header className="dispatch-monitoring__topbar panel">
        <div className="dispatch-monitoring__brand">
          <span>ConnectVoice</span>
          <h1>Multi-Channel Monitor</h1>
        </div>
        <div className="dispatch-monitoring__actions">
          <button className="btn btn--secondary" onClick={muteAll}>Mute All</button>
          <button className="btn btn--secondary" onClick={unmuteAll}>Unmute All</button>
          <button className="btn" onClick={onLogout}>Log out</button>
        </div>
      </header>

      {error && (
        <div className="alert">
          {error}
          <button className="btn btn--secondary" onClick={() => window.location.reload()} style={{ marginLeft: '12px' }}>
            Retry
          </button>
        </div>
      )}

      {loading && <div className="screen screen--center">Loading channels...</div>}

      {!loading && !error && token && authUser && (
        <ChannelProvider user={authUser}>
          <MonitoringWithPermissions
            wsUrl={wsUrl}
            token={token}
            mutedChannels={mutedChannels}
            onToggleMute={toggleMute}
          />
        </ChannelProvider>
      )}
    </div>
  );
};
```

**Audio muting implementation:**

The ChannelCard already manages ConnectionManager which creates audio internally. To actually mute audio, we need to add a `useEffect` in ChannelCard that controls the audio output when `isMuted` changes.

In the existing ChannelCard.jsx (already modified in Plan 01), add audio muting logic for the compact variant. Inside the compact variant's rendering block, add a useEffect:

```jsx
// Audio muting: find and control audio elements created by ConnectionManager
useEffect(() => {
  if (!connectionManager || variant !== 'compact') return;

  // ConnectionManager creates audio elements that play consumer tracks
  // Access the transport client to get consumers and their tracks
  const transportClient = connectionManager.getTransportClient?.();
  if (!transportClient) return;

  // The ConnectionManager creates <audio> elements with srcObject = consumer track
  // These elements are auto-playing. We need to mute/unmute them.
  // Look for audio elements that ConnectionManager created
  // ConnectionManager stores consumers, each with a track attached to an audio element
  // Since we can't directly access those audio elements, use a different approach:
  // Set track.enabled = false to stop receiving audio data (but this stops data flow)
  // Better: ConnectionManager should expose a mute method, but it doesn't.
  // Simplest approach that works: query audio elements in the DOM that belong to this card
  // But audio elements created by ConnectionManager aren't in the card's DOM tree.

  // ACTUAL approach: Use the consumer's track.enabled property
  // When muted: keep connection alive but disable track playback
  // track.enabled = false prevents audio output but keeps the track active
  // This is different from HTMLAudioElement.muted which keeps data flowing
  // For fast unmute, track.enabled toggle is near-instant
  try {
    const consumers = transportClient.getAllConsumers?.();
    if (consumers && Array.isArray(consumers)) {
      consumers.forEach((consumer) => {
        if (consumer.track) {
          consumer.track.enabled = !isMuted;
        }
      });
    }
  } catch (e) {
    // Silently ignore -- consumers may not be available yet
  }
}, [connectionManager, isMuted, variant]);
```

WAIT -- the above approach depends on TransportClient having `getAllConsumers()` and `getTransportClient()` methods. We need to check if ConnectionManager exposes these. Per 03-02 SUMMARY:
- ConnectionManager public getters: `getMicrophoneManager()`, `getTransportClient()`, `getConnectionState()`, `getChannelState()`

TransportClient should have consumer access. But we need to be careful about the API surface.

**REVISED simpler approach for audio muting:** Actually, the SIMPLEST approach is to NOT mute at the track level in this plan. Instead, add a `useRef` for an `<audio>` element overlay. When ChannelCard's `useChannelConnection` hook creates the ConnectionManager and it starts receiving audio, the audio plays through the ConnectionManager's internal audio element. We cannot easily intercept that.

**ACTUALLY SIMPLEST approach:** Add a `setMuted(boolean)` method call on the ConnectionManager if it exists, or use a workaround. Looking at the ConnectionManager from Phase 1 (01-07), it manages audio through TransportClient which creates `<audio>` elements. The TransportClient stores references to these audio elements.

For MVP: Add mute/unmute support by having the ChannelCard create its own `<audio>` element for consumer tracks IF in compact mode, rather than relying on ConnectionManager's internal audio element management. BUT this would require intercepting the consumer creation.

**FINAL practical approach:** Expose audio muting via the useChannelConnection hook. Add an optional `muted` parameter to useChannelConnection. When muted changes, iterate over the ConnectionManager's TransportClient consumers and toggle `track.enabled`. This requires adding a `useEffect` in useChannelConnection.js that watches a `muted` prop.

Actually, let's keep it even simpler. Modify `useChannelConnection.js` to accept an optional `options` parameter including `muted`:

In `web-ui/src/hooks/useChannelConnection.js`, update the hook signature:
```javascript
export const useChannelConnection = (channelId, wsUrl, token, options = {}) => {
```

Add a useEffect that handles muting when `options.muted` changes:
```javascript
// Handle audio muting
useEffect(() => {
  if (!managerRef.current) return;
  const manager = managerRef.current;

  try {
    const transportClient = manager.getTransportClient();
    if (!transportClient) return;

    // TransportClient manages consumers -- access their tracks
    const consumers = transportClient.getConsumers ? transportClient.getConsumers() : [];
    consumers.forEach((consumer) => {
      if (consumer.track) {
        consumer.track.enabled = !options.muted;
      }
    });
  } catch (e) {
    // Consumer access may fail if not yet connected
  }
}, [options.muted]);
```

Then in ChannelCard.jsx, pass the muted option:
```jsx
const { connectionState, error, connectionManager } = useChannelConnection(
  channel.id, wsUrl, token, { muted: isMuted }
);
```

IMPORTANT: Before implementing this, READ the current TransportClient source to see what methods are available for accessing consumers. Check `src/client/transportClient.ts`. If TransportClient doesn't expose a `getConsumers()` method, you'll need to find another way or skip audio muting for now and note it as a known limitation.

If TransportClient does NOT expose consumer access, use this fallback approach:
- Don't modify useChannelConnection
- In ChannelCard compact variant, set `connectionManager.audioEnabled = !isMuted` or similar
- Or create a `document.querySelectorAll('audio')` hack (not recommended)
- Or simply note that audio muting is visual-only for now and mark it as a TODO for Plan 03

THE EXECUTOR SHOULD: Read `src/client/transportClient.ts` first. If there's a way to access consumers and their tracks, implement track-level muting. If not, implement visual-only muting (the card dims, shows muted icon) and log a TODO comment that audio-level muting requires TransportClient API extension.
  </action>
  <verify>
Run `npm run build` from `web-ui/` to confirm the build succeeds.
Verify DispatchMonitoring.jsx exists and imports ChannelGrid.
Verify ChannelGrid.jsx exists and renders ChannelCard with variant="compact".
Check that DispatchMonitoring handles token fetching, permission updates, and mute state.
  </verify>
  <done>
DispatchMonitoring page fetches router token, wraps content in ChannelProvider, renders ChannelGrid with compact ChannelCards.
ChannelGrid renders responsive grid of compact ChannelCards.
Mute/unmute toggles per channel (visual, and audio-level if TransportClient supports it).
Mute All / Unmute All bulk actions work.
Stats bar shows monitoring count, muted count, active count.
Real-time permission updates add/remove channels dynamically.
Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Route wiring, navigation links, and grid CSS</name>
  <files>web-ui/src/App.jsx, web-ui/src/pages/Events.jsx, web-ui/src/pages/Dispatch.jsx, web-ui/src/styles.css</files>
  <action>
**1. Add route in `web-ui/src/App.jsx`:**

Import DispatchMonitoring at the top:
```jsx
import DispatchMonitoring from './pages/DispatchMonitoring.jsx';
```

Add a new Route BEFORE the `path="*"` catch-all route, following the same auth pattern as existing routes:
```jsx
<Route
  path="/event/:eventId/monitoring"
  element={
    user ? (
      needsSetup ? (
        <Navigate to="/first-run" replace />
      ) : (
        <DispatchMonitoring user={user} onLogout={handleLogout} />
      )
    ) : (
      <Navigate to="/login" replace />
    )
  }
/>
```

**2. Add navigation link in `web-ui/src/pages/Events.jsx`:**

Add a "Multi-Channel Monitor" link in each event card's actions area. This should appear AFTER the existing "My Channels" and "Dispatch View" links. Add it conditionally for DISPATCH and ADMIN roles (they can access the monitoring page).

Look at the existing event card rendering. Find where the "Dispatch View" link is rendered. Add after it:
```jsx
{(user.globalRole === 'DISPATCH' || user.globalRole === 'ADMIN' ||
  event.role === 'DISPATCH' || event.role === 'ADMIN') && (
  <a href={`/event/${event.id}/monitoring`} className="btn btn--secondary">
    Multi-Channel Monitor
  </a>
)}
```

NOTE: Check the existing Events.jsx code to see how roles are checked. The existing "Dispatch View" link probably already has a role check pattern -- follow the same pattern. If Events.jsx uses the event's role field or the user's global role, match that approach.

**3. Add navigation link in `web-ui/src/pages/Dispatch.jsx`:**

In the Dispatch page header (the control-plane topbar), add a link to the monitoring page. This is the existing dispatch console that DISPATCH users see. Add a "Monitor Channels" button in the `control-plane__actions` div:

```jsx
<a href={`/event/${eventId}/monitoring`} className="btn btn--secondary">
  Monitor Channels
</a>
```

Place it before the "Log out" button in the `control-plane__actions` div.

**4. Add grid CSS to `web-ui/src/styles.css`:**

Append dispatch monitoring page styles:

```css
/* === Dispatch Monitoring Page === */
.dispatch-monitoring {
  min-height: 100vh;
  padding: 16px 20px 32px;
}

.dispatch-monitoring__topbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
  flex-wrap: wrap;
  gap: 12px;
}

.dispatch-monitoring__brand {
  display: flex;
  flex-direction: column;
}

.dispatch-monitoring__brand span {
  color: var(--muted);
  font-size: 0.85rem;
}

.dispatch-monitoring__brand h1 {
  font-size: 1.4rem;
  margin: 0;
}

.dispatch-monitoring__actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.dispatch-monitoring__stats {
  display: flex;
  gap: 20px;
  padding: 8px 16px;
  background: var(--surface);
  border-radius: 8px;
  margin-bottom: 16px;
  box-shadow: 0 1px 3px var(--shadow);
}

.dispatch-monitoring__stat {
  font-size: 0.9rem;
  color: var(--muted);
}

.dispatch-monitoring__stat strong {
  color: var(--ink);
}

/* Channel Grid */
.channel-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 12px;
}

.channel-grid__empty {
  grid-column: 1 / -1;
  text-align: center;
  padding: 48px 24px;
  color: var(--muted);
  font-size: 1rem;
}

/* Responsive grid breakpoints for dispatch monitoring */
@media (min-width: 1920px) {
  .channel-grid {
    grid-template-columns: repeat(10, 1fr);
  }
}

@media (min-width: 1280px) and (max-width: 1919px) {
  .channel-grid {
    grid-template-columns: repeat(8, 1fr);
  }
}

@media (min-width: 900px) and (max-width: 1279px) {
  .channel-grid {
    grid-template-columns: repeat(6, 1fr);
  }
}

@media (max-width: 899px) {
  .channel-grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

@media (max-width: 600px) {
  .channel-grid {
    grid-template-columns: repeat(2, 1fr);
  }

  .dispatch-monitoring {
    padding: 12px;
  }

  .dispatch-monitoring__topbar {
    flex-direction: column;
    align-items: flex-start;
  }

  .dispatch-monitoring__stats {
    flex-wrap: wrap;
    gap: 12px;
  }
}
```
  </action>
  <verify>
Run `npm run build` from `web-ui/` to confirm the build succeeds.
Check that App.jsx has the `/event/:eventId/monitoring` route.
Check that Events.jsx has the "Multi-Channel Monitor" link for DISPATCH/ADMIN users.
Check that Dispatch.jsx has the "Monitor Channels" link.
Check that styles.css has `.dispatch-monitoring` and `.channel-grid` styles.
  </verify>
  <done>
Route `/event/:eventId/monitoring` exists in App.jsx with auth protection.
Events page shows "Multi-Channel Monitor" link for DISPATCH and ADMIN users.
Dispatch page shows "Monitor Channels" link to monitoring page.
CSS grid layout supports 50 channels with responsive breakpoints (10 cols on 1920px, 8 on 1280px, 6 on 900px, 3 on small, 2 on mobile).
Build passes.
  </done>
</task>

</tasks>

<verification>
- `npm run build` passes in web-ui
- DispatchMonitoring page exists at `/event/:eventId/monitoring`
- ChannelGrid renders compact ChannelCards in responsive grid
- Mute toggle state managed per channel
- Permission updates dynamically add/remove channels
- Navigation links exist from Events page and Dispatch page
</verification>

<success_criteria>
1. Dispatch user can navigate to `/event/:eventId/monitoring` via links on Events or Dispatch pages
2. Monitoring page shows all assigned channels in a compact grid layout
3. Each channel card has mute toggle, activity indicator, and PTT button
4. Mute All / Unmute All buttons work
5. Stats bar shows monitoring count, muted count, and active count
6. Real-time permission updates add/remove channels
7. Grid is responsive (10 cols on ultrawide, scaling down to 2 on mobile)
8. Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-dispatch-multi-channel-monitoring/04-02-SUMMARY.md`
</output>
