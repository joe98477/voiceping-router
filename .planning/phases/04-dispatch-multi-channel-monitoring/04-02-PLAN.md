---
phase: 04-dispatch-multi-channel-monitoring
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - web-ui/src/pages/DispatchMonitoring.jsx
  - web-ui/src/components/ChannelGrid.jsx
  - web-ui/src/App.jsx
  - web-ui/src/pages/Events.jsx
  - web-ui/src/pages/Dispatch.jsx
  - web-ui/src/styles.css
  - web-ui/src/hooks/useChannelConnection.js
autonomous: true

must_haves:
  truths:
    - "Dispatch user can navigate to multi-channel monitoring page"
    - "Dispatch user sees all assigned channels in a responsive grid"
    - "Dispatch user can mute/unmute individual channels"
    - "Dispatch user can transmit PTT on any monitored channel"
    - "Dispatch user sees visual activity indicators on active channels"
    - "Audio from muted channels is silenced, unmuted channels play audio"
  artifacts:
    - path: "web-ui/src/pages/DispatchMonitoring.jsx"
      provides: "Multi-channel monitoring page for DISPATCH users"
      min_lines: 80
    - path: "web-ui/src/components/ChannelGrid.jsx"
      provides: "Responsive grid layout rendering compact ChannelCards"
      min_lines: 20
    - path: "web-ui/src/App.jsx"
      provides: "Route for /event/:eventId/monitoring"
      contains: "monitoring"
    - path: "web-ui/src/styles.css"
      provides: "Grid layout CSS for dispatch monitoring"
      contains: "dispatch-monitoring"
  key_links:
    - from: "web-ui/src/pages/DispatchMonitoring.jsx"
      to: "web-ui/src/components/ChannelGrid.jsx"
      via: "import and render ChannelGrid"
      pattern: "ChannelGrid"
    - from: "web-ui/src/components/ChannelGrid.jsx"
      to: "web-ui/src/components/ChannelCard.jsx"
      via: "renders compact ChannelCard per channel"
      pattern: 'variant.*compact'
    - from: "web-ui/src/pages/DispatchMonitoring.jsx"
      to: "web-ui/src/hooks/usePermissionUpdates.js"
      via: "real-time permission sync for channel list"
      pattern: "usePermissionUpdates"
    - from: "web-ui/src/App.jsx"
      to: "web-ui/src/pages/DispatchMonitoring.jsx"
      via: "Route path /event/:eventId/monitoring"
      pattern: "monitoring"
    - from: "web-ui/src/hooks/useChannelConnection.js"
      to: "connectionManager.getTransportClient().getAllConsumers()"
      via: "useEffect toggling consumer track.enabled based on muted option"
      pattern: "track\\.enabled"
---

<objective>
DispatchMonitoring page with responsive channel grid, per-channel mute/unmute, and audio management for multi-channel monitoring.

Purpose: Deliver the core dispatch multi-channel monitoring UI that enables DISPATCH users to see all assigned channels in a compact grid, selectively mute/unmute channels, transmit PTT on any channel, and see real-time activity indicators.

Output: DispatchMonitoring page, ChannelGrid component, route wiring, navigation links, audio muting in useChannelConnection, and grid layout CSS.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-dispatch-multi-channel-monitoring/04-RESEARCH.md
@.planning/phases/04-dispatch-multi-channel-monitoring/04-01-SUMMARY.md
@web-ui/src/pages/Channels.jsx
@web-ui/src/components/ChannelCard.jsx
@web-ui/src/components/ChannelList.jsx
@web-ui/src/hooks/useChannelConnection.js
@web-ui/src/hooks/usePermissionUpdates.js
@web-ui/src/hooks/useAuth.js
@web-ui/src/context/ChannelContext.jsx
@web-ui/src/App.jsx
@web-ui/src/pages/Events.jsx
@web-ui/src/pages/Dispatch.jsx
@web-ui/src/styles.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: ChannelGrid component, DispatchMonitoring page, and audio muting via useChannelConnection</name>
  <files>web-ui/src/components/ChannelGrid.jsx, web-ui/src/pages/DispatchMonitoring.jsx, web-ui/src/hooks/useChannelConnection.js</files>
  <action>
**1. Add audio muting support to `web-ui/src/hooks/useChannelConnection.js`:**

Update the hook signature to accept an optional fourth `options` parameter:

```javascript
export const useChannelConnection = (channelId, wsUrl, token, options = {}) => {
```

Add a `useEffect` AFTER the existing connection useEffect (not inside it) that handles muting. This effect watches `options.muted` and toggles consumer track playback via the existing API chain:

```javascript
// Handle audio muting via consumer track.enabled
// API chain: ConnectionManager.getTransportClient() -> TransportClient.getAllConsumers() -> consumer.track.enabled
useEffect(() => {
  if (!managerRef.current) return;

  try {
    const transportClient = managerRef.current.getTransportClient();
    if (!transportClient) return;

    const consumers = transportClient.getAllConsumers();
    consumers.forEach((consumer) => {
      if (consumer.track) {
        consumer.track.enabled = !options.muted;
      }
    });
  } catch (e) {
    // Consumers may not be available yet during initial connection
    console.debug(`[${channelId}] Mute toggle skipped: consumers not ready`);
  }
}, [options.muted, channelId]);
```

Why this works: `ConnectionManager` exposes `getTransportClient()` which returns the `TransportClient` instance. `TransportClient` exposes `getAllConsumers()` which returns all mediasoup `Consumer` objects from its internal Map. Each `Consumer` has a `.track` (MediaStreamTrack). Setting `track.enabled = false` silences audio output instantly while keeping the WebRTC connection alive. Setting `track.enabled = true` restores audio instantly. This is the standard WebRTC approach for muting received audio.

Also, add a second `useEffect` to re-apply mute state when new consumers arrive (since consumers are created asynchronously when other users start transmitting). Use an interval that runs only when muted:

```javascript
// Re-apply mute when new consumers arrive (consumers are created dynamically)
useEffect(() => {
  if (!options.muted || !managerRef.current) return;

  const interval = setInterval(() => {
    try {
      const transportClient = managerRef.current?.getTransportClient();
      if (!transportClient) return;

      const consumers = transportClient.getAllConsumers();
      consumers.forEach((consumer) => {
        if (consumer.track && consumer.track.enabled) {
          consumer.track.enabled = false;
        }
      });
    } catch (e) {
      // Ignore
    }
  }, 500);

  return () => clearInterval(interval);
}, [options.muted]);
```

This 500ms polling ensures newly arriving consumers get muted too. The interval only runs while `options.muted` is true, so there is zero overhead when unmuted.

Existing callers of `useChannelConnection(channelId, wsUrl, token)` are unaffected -- the fourth parameter defaults to `{}` so `options.muted` is `undefined` (falsy), and both new useEffects become no-ops.

**2. Create `web-ui/src/components/ChannelGrid.jsx`:**

A responsive grid component that renders compact ChannelCards:

```jsx
import React from 'react';
import ChannelCard from './ChannelCard.jsx';

const ChannelGrid = ({ channels, wsUrl, token, mutedChannels, onToggleMute }) => {
  if (!channels || channels.length === 0) {
    return (
      <div className="channel-grid__empty">
        No channels assigned. Contact an administrator for channel access.
      </div>
    );
  }

  return (
    <div className="channel-grid">
      {channels.map((channel) => (
        <ChannelCard
          key={channel.id}
          channel={channel}
          wsUrl={wsUrl}
          token={token}
          variant="compact"
          isMuted={mutedChannels.has(channel.id)}
          onToggleMute={() => onToggleMute(channel.id)}
        />
      ))}
    </div>
  );
};

export default ChannelGrid;
```

**3. Create `web-ui/src/pages/DispatchMonitoring.jsx`:**

Full monitoring page for DISPATCH users. Follow the same patterns as Channels.jsx (token fetching, ChannelProvider, permission updates) but with grid layout and mute state management.

Structure:
- Import useParams, apiPost, useAuth, ChannelProvider, useChannels, usePermissionUpdates, ChannelGrid
- Use the same `getWsUrl()` function pattern as Channels.jsx
- Fetch router token on mount via `apiPost('/api/router/token', { eventId })`
- Manage mute state with `useState(new Set())` -- a Set of muted channel IDs
- Mute all / Unmute all bulk action buttons
- Stats bar showing: total channels, muted count, active count (channels with isBusy)
- Render ChannelGrid inside ChannelProvider

Inner component pattern (same as Channels.jsx ChannelListWithPermissions):

```jsx
const MonitoringWithPermissions = ({ wsUrl, token, mutedChannels, onToggleMute }) => {
  const { channels, channelStates, setChannels } = useChannels();

  // Permission updates (same pattern as Channels.jsx)
  const handlePermissionUpdate = useCallback(({ added, removed }) => {
    setChannels((prevChannels) => {
      const filtered = prevChannels.filter((ch) => !(removed || []).includes(ch.id));
      const newChannels = (added || []).map((id) => ({ id, name: id }));
      return [...filtered, ...newChannels];
    });
  }, [setChannels]);

  usePermissionUpdates(wsUrl, token, handlePermissionUpdate);

  // Count active channels
  const activeCount = channels.filter((ch) => channelStates[ch.id]?.isBusy).length;

  return (
    <>
      <div className="dispatch-monitoring__stats">
        <span className="dispatch-monitoring__stat">
          Monitoring: <strong>{channels.length}</strong> channels
        </span>
        <span className="dispatch-monitoring__stat">
          Muted: <strong>{mutedChannels.size}</strong>
        </span>
        <span className="dispatch-monitoring__stat">
          Active: <strong>{activeCount}</strong>
        </span>
      </div>
      <ChannelGrid
        channels={channels}
        wsUrl={wsUrl}
        token={token}
        mutedChannels={mutedChannels}
        onToggleMute={onToggleMute}
      />
    </>
  );
};
```

Outer DispatchMonitoring component:
```jsx
const DispatchMonitoring = ({ user, onLogout }) => {
  const { eventId } = useParams();
  const { user: authUser, login } = useAuth();

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [token, setToken] = useState(null);
  const [wsUrl] = useState(getWsUrl());
  const [mutedChannels, setMutedChannels] = useState(new Set());

  // Fetch router token on mount (same as Channels.jsx)
  useEffect(() => {
    const fetchToken = async () => {
      setLoading(true);
      setError('');
      try {
        const response = await apiPost('/api/router/token', { eventId });
        if (!response || !response.token) throw new Error('Invalid token response');
        login(response.token);
        setToken(response.token);
      } catch (err) {
        if (err.status === 403) {
          setError('You are not active in this event. Contact an administrator for access.');
        } else {
          setError(err.message || 'Failed to load channels');
        }
      } finally {
        setLoading(false);
      }
    };
    fetchToken();
  }, [eventId, login]);

  const toggleMute = useCallback((channelId) => {
    setMutedChannels((prev) => {
      const next = new Set(prev);
      if (next.has(channelId)) {
        next.delete(channelId);
      } else {
        next.add(channelId);
      }
      return next;
    });
  }, []);

  const muteAll = useCallback(() => {
    if (authUser && authUser.channelIds) {
      setMutedChannels(new Set(authUser.channelIds));
    }
  }, [authUser]);

  const unmuteAll = useCallback(() => {
    setMutedChannels(new Set());
  }, []);

  return (
    <div className="dispatch-monitoring">
      <header className="dispatch-monitoring__topbar panel">
        <div className="dispatch-monitoring__brand">
          <span>ConnectVoice</span>
          <h1>Multi-Channel Monitor</h1>
        </div>
        <div className="dispatch-monitoring__actions">
          <button className="btn btn--secondary" onClick={muteAll}>Mute All</button>
          <button className="btn btn--secondary" onClick={unmuteAll}>Unmute All</button>
          <button className="btn" onClick={onLogout}>Log out</button>
        </div>
      </header>

      {error && (
        <div className="alert">
          {error}
          <button className="btn btn--secondary" onClick={() => window.location.reload()} style={{ marginLeft: '12px' }}>
            Retry
          </button>
        </div>
      )}

      {loading && <div className="screen screen--center">Loading channels...</div>}

      {!loading && !error && token && authUser && (
        <ChannelProvider user={authUser}>
          <MonitoringWithPermissions
            wsUrl={wsUrl}
            token={token}
            mutedChannels={mutedChannels}
            onToggleMute={toggleMute}
          />
        </ChannelProvider>
      )}
    </div>
  );
};
```

**4. Wire audio muting into ChannelCard compact variant:**

In `web-ui/src/components/ChannelCard.jsx`, the compact variant (added in Plan 01) calls `useChannelConnection(channel.id, wsUrl, token)`. Update this call to pass the muted option:

```jsx
const { connectionState, error, connectionManager } = useChannelConnection(
  channel.id, wsUrl, token, { muted: isMuted }
);
```

This must be done ONLY for the compact variant path. Since the existing ChannelCard calls useChannelConnection at the top of the component (before the variant check), the simplest approach is to pass `{ muted: isMuted || false }` in the existing call. When `isMuted` is undefined (default variant), this becomes `{ muted: false }` which is a no-op in the hook.
  </action>
  <verify>
Run `npm run build` from `web-ui/` to confirm the build succeeds.
Verify DispatchMonitoring.jsx exists and imports ChannelGrid.
Verify ChannelGrid.jsx exists and renders ChannelCard with variant="compact".
Verify useChannelConnection.js accepts options parameter and has track.enabled muting logic.
Check that DispatchMonitoring handles token fetching, permission updates, and mute state.
  </verify>
  <done>
DispatchMonitoring page fetches router token, wraps content in ChannelProvider, renders ChannelGrid with compact ChannelCards.
ChannelGrid renders responsive grid of compact ChannelCards.
Audio muting works at the WebRTC track level: useChannelConnection toggles consumer.track.enabled via ConnectionManager.getTransportClient().getAllConsumers().
Mute/unmute toggles per channel with real audio silencing.
Mute All / Unmute All bulk actions work.
Stats bar shows monitoring count, muted count, active count.
Real-time permission updates add/remove channels dynamically.
Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Route wiring, navigation links, and grid CSS</name>
  <files>web-ui/src/App.jsx, web-ui/src/pages/Events.jsx, web-ui/src/pages/Dispatch.jsx, web-ui/src/styles.css</files>
  <action>
**1. Add route in `web-ui/src/App.jsx`:**

Import DispatchMonitoring at the top:
```jsx
import DispatchMonitoring from './pages/DispatchMonitoring.jsx';
```

Add a new Route BEFORE the `path="*"` catch-all route, following the same auth pattern as existing routes:
```jsx
<Route
  path="/event/:eventId/monitoring"
  element={
    user ? (
      needsSetup ? (
        <Navigate to="/first-run" replace />
      ) : (
        <DispatchMonitoring user={user} onLogout={handleLogout} />
      )
    ) : (
      <Navigate to="/login" replace />
    )
  }
/>
```

**2. Add navigation link in `web-ui/src/pages/Events.jsx`:**

Add a "Multi-Channel Monitor" link in each event card's actions area. This should appear AFTER the existing "My Channels" and "Dispatch View" links. Add it conditionally for DISPATCH and ADMIN roles (they can access the monitoring page).

Look at the existing event card rendering. Find where the "Dispatch View" link is rendered. Add after it:
```jsx
{(user.globalRole === 'DISPATCH' || user.globalRole === 'ADMIN' ||
  event.role === 'DISPATCH' || event.role === 'ADMIN') && (
  <a href={`/event/${event.id}/monitoring`} className="btn btn--secondary">
    Multi-Channel Monitor
  </a>
)}
```

NOTE: Check the existing Events.jsx code to see how roles are checked. The existing "Dispatch View" link probably already has a role check pattern -- follow the same pattern. If Events.jsx uses the event's role field or the user's global role, match that approach.

**3. Add navigation link in `web-ui/src/pages/Dispatch.jsx`:**

In the Dispatch page header (the control-plane topbar), add a link to the monitoring page. This is the existing dispatch console that DISPATCH users see. Add a "Monitor Channels" button in the `control-plane__actions` div:

```jsx
<a href={`/event/${eventId}/monitoring`} className="btn btn--secondary">
  Monitor Channels
</a>
```

Place it before the "Log out" button in the `control-plane__actions` div.

**4. Add grid CSS to `web-ui/src/styles.css`:**

Append dispatch monitoring page styles:

```css
/* === Dispatch Monitoring Page === */
.dispatch-monitoring {
  min-height: 100vh;
  padding: 16px 20px 32px;
}

.dispatch-monitoring__topbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
  flex-wrap: wrap;
  gap: 12px;
}

.dispatch-monitoring__brand {
  display: flex;
  flex-direction: column;
}

.dispatch-monitoring__brand span {
  color: var(--muted);
  font-size: 0.85rem;
}

.dispatch-monitoring__brand h1 {
  font-size: 1.4rem;
  margin: 0;
}

.dispatch-monitoring__actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.dispatch-monitoring__stats {
  display: flex;
  gap: 20px;
  padding: 8px 16px;
  background: var(--surface);
  border-radius: 8px;
  margin-bottom: 16px;
  box-shadow: 0 1px 3px var(--shadow);
}

.dispatch-monitoring__stat {
  font-size: 0.9rem;
  color: var(--muted);
}

.dispatch-monitoring__stat strong {
  color: var(--ink);
}

/* Channel Grid */
.channel-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 12px;
}

.channel-grid__empty {
  grid-column: 1 / -1;
  text-align: center;
  padding: 48px 24px;
  color: var(--muted);
  font-size: 1rem;
}

/* Responsive grid breakpoints for dispatch monitoring */
@media (min-width: 1920px) {
  .channel-grid {
    grid-template-columns: repeat(10, 1fr);
  }
}

@media (min-width: 1280px) and (max-width: 1919px) {
  .channel-grid {
    grid-template-columns: repeat(8, 1fr);
  }
}

@media (min-width: 900px) and (max-width: 1279px) {
  .channel-grid {
    grid-template-columns: repeat(6, 1fr);
  }
}

@media (max-width: 899px) {
  .channel-grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

@media (max-width: 600px) {
  .channel-grid {
    grid-template-columns: repeat(2, 1fr);
  }

  .dispatch-monitoring {
    padding: 12px;
  }

  .dispatch-monitoring__topbar {
    flex-direction: column;
    align-items: flex-start;
  }

  .dispatch-monitoring__stats {
    flex-wrap: wrap;
    gap: 12px;
  }
}
```
  </action>
  <verify>
Run `npm run build` from `web-ui/` to confirm the build succeeds.
Check that App.jsx has the `/event/:eventId/monitoring` route.
Check that Events.jsx has the "Multi-Channel Monitor" link for DISPATCH/ADMIN users.
Check that Dispatch.jsx has the "Monitor Channels" link.
Check that styles.css has `.dispatch-monitoring` and `.channel-grid` styles.
  </verify>
  <done>
Route `/event/:eventId/monitoring` exists in App.jsx with auth protection.
Events page shows "Multi-Channel Monitor" link for DISPATCH and ADMIN users.
Dispatch page shows "Monitor Channels" link to monitoring page.
CSS grid layout supports 50 channels with responsive breakpoints (10 cols on 1920px, 8 on 1280px, 6 on 900px, 3 on small, 2 on mobile).
Build passes.
  </done>
</task>

</tasks>

<verification>
- `npm run build` passes in web-ui
- DispatchMonitoring page exists at `/event/:eventId/monitoring`
- ChannelGrid renders compact ChannelCards in responsive grid
- Audio muting works: useChannelConnection toggles consumer.track.enabled when options.muted changes
- Mute toggle state managed per channel
- Permission updates dynamically add/remove channels
- Navigation links exist from Events page and Dispatch page
</verification>

<success_criteria>
1. Dispatch user can navigate to `/event/:eventId/monitoring` via links on Events or Dispatch pages
2. Monitoring page shows all assigned channels in a compact grid layout
3. Each channel card has mute toggle, activity indicator, and PTT button
4. Audio muting silences received audio at the WebRTC track level (not visual-only)
5. Mute All / Unmute All buttons work
6. Stats bar shows monitoring count, muted count, and active count
7. Real-time permission updates add/remove channels
8. Grid is responsive (10 cols on ultrawide, scaling down to 2 on mobile)
9. Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-dispatch-multi-channel-monitoring/04-02-SUMMARY.md`
</output>
