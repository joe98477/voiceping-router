---
phase: 10-network-resilience-ux-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - android/app/src/main/java/com/voiceping/android/data/network/NetworkMonitor.kt
  - android/app/src/main/java/com/voiceping/android/domain/model/ConnectionState.kt
  - android/app/src/main/java/com/voiceping/android/data/network/SignalingClient.kt
  - android/app/src/main/java/com/voiceping/android/domain/model/NetworkType.kt
autonomous: true

must_haves:
  truths:
    - "App auto-reconnects silently after network loss with exponential backoff (1s, 2s, 4s, 8s... capped at 30s)"
    - "App gives up reconnection after 5 minutes and shows Connection lost with Retry button"
    - "When network becomes available again, reconnection retries immediately with reset backoff"
    - "WiFi-to-cellular handoff triggers transparent reconnection without releasing PTT"
    - "WebSocket heartbeat measures round-trip latency for network quality display"
    - "App transitions through RECONNECTING state before giving up (distinct from initial CONNECTING)"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/data/network/NetworkMonitor.kt"
      provides: "ConnectivityManager wrapper exposing network availability and type"
      contains: "NetworkCallback"
    - path: "android/app/src/main/java/com/voiceping/android/domain/model/ConnectionState.kt"
      provides: "Enhanced ConnectionState with RECONNECTING"
      contains: "RECONNECTING"
    - path: "android/app/src/main/java/com/voiceping/android/data/network/SignalingClient.kt"
      provides: "WebSocket reconnection with exponential backoff and latency measurement"
      contains: "scheduleReconnect"
    - path: "android/app/src/main/java/com/voiceping/android/domain/model/NetworkType.kt"
      provides: "Network type enum (WIFI, CELLULAR, NONE, OTHER)"
      contains: "enum class NetworkType"
  key_links:
    - from: "SignalingClient"
      to: "NetworkMonitor"
      via: "isNetworkAvailable Flow collection resets backoff"
      pattern: "networkMonitor\\.isNetworkAvailable"
    - from: "SignalingClient"
      to: "ConnectionState.RECONNECTING"
      via: "state transition on WebSocket failure"
      pattern: "ConnectionState\\.RECONNECTING"
---

<objective>
Network resilience foundation: NetworkMonitor for connectivity detection and SignalingClient enhancement with exponential backoff reconnection, latency measurement, and WiFi/cellular handoff support.

Purpose: NET-01 (auto-reconnect) and NET-02 (WiFi-to-cellular handoff) depend on detecting network state changes and automatically reconnecting the WebSocket. This plan creates the foundation that all reconnection UI and offline behavior build upon.

Output: NetworkMonitor.kt, enhanced SignalingClient.kt with reconnection logic, enhanced ConnectionState with RECONNECTING, NetworkType enum, latency StateFlow.
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-network-resilience-ux-polish/10-CONTEXT.md
@.planning/phases/10-network-resilience-ux-polish/10-RESEARCH.md
@android/app/src/main/java/com/voiceping/android/data/network/SignalingClient.kt
@android/app/src/main/java/com/voiceping/android/domain/model/ConnectionState.kt
@android/app/src/main/java/com/voiceping/android/di/NetworkModule.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NetworkMonitor and NetworkType model</name>
  <files>
    android/app/src/main/java/com/voiceping/android/data/network/NetworkMonitor.kt
    android/app/src/main/java/com/voiceping/android/domain/model/NetworkType.kt
    android/app/src/main/java/com/voiceping/android/domain/model/ConnectionState.kt
  </files>
  <action>
    1. Create NetworkType enum in domain/model/NetworkType.kt:
       - Values: WIFI, CELLULAR, NONE, OTHER
       - Simple enum, no methods needed.

    2. Enhance ConnectionState enum in domain/model/ConnectionState.kt:
       - Add RECONNECTING between CONNECTED and FAILED.
       - Final values: DISCONNECTED, CONNECTING, CONNECTED, RECONNECTING, FAILED.

    3. Create NetworkMonitor in data/network/NetworkMonitor.kt:
       - @Singleton class with @Inject constructor(@ApplicationContext context: Context)
       - Get ConnectivityManager from context.getSystemService(ConnectivityManager::class.java)
       - Expose `isNetworkAvailable: StateFlow<Boolean>` (MutableStateFlow, default false)
       - Expose `networkType: StateFlow<NetworkType>` (MutableStateFlow, default NONE)
       - Private inner NetworkCallback:
         - onAvailable(network): set isNetworkAvailable = true
         - onLost(network): set isNetworkAvailable = false, networkType = NONE
         - onCapabilitiesChanged(network, capabilities): detect transport type:
           - hasTransport(TRANSPORT_WIFI) -> WIFI
           - hasTransport(TRANSPORT_CELLULAR) -> CELLULAR
           - else -> OTHER
       - `start()` method: Build NetworkRequest with NET_CAPABILITY_INTERNET, register callback.
         Also check initial state: connectivityManager.activeNetwork + getNetworkCapabilities.
       - `stop()` method: unregisterNetworkCallback.
       - Log network transitions at INFO level for debugging.
  </action>
  <verify>
    cd android && ./gradlew compileDebugKotlin 2>&1 | tail -5
    Verify: NetworkMonitor.kt, NetworkType.kt exist with correct content.
    Verify: ConnectionState.kt has RECONNECTING value.
  </verify>
  <done>
    NetworkMonitor wraps ConnectivityManager with NetworkCallback, exposes isNetworkAvailable and networkType as StateFlows. ConnectionState has RECONNECTING. NetworkType enum has WIFI, CELLULAR, NONE, OTHER.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance SignalingClient with reconnection and latency measurement</name>
  <files>
    android/app/src/main/java/com/voiceping/android/data/network/SignalingClient.kt
  </files>
  <action>
    Enhance existing SignalingClient to add exponential backoff reconnection and latency measurement. Per locked user decisions:
    - Exponential backoff: 1s, 2s, 4s, 8s... capped at 30s
    - Max retry: 5 minutes total, then show FAILED state
    - Network restore: Reset backoff and retry immediately
    - Brief drops (1-3s): Silent resume
    - Long disconnection (5+s): RECONNECTING state

    **Changes to SignalingClient:**

    1. Add NetworkMonitor as constructor parameter:
       ```
       class SignalingClient @Inject constructor(
           private val gson: Gson,
           private val networkMonitor: NetworkMonitor
       )
       ```

    2. Add reconnection state fields:
       - `private var reconnectAttempt = 0`
       - `private var reconnectJob: Job? = null`
       - `private var lastServerUrl: String? = null`
       - `private var lastToken: String? = null`
       - `private var disconnectedAt: Long? = null` (timestamp when disconnect detected)
       - `private val maxReconnectDurationMs = 5 * 60 * 1000L` (5 minutes)
       - `private var reconnectStartTime: Long? = null`

    3. Add latency measurement:
       - `private val _latency = MutableStateFlow<Long?>(null)`
       - `val latency: StateFlow<Long?> = _latency.asStateFlow()`
       - Modify startHeartbeat() to measure round-trip time:
         Record System.currentTimeMillis() before sending PING via request() (not fire-and-forget send()).
         After response received, calculate RTT = currentTime - startTime.
         Set _latency.value = rtt.
         If PING times out or fails, set _latency.value = null.
         Use try/catch around the request call since it has 10s timeout.

    4. Store connection params in connect():
       - Save serverUrl and token to lastServerUrl/lastToken before connecting.
       - Reset reconnectAttempt = 0 on successful fresh connect.

    5. Modify onFailure handler:
       - Instead of immediately setting FAILED, start reconnection:
       - Set disconnectedAt = System.currentTimeMillis() if null
       - Set reconnectStartTime if null (tracks 5-minute window)
       - Set _connectionState.value = ConnectionState.RECONNECTING
       - Call scheduleReconnect()
       - Still complete pending requests exceptionally and cancel heartbeat.

    6. Modify onClosing/onClosed handlers:
       - If close code is NOT 1000 (normal close), treat as unexpected disconnect and start reconnection same as onFailure.
       - If close code IS 1000 (client-initiated disconnect via disconnect()), set DISCONNECTED (no reconnect).

    7. Add calculateBackoff() method:
       ```kotlin
       private fun calculateBackoff(): Long {
           val delay = (2.0.pow(reconnectAttempt.toDouble()) * 1000L).toLong()
           return delay.coerceAtMost(30_000L) // Cap at 30 seconds per user decision
       }
       ```
       Import kotlin.math.pow.

    8. Add scheduleReconnect() method:
       ```kotlin
       private fun scheduleReconnect() {
           reconnectJob?.cancel() // Cancel existing to prevent race conditions

           if (_connectionState.value != ConnectionState.RECONNECTING) return

           // Check 5-minute max retry window
           val startTime = reconnectStartTime ?: return
           if (System.currentTimeMillis() - startTime > maxReconnectDurationMs) {
               Log.w(TAG, "Reconnection timeout after 5 minutes, giving up")
               _connectionState.value = ConnectionState.FAILED
               resetReconnectionState()
               return
           }

           reconnectJob = scope.launch {
               val delay = calculateBackoff()
               Log.d(TAG, "Scheduling reconnect attempt ${reconnectAttempt + 1} in ${delay}ms")
               delay(delay)
               reconnectAttempt++
               try {
                   val url = lastServerUrl ?: return@launch
                   val token = lastToken ?: return@launch
                   connect(url, token)
               } catch (e: Exception) {
                   Log.e(TAG, "Reconnect attempt failed", e)
                   // onFailure will handle next retry
               }
           }
       }
       ```

    9. Add resetReconnectionState() helper:
       ```kotlin
       private fun resetReconnectionState() {
           reconnectAttempt = 0
           reconnectStartTime = null
           disconnectedAt = null
           reconnectJob?.cancel()
           reconnectJob = null
       }
       ```

    10. Modify onOpen handler:
        - After setting CONNECTED and starting heartbeat, also call resetReconnectionState().
        - This handles successful reconnection clearing all retry state.

    11. Add manualRetry() method for the "Retry" button after FAILED state:
        ```kotlin
        fun manualRetry() {
            if (_connectionState.value != ConnectionState.FAILED) return
            reconnectStartTime = System.currentTimeMillis() // Reset 5-minute window
            reconnectAttempt = 0
            _connectionState.value = ConnectionState.RECONNECTING
            scheduleReconnect()
        }
        ```

    12. Add NetworkMonitor observation in init block:
        ```kotlin
        init {
            scope.launch {
                networkMonitor.isNetworkAvailable.collect { available ->
                    if (available && _connectionState.value == ConnectionState.RECONNECTING) {
                        Log.d(TAG, "Network available, resetting backoff and retrying immediately")
                        reconnectAttempt = 0 // Reset backoff per user decision
                        reconnectJob?.cancel()
                        scheduleReconnect()
                    }
                }
            }
        }
        ```

    13. Modify disconnect() method:
        - Add resetReconnectionState() call to prevent reconnection after explicit disconnect.
        - Set a flag `private var intentionalDisconnect = false` set to true in disconnect(), checked in onClosing/onClosed to prevent reconnection.
        - Reset flag in connect().

    **Important:** Do NOT change the heartbeat interval (25s). The latency measurement piggybacks on the existing heartbeat by changing send() to request() for PING and measuring RTT.
  </action>
  <verify>
    cd android && ./gradlew compileDebugKotlin 2>&1 | tail -5
    Verify: SignalingClient has scheduleReconnect, calculateBackoff, manualRetry methods.
    Verify: SignalingClient has latency StateFlow.
    Verify: SignalingClient constructor takes NetworkMonitor parameter.
    Verify: NetworkMonitor observation in init block.
  </verify>
  <done>
    SignalingClient auto-reconnects with exponential backoff (1s-30s cap), gives up after 5 minutes, resets on network restore, measures PING latency, and supports manualRetry() for the Retry button. ConnectionState transitions through RECONNECTING before FAILED.
  </done>
</task>

</tasks>

<verification>
1. `cd android && ./gradlew compileDebugKotlin` compiles without errors
2. ConnectionState enum has 5 values: DISCONNECTED, CONNECTING, CONNECTED, RECONNECTING, FAILED
3. NetworkMonitor exposes isNetworkAvailable and networkType StateFlows
4. SignalingClient has exponential backoff with 30s cap
5. SignalingClient gives up after 5 minutes (maxReconnectDurationMs)
6. SignalingClient resets backoff on network restore (NetworkMonitor observation)
7. SignalingClient exposes latency StateFlow from heartbeat measurement
8. manualRetry() method exists for FAILED state recovery
</verification>

<success_criteria>
Network resilience foundation compiles and provides: NetworkMonitor for connectivity detection, enhanced ConnectionState with RECONNECTING, SignalingClient with exponential backoff reconnection (1s-30s cap, 5-minute max), network-aware retry reset, and latency measurement via heartbeat PING.
</success_criteria>

<output>
After completion, create `.planning/phases/10-network-resilience-ux-polish/10-01-SUMMARY.md`
</output>
