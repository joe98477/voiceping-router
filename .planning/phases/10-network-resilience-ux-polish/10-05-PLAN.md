---
phase: 10-network-resilience-ux-polish
plan: 05
type: execute
wave: 2
depends_on: ["10-01", "10-02"]
files_modified:
  - android/app/src/main/java/com/voiceping/android/presentation/settings/SettingsScreen.kt
  - android/app/src/main/java/com/voiceping/android/presentation/settings/SettingsViewModel.kt
  - android/app/src/main/java/com/voiceping/android/presentation/shell/ProfileDrawer.kt
  - android/app/src/main/java/com/voiceping/android/presentation/navigation/NavGraph.kt
  - android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListScreen.kt
  - android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListViewModel.kt
  - android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
  - android/app/src/main/java/com/voiceping/android/presentation/events/EventPickerViewModel.kt
autonomous: true

must_haves:
  truths:
    - "Dedicated Settings screen accessible from ProfileDrawer with all settings consolidated"
    - "Settings screen organized in groups: PTT, Audio, Scan Mode, Hardware, Advanced"
    - "ProfileDrawer simplified to user info, Switch Event, Settings link, and Logout only"
    - "Settings screen uses Material3 ListItem patterns with Switch/RadioButton/Slider"
    - "EventPickerViewModel uses cache-first loading (shows cached events when offline)"
    - "ChannelListViewModel uses cache-first loading for channels"
    - "ChannelRepository starts NetworkMonitor and wires reconnection channel rejoin"
    - "Extended disconnection (30+s) auto-rejoins all previously monitored channels"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/presentation/settings/SettingsScreen.kt"
      provides: "Consolidated Settings screen with grouped preference-style UI"
      contains: "SettingsScreen"
    - path: "android/app/src/main/java/com/voiceping/android/presentation/settings/SettingsViewModel.kt"
      provides: "SettingsViewModel exposing all settings as StateFlows"
      contains: "@HiltViewModel"
    - path: "android/app/src/main/java/com/voiceping/android/presentation/shell/ProfileDrawer.kt"
      provides: "Simplified ProfileDrawer with user info, event switch, settings link, logout"
      contains: "ProfileDrawer"
  key_links:
    - from: "NavGraph"
      to: "SettingsScreen"
      via: "Navigation route for settings"
      pattern: "Routes\\.SETTINGS"
    - from: "ProfileDrawer"
      to: "SettingsScreen"
      via: "Settings menu item navigates to SettingsScreen"
      pattern: "onSettings"
    - from: "ChannelRepository"
      to: "NetworkMonitor"
      via: "Repository starts monitor and triggers reconnection channel rejoin"
      pattern: "networkMonitor"
---

<objective>
Consolidated Settings screen with all preferences, simplified ProfileDrawer, cache-first loading for events/channels, and final integration wiring (NetworkMonitor lifecycle, channel rejoin on reconnection).

Purpose: UX-04 (settings screen for scan mode, button mapping, audio output, auto-start). Also completes NET-03 integration by using cache-first EventRepository in ViewModels, and wires the reconnection channel rejoin behavior.

Output: SettingsScreen.kt, SettingsViewModel.kt, simplified ProfileDrawer, updated NavGraph, cache-first ViewModel loading, NetworkMonitor lifecycle management, reconnection channel rejoin.
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-network-resilience-ux-polish/10-CONTEXT.md
@.planning/phases/10-network-resilience-ux-polish/10-RESEARCH.md
@.planning/phases/10-network-resilience-ux-polish/10-01-SUMMARY.md
@.planning/phases/10-network-resilience-ux-polish/10-02-SUMMARY.md
@.planning/phases/10-network-resilience-ux-polish/10-03-SUMMARY.md
@.planning/phases/10-network-resilience-ux-polish/10-04-SUMMARY.md
@android/app/src/main/java/com/voiceping/android/presentation/shell/ProfileDrawer.kt
@android/app/src/main/java/com/voiceping/android/presentation/navigation/NavGraph.kt
@android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListViewModel.kt
@android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListScreen.kt
@android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
@android/app/src/main/java/com/voiceping/android/data/repository/EventRepository.kt
@android/app/src/main/java/com/voiceping/android/presentation/events/EventPickerViewModel.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SettingsScreen and SettingsViewModel, simplify ProfileDrawer</name>
  <files>
    android/app/src/main/java/com/voiceping/android/presentation/settings/SettingsScreen.kt
    android/app/src/main/java/com/voiceping/android/presentation/settings/SettingsViewModel.kt
    android/app/src/main/java/com/voiceping/android/presentation/shell/ProfileDrawer.kt
    android/app/src/main/java/com/voiceping/android/presentation/navigation/NavGraph.kt
  </files>
  <action>
    1. Create SettingsViewModel in presentation/settings/SettingsViewModel.kt:
       @HiltViewModel class with @Inject constructor.
       Inject SettingsRepository, AudioRouter.

       Expose all settings as StateFlows (move from ChannelListViewModel to here):
       - pttMode, audioRoute, toggleMaxDuration
       - pttStartToneEnabled, rogerBeepEnabled, rxSquelchEnabled
       - scanModeEnabled, scanReturnDelay, pttTargetMode, audioMixMode
       - volumeKeyPttConfig, bluetoothPttEnabled, bluetoothPttButtonKeycode, bootAutoStartEnabled

       All use settingsRepository.getXxx().stateIn(viewModelScope, ...) pattern.

       Setter methods for each setting (same as currently in ChannelListViewModel):
       - setPttMode, setAudioRoute, setToggleMaxDuration, etc.
       - setAudioRoute also applies via AudioRouter (same logic as ChannelListViewModel).

       Note: ChannelListViewModel will KEEP its read-only StateFlows for settings it needs to observe (pttMode, audioRoute, scanModeEnabled, pttTargetMode, etc.) since those drive scan mode and PTT behavior. SettingsViewModel owns the write operations.

    2. Create SettingsScreen in presentation/settings/SettingsScreen.kt:
       @Composable function accepting SettingsViewModel (via hiltViewModel()) and onNavigateBack callback.

       Layout:
       - Scaffold with TopAppBar: title "Settings", leading back arrow icon button.
       - Content: LazyColumn with grouped sections using Material3 ListItem patterns.

       **Sections (organized by group):**

       **PTT Settings:**
       - PTT Mode: RadioButton group (Press and Hold / Toggle) using ListItem
       - Toggle Max Duration: Slider (30-120s, shown when Toggle mode selected) with ListItem

       **Audio:**
       - Audio Output: RadioButton group (Speaker / Earpiece) using ListItem
       - PTT Start Tone: ListItem with Switch
       - Roger Beep: ListItem with Switch
       - RX Squelch: ListItem with Switch

       **Scan Mode:**
       - Auto-switch channels: ListItem with Switch + subtitle "Bottom bar follows active speaker"
       - PTT Target (shown when scan enabled): RadioButton group (Always primary / Displayed channel)
       - Return Delay (shown when scan enabled): Slider (2-5s)
       - Audio Mix: RadioButton group (Equal volume / Primary priority with subtitle)

       **Hardware:**
       - Volume Key PTT: RadioButton group (Disabled / Volume Up / Volume Down / Both Keys) with helper text
       - Bluetooth PTT: ListItem with Switch
       - Bluetooth PTT Button (shown when BT enabled): ListItem with button name + "Detect Button" text button.
         Note: Button detection requires navigating to ButtonDetectionScreen or showing dialog. For now, include a "Detect Button" TextButton that triggers navigation callback.
       - Start on boot: ListItem with Switch + subtitle "Auto-start when device powers on" + API 35 note

       Each section:
       - Section header: Text with titleSmall + primary color, 16dp top padding
       - HorizontalDivider between sections
       - ListItem for each setting with appropriate trailing content (Switch, RadioButton)

       Use same composable patterns as current ProfileDrawer but in proper full-screen layout with LazyColumn.

    3. Simplify ProfileDrawer.kt:
       Remove ALL inline settings (PTT, audio, scan mode, hardware buttons).
       Keep ONLY:
       - Close button
       - User info (name, email)
       - HorizontalDivider
       - Menu items: Switch Event, Settings, Logout
       - App version

       Dramatically reduce parameter list:
       ```kotlin
       @Composable
       fun ProfileDrawer(
           isOpen: Boolean,
           onDismiss: () -> Unit,
           userName: String,
           userEmail: String,
           appVersion: String = "1.0.0",
           onSwitchEvent: () -> Unit = {},
           onSettings: () -> Unit = {},
           onLogout: () -> Unit = {},
           content: @Composable () -> Unit
       )
       ```

       This is a significant simplification from the current ~90-parameter version.

    4. Update NavGraph.kt:
       - Add Routes.SETTINGS = "settings" constant.
       - Add composable(Routes.SETTINGS) entry with SettingsScreen.
       - SettingsScreen receives onNavigateBack callback that pops back.
       - Wire onSettings from ChannelListScreen to navigate to Routes.SETTINGS.
       - ButtonDetectionScreen already exists at its own route, ensure SettingsScreen can navigate to it.

    5. Update ChannelListScreen.kt:
       - Remove all settings-related parameter passing to ProfileDrawer (it no longer needs them).
       - ProfileDrawer now just gets: isOpen, onDismiss, userName, userEmail, onSwitchEvent, onSettings, onLogout, content.
       - onSettings navigates to Routes.SETTINGS.
       - Remove settings-related state collections that were only used for ProfileDrawer.
       - Keep settings state collections that are used by the screen itself (pttMode for PttButton, etc.).
  </action>
  <verify>
    cd android && ./gradlew compileDebugKotlin 2>&1 | tail -5
    Verify: SettingsScreen exists with grouped settings sections
    Verify: SettingsViewModel exposes all settings
    Verify: ProfileDrawer simplified (no inline settings)
    Verify: NavGraph has Routes.SETTINGS
    Verify: ChannelListScreen navigates to settings
  </verify>
  <done>
    Dedicated SettingsScreen with all preferences organized in groups (PTT, Audio, Scan Mode, Hardware). ProfileDrawer simplified to user info + menu links. Navigation wired through NavGraph.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire cache-first loading and reconnection channel rejoin</name>
  <files>
    android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListViewModel.kt
    android/app/src/main/java/com/voiceping/android/presentation/events/EventPickerViewModel.kt
    android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
  </files>
  <action>
    1. Update EventPickerViewModel to use cache-first loading:
       - Change loadEvents() to call eventRepository.getEventsWithCache() instead of eventRepository.getEvents().
       - This ensures EventPickerScreen shows cached events on cold start with no network.

    2. Update ChannelListViewModel.loadChannels() to use cache-first loading:
       - Change to call eventRepository.getChannelsWithCache(eventId) instead of eventRepository.getChannelsForEvent(eventId).
       - This ensures ChannelListScreen shows cached channels when offline.

    3. Wire NetworkMonitor lifecycle and reconnection channel rejoin in ChannelRepository:
       Per locked decisions:
       - Extended disconnection (30+s): Auto-rejoin ALL previously monitored channels when connection restores
       - NetworkMonitor lifecycle management

       Add NetworkMonitor to ChannelRepository constructor (if not already injected).

       In ChannelRepository init block, add connection state observer:
       ```kotlin
       // Track disconnection timing for channel rejoin decision
       private var disconnectedAt: Long? = null

       init {
           // ... existing init code ...

           // Start NetworkMonitor
           networkMonitor.start()

           // Observe connection state for channel rejoin on reconnection
           scope.launch {
               var previousState = signalingClient.connectionState.value
               signalingClient.connectionState.collect { newState ->
                   if (previousState != ConnectionState.CONNECTED && newState == ConnectionState.CONNECTED) {
                       // Just reconnected - check if we need to rejoin channels
                       val disconnectTime = disconnectedAt
                       if (disconnectTime != null) {
                           val disconnectDuration = System.currentTimeMillis() - disconnectTime
                           if (disconnectDuration > 30_000) {
                               // Extended disconnection (30+s): rejoin all monitored channels
                               Log.d(TAG, "Extended disconnect (${disconnectDuration}ms), rejoining all channels")
                               rejoinAllMonitoredChannels()
                           }
                       }
                       disconnectedAt = null
                   } else if (previousState == ConnectionState.CONNECTED && newState != ConnectionState.CONNECTED) {
                       // Just disconnected - record time
                       disconnectedAt = System.currentTimeMillis()
                   }
                   previousState = newState
               }
           }
       }
       ```

       Add rejoinAllMonitoredChannels() method:
       ```kotlin
       private suspend fun rejoinAllMonitoredChannels() {
           val currentChannels = monitoredChannels.value
           if (currentChannels.isEmpty()) {
               Log.d(TAG, "No channels to rejoin")
               return
           }

           Log.d(TAG, "Rejoining ${currentChannels.size} channels after reconnection")
           for ((channelId, state) in currentChannels) {
               try {
                   // Re-send JOIN_CHANNEL to server
                   signalingClient.request(
                       SignalingType.JOIN_CHANNEL,
                       mapOf("channelId" to channelId)
                   )
                   Log.d(TAG, "Rejoined channel: ${state.channelName}")
               } catch (e: Exception) {
                   Log.e(TAG, "Failed to rejoin channel ${state.channelName}", e)
               }
           }
       }
       ```

    4. Remove settings setter methods from ChannelListViewModel that were moved to SettingsViewModel:
       Remove: setPttMode, setAudioRoute, setPttStartToneEnabled, setRogerBeepEnabled, setRxSquelchEnabled, setToggleMaxDuration, setScanModeEnabled, setScanReturnDelay, setPttTargetMode, setAudioMixMode, setVolumeKeyPttConfig, setBluetoothPttEnabled, setBluetoothPttButtonKeycode, setBootAutoStartEnabled.

       Keep: Read-only StateFlows that the ChannelListScreen still needs for display/behavior (pttMode for PttButton, scanModeEnabled for scan logic, pttTargetMode for PTT targeting, etc.).

       Keep: Action methods that aren't settings (toggleChannel, onPttPressed, onPttReleased, muteChannel, etc.).

       Remove: startButtonDetection, confirmDetectedButton, stopButtonDetection (move to SettingsViewModel or keep in ChannelListViewModel if ButtonDetectionScreen is accessed from there).

    5. Clean up ChannelRepository.disconnectAll() to also stop NetworkMonitor:
       ```kotlin
       fun disconnectAll() {
           // ... existing cleanup ...
           networkMonitor.stop()
       }
       ```
  </action>
  <verify>
    cd android && ./gradlew compileDebugKotlin 2>&1 | tail -5
    Verify: EventPickerViewModel calls getEventsWithCache()
    Verify: ChannelListViewModel calls getChannelsWithCache()
    Verify: ChannelRepository observes connectionState and rejoins channels after 30+s disconnect
    Verify: ChannelRepository starts/stops NetworkMonitor
    Verify: Settings setters removed from ChannelListViewModel
  </verify>
  <done>
    Cache-first loading in EventPickerViewModel and ChannelListViewModel. ChannelRepository manages NetworkMonitor lifecycle and auto-rejoins all monitored channels after extended disconnection (30+s). Settings setter methods moved from ChannelListViewModel to SettingsViewModel.
  </done>
</task>

</tasks>

<verification>
1. `cd android && ./gradlew compileDebugKotlin` compiles without errors
2. SettingsScreen shows all settings grouped: PTT, Audio, Scan Mode, Hardware
3. ProfileDrawer has only user info + menu items (no inline settings)
4. NavGraph routes to SettingsScreen
5. EventPickerViewModel uses getEventsWithCache() for offline support
6. ChannelListViewModel uses getChannelsWithCache() for offline support
7. ChannelRepository starts NetworkMonitor and observes connection for channel rejoin
8. Extended disconnection (30+s) triggers rejoinAllMonitoredChannels()
9. ChannelListViewModel no longer has settings setter methods
</verification>

<success_criteria>
Consolidated Settings screen accessible from ProfileDrawer with all preferences organized in groups. ProfileDrawer dramatically simplified. Cache-first loading ensures offline support in both EventPicker and ChannelList. ChannelRepository manages NetworkMonitor lifecycle and auto-rejoins channels after extended disconnection. Phase 10 complete: production-ready app with cellular network resilience and polished UX.
</success_criteria>

<output>
After completion, create `.planning/phases/10-network-resilience-ux-polish/10-05-SUMMARY.md`
</output>
