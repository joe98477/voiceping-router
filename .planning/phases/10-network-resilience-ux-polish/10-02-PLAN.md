---
phase: 10-network-resilience-ux-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - android/app/build.gradle.kts
  - android/app/src/main/java/com/voiceping/android/data/database/VoicePingDatabase.kt
  - android/app/src/main/java/com/voiceping/android/data/database/entities/EventEntity.kt
  - android/app/src/main/java/com/voiceping/android/data/database/entities/ChannelEntity.kt
  - android/app/src/main/java/com/voiceping/android/data/database/entities/TeamEntity.kt
  - android/app/src/main/java/com/voiceping/android/data/database/dao/EventDao.kt
  - android/app/src/main/java/com/voiceping/android/data/database/dao/ChannelDao.kt
  - android/app/src/main/java/com/voiceping/android/di/AppModule.kt
  - android/app/src/main/java/com/voiceping/android/data/repository/EventRepository.kt
autonomous: true

must_haves:
  truths:
    - "App shows cached channel list on cold start with no network (last-known state)"
    - "Channel list loads from Room database and refreshes from network when available"
    - "Event, channel, and team data persists across app restarts on disk"
    - "Each cached entity has lastUpdated timestamp for staleness detection"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/data/database/VoicePingDatabase.kt"
      provides: "Room database with Event, Team, Channel entities"
      contains: "@Database"
    - path: "android/app/src/main/java/com/voiceping/android/data/database/entities/ChannelEntity.kt"
      provides: "Channel entity with lastUpdated timestamp"
      contains: "@Entity"
    - path: "android/app/src/main/java/com/voiceping/android/data/database/dao/ChannelDao.kt"
      provides: "Channel DAO with Flow-based queries"
      contains: "@Dao"
    - path: "android/app/src/main/java/com/voiceping/android/data/repository/EventRepository.kt"
      provides: "EventRepository enhanced with Room cache-first loading"
      contains: "channelDao"
  key_links:
    - from: "EventRepository"
      to: "ChannelDao"
      via: "Room queries and inserts for offline caching"
      pattern: "channelDao\\."
    - from: "VoicePingDatabase"
      to: "AppModule"
      via: "Hilt provides Room database singleton"
      pattern: "Room\\.databaseBuilder"
---

<objective>
Room database for offline caching of event, team, and channel data. EventRepository enhanced with cache-first loading pattern: UI always observes database, network updates write to database.

Purpose: NET-03 (offline state with cached channel list) requires persistent data that survives app restarts. When the app launches with no network, users see the last-known channel list from the Room database instead of an error screen.

Output: Room database (VoicePingDatabase), entities (EventEntity, TeamEntity, ChannelEntity), DAOs (EventDao, ChannelDao), enhanced EventRepository with cache-first pattern, Hilt bindings.
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-network-resilience-ux-polish/10-CONTEXT.md
@.planning/phases/10-network-resilience-ux-polish/10-RESEARCH.md
@android/app/build.gradle.kts
@android/app/src/main/java/com/voiceping/android/data/repository/EventRepository.kt
@android/app/src/main/java/com/voiceping/android/di/AppModule.kt
@android/app/src/main/java/com/voiceping/android/domain/model/Channel.kt
@android/app/src/main/java/com/voiceping/android/domain/model/Event.kt
@android/app/src/main/java/com/voiceping/android/domain/model/Team.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Room dependency, create entities and DAOs</name>
  <files>
    android/app/build.gradle.kts
    android/app/src/main/java/com/voiceping/android/data/database/entities/EventEntity.kt
    android/app/src/main/java/com/voiceping/android/data/database/entities/ChannelEntity.kt
    android/app/src/main/java/com/voiceping/android/data/database/entities/TeamEntity.kt
    android/app/src/main/java/com/voiceping/android/data/database/dao/EventDao.kt
    android/app/src/main/java/com/voiceping/android/data/database/dao/ChannelDao.kt
  </files>
  <action>
    1. Add Room dependencies to android/app/build.gradle.kts:
       ```kotlin
       // Room (offline caching)
       implementation("androidx.room:room-runtime:2.6.1")
       implementation("androidx.room:room-ktx:2.6.1")
       ksp("androidx.room:room-compiler:2.6.1")
       ```
       Add under the DataStore dependency section. KSP plugin is already applied.

    2. Create EventEntity in data/database/entities/EventEntity.kt:
       ```kotlin
       @Entity(tableName = "events")
       data class EventEntity(
           @PrimaryKey val id: String,
           val name: String,
           val description: String = "",
           val lastUpdated: Long = System.currentTimeMillis()
       )
       ```
       Add toDomain() extension: maps to domain Event model.
       Add companion fromDomain(event: Event) factory.

    3. Create TeamEntity in data/database/entities/TeamEntity.kt:
       ```kotlin
       @Entity(tableName = "teams")
       data class TeamEntity(
           @PrimaryKey val id: String,
           val name: String,
           val eventId: String,
           val lastUpdated: Long = System.currentTimeMillis()
       )
       ```
       Add toDomain() and fromDomain() methods.

    4. Create ChannelEntity in data/database/entities/ChannelEntity.kt:
       ```kotlin
       @Entity(tableName = "channels")
       data class ChannelEntity(
           @PrimaryKey val id: String,
           val name: String,
           val teamId: String,
           val teamName: String,  // Denormalized for simpler queries
           val eventId: String,
           val lastUpdated: Long = System.currentTimeMillis()
       )
       ```
       Add toDomain() mapping to domain Channel model.
       Add companion fromDomain(channel: Channel, eventId: String) factory.

    5. Create EventDao in data/database/dao/EventDao.kt:
       ```kotlin
       @Dao
       interface EventDao {
           @Query("SELECT * FROM events ORDER BY name")
           fun getAllEventsFlow(): Flow<List<EventEntity>>

           @Query("SELECT * FROM events ORDER BY name")
           suspend fun getAllEvents(): List<EventEntity>

           @Insert(onConflict = OnConflictStrategy.REPLACE)
           suspend fun insertAll(events: List<EventEntity>)

           @Query("DELETE FROM events")
           suspend fun deleteAll()
       }
       ```

    6. Create ChannelDao in data/database/dao/ChannelDao.kt:
       ```kotlin
       @Dao
       interface ChannelDao {
           @Query("SELECT * FROM channels WHERE eventId = :eventId ORDER BY teamName, name")
           fun getChannelsFlow(eventId: String): Flow<List<ChannelEntity>>

           @Query("SELECT * FROM channels WHERE eventId = :eventId ORDER BY teamName, name")
           suspend fun getChannels(eventId: String): List<ChannelEntity>

           @Insert(onConflict = OnConflictStrategy.REPLACE)
           suspend fun insertAll(channels: List<ChannelEntity>)

           @Query("DELETE FROM channels WHERE eventId = :eventId")
           suspend fun deleteByEvent(eventId: String)
       }
       ```
  </action>
  <verify>
    cd android && ./gradlew compileDebugKotlin 2>&1 | tail -5
    Verify: Room dependencies in build.gradle.kts
    Verify: All 3 entity files and 2 DAO files exist
  </verify>
  <done>
    Room dependencies added. Three entities (Event, Team, Channel) with @Entity annotations and lastUpdated timestamps. Two DAOs (EventDao, ChannelDao) with suspend and Flow-based queries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create VoicePingDatabase and wire Hilt providers</name>
  <files>
    android/app/src/main/java/com/voiceping/android/data/database/VoicePingDatabase.kt
    android/app/src/main/java/com/voiceping/android/di/AppModule.kt
  </files>
  <action>
    1. Create VoicePingDatabase in data/database/VoicePingDatabase.kt:
       ```kotlin
       @Database(
           entities = [EventEntity::class, TeamEntity::class, ChannelEntity::class],
           version = 1,
           exportSchema = false
       )
       abstract class VoicePingDatabase : RoomDatabase() {
           abstract fun eventDao(): EventDao
           abstract fun channelDao(): ChannelDao
       }
       ```

    2. Add Room database and DAO bindings to di/AppModule.kt:
       Add @Provides @Singleton methods:
       - provideDatabase(@ApplicationContext context): VoicePingDatabase
         Uses Room.databaseBuilder(context, VoicePingDatabase::class.java, "voiceping_db")
         .fallbackToDestructiveMigration() for v1 (no migration needed for first version)
         .build()
       - provideEventDao(database): EventDao = database.eventDao()
       - provideChannelDao(database): ChannelDao = database.channelDao()
  </action>
  <verify>
    cd android && ./gradlew compileDebugKotlin 2>&1 | tail -5
    Verify: VoicePingDatabase exists with @Database annotation
    Verify: AppModule has Room providers (provideDatabase, provideEventDao, provideChannelDao)
  </verify>
  <done>
    VoicePingDatabase created as Room @Database. Hilt AppModule provides database singleton and DAOs via @Provides @Singleton methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance EventRepository with cache-first loading pattern</name>
  <files>
    android/app/src/main/java/com/voiceping/android/data/repository/EventRepository.kt
  </files>
  <action>
    Enhance existing EventRepository to implement cache-first loading: UI observes database, network updates write to database. When network is unavailable, cached data is shown.

    1. Add DAO constructor parameters:
       ```kotlin
       class EventRepository @Inject constructor(
           private val eventApi: EventApi,
           private val tokenManager: TokenManager,
           private val eventDao: EventDao,
           private val channelDao: ChannelDao
       )
       ```

    2. Add getEventsWithCache() method:
       ```kotlin
       suspend fun getEventsWithCache(): Result<List<Event>> {
           return try {
               // Try network first
               val networkResult = getEvents()
               if (networkResult.isSuccess) {
                   // Cache to database
                   val events = networkResult.getOrThrow()
                   withContext(Dispatchers.IO) {
                       eventDao.insertAll(events.map { EventEntity.fromDomain(it) })
                   }
                   networkResult
               } else {
                   // Fall back to cache
                   getCachedEvents()
               }
           } catch (e: Exception) {
               // Network error, fall back to cache
               val cached = getCachedEvents()
               if (cached.isSuccess && cached.getOrThrow().isNotEmpty()) {
                   cached
               } else {
                   Result.failure(e)
               }
           }
       }
       ```

    3. Add getCachedEvents() method:
       ```kotlin
       private suspend fun getCachedEvents(): Result<List<Event>> {
           return try {
               val cached = withContext(Dispatchers.IO) {
                   eventDao.getAllEvents()
               }
               Result.success(cached.map { it.toDomain() })
           } catch (e: Exception) {
               Result.failure(e)
           }
       }
       ```

    4. Add getChannelsWithCache(eventId) method:
       ```kotlin
       suspend fun getChannelsWithCache(eventId: String): Result<List<Channel>> {
           return try {
               // Try network first
               val networkResult = getChannelsForEvent(eventId)
               if (networkResult.isSuccess) {
                   // Cache to database
                   val channels = networkResult.getOrThrow()
                   withContext(Dispatchers.IO) {
                       channelDao.deleteByEvent(eventId) // Clear old, replace with fresh
                       channelDao.insertAll(channels.map { ChannelEntity.fromDomain(it, eventId) })
                   }
                   networkResult
               } else {
                   getCachedChannels(eventId)
               }
           } catch (e: Exception) {
               val cached = getCachedChannels(eventId)
               if (cached.isSuccess && cached.getOrThrow().isNotEmpty()) {
                   cached
               } else {
                   Result.failure(e)
               }
           }
       }
       ```

    5. Add getCachedChannels(eventId) method:
       ```kotlin
       private suspend fun getCachedChannels(eventId: String): Result<List<Channel>> {
           return try {
               val cached = withContext(Dispatchers.IO) {
                   channelDao.getChannels(eventId)
               }
               Result.success(cached.map { it.toDomain() })
           } catch (e: Exception) {
               Result.failure(e)
           }
       }
       ```

    6. Add Flow-based observation method for reactive UI:
       ```kotlin
       fun observeChannels(eventId: String): Flow<List<Channel>> {
           return channelDao.getChannelsFlow(eventId)
               .map { entities -> entities.map { it.toDomain() } }
       }
       ```

    7. Keep existing getEvents() and getChannelsForEvent() methods unchanged (they are pure network calls). The new *WithCache methods wrap them.

    Import kotlinx.coroutines.Dispatchers and kotlinx.coroutines.withContext.
  </action>
  <verify>
    cd android && ./gradlew compileDebugKotlin 2>&1 | tail -5
    Verify: EventRepository has getEventsWithCache() and getChannelsWithCache() methods
    Verify: EventRepository has EventDao and ChannelDao parameters
    Verify: Cache-first pattern: try network, fall back to database on failure
  </verify>
  <done>
    EventRepository loads data cache-first: tries network, writes results to Room database on success, falls back to cached data on network failure. Cold start with no network shows last-known channel list from Room database.
  </done>
</task>

</tasks>

<verification>
1. `cd android && ./gradlew compileDebugKotlin` compiles without errors
2. Room dependencies present in build.gradle.kts
3. Three entities exist with @Entity annotations and lastUpdated timestamps
4. DAOs provide both suspend and Flow-based query methods
5. VoicePingDatabase is @Database with version 1
6. AppModule provides database singleton and DAOs
7. EventRepository has getEventsWithCache() and getChannelsWithCache() methods
8. Cache-first pattern: network -> cache on success -> fallback to cache on failure
</verification>

<success_criteria>
Room database created with Event, Team, Channel entities. EventRepository enhanced with cache-first loading pattern. App can show last-known channel list from disk cache when network is unavailable, including on cold start.
</success_criteria>

<output>
After completion, create `.planning/phases/10-network-resilience-ux-polish/10-02-SUMMARY.md`
</output>
