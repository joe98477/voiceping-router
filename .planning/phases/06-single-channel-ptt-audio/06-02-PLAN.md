---
phase: 06-single-channel-ptt-audio
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - android/app/src/main/AndroidManifest.xml
  - android/app/src/main/java/com/voiceping/android/data/audio/AudioCaptureManager.kt
  - android/app/src/main/java/com/voiceping/android/data/audio/AudioRouter.kt
  - android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
  - android/app/src/main/java/com/voiceping/android/data/ptt/PttManager.kt
  - android/app/src/main/java/com/voiceping/android/service/AudioCaptureService.kt
autonomous: true

must_haves:
  truths:
    - "PttManager transitions through Idle -> Requesting -> Transmitting -> Idle on successful PTT"
    - "PttManager transitions through Idle -> Requesting -> Denied -> Idle when channel is busy"
    - "AudioCaptureManager captures mic audio at 48kHz mono with VOICE_COMMUNICATION source"
    - "MediasoupClient can create send transport and produce audio to server"
    - "AudioRouter supports speaker, earpiece, and Bluetooth SCO routing with saved route fallback"
    - "Foreground service with microphone type enables background audio capture"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/data/ptt/PttManager.kt"
      provides: "PTT state machine orchestrating signaling, audio capture, mediasoup producer"
      contains: "class PttManager"
    - path: "android/app/src/main/java/com/voiceping/android/data/audio/AudioCaptureManager.kt"
      provides: "AudioRecord-based mic capture with real-time thread priority"
      contains: "AudioRecord"
    - path: "android/app/src/main/java/com/voiceping/android/service/AudioCaptureService.kt"
      provides: "Foreground service with microphone type for audio capture"
      contains: "foregroundServiceType"
    - path: "android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt"
      provides: "Send transport and producer for audio transmission"
      contains: "createSendTransport"
    - path: "android/app/src/main/java/com/voiceping/android/data/audio/AudioRouter.kt"
      provides: "Enhanced audio routing with Bluetooth SCO and saved route"
      contains: "AudioRoute"
  key_links:
    - from: "android/app/src/main/java/com/voiceping/android/data/ptt/PttManager.kt"
      to: "android/app/src/main/java/com/voiceping/android/data/network/SignalingClient.kt"
      via: "Sends PTT_START request, receives grant/deny response"
      pattern: "SignalingType\\.PTT_START"
    - from: "android/app/src/main/java/com/voiceping/android/data/ptt/PttManager.kt"
      to: "android/app/src/main/java/com/voiceping/android/data/audio/AudioCaptureManager.kt"
      via: "Starts/stops mic capture on PTT grant/release"
      pattern: "audioCaptureManager\\.start|stop"
    - from: "android/app/src/main/java/com/voiceping/android/data/audio/AudioCaptureManager.kt"
      to: "android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt"
      via: "Sends captured PCM buffers to producer"
      pattern: "mediasoupClient.*send|produce"
---

<objective>
Build the PTT core engine: state machine (PttManager), microphone capture (AudioCaptureManager), send transport/producer (MediasoupClient enhancement), enhanced audio routing (AudioRouter with Bluetooth), and foreground service for mic access.

Purpose: This is the backend engine that drives PTT transmission. When user presses PTT button, PttManager orchestrates the flow: request server -> start foreground service -> capture mic audio -> send via mediasoup producer. This plan creates the non-UI machinery.

Output: PttManager (state machine), AudioCaptureManager (mic capture), AudioCaptureService (foreground service), enhanced MediasoupClient (send transport), enhanced AudioRouter (Bluetooth support).
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-single-channel-ptt-audio/06-CONTEXT.md
@.planning/phases/06-single-channel-ptt-audio/06-RESEARCH.md
@.planning/phases/05-android-setup-webrtc/05-03-SUMMARY.md
@.planning/phases/05-android-setup-webrtc/05-05-SUMMARY.md
@android/app/src/main/java/com/voiceping/android/data/network/SignalingClient.kt
@android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
@android/app/src/main/java/com/voiceping/android/data/audio/AudioRouter.kt
@android/app/src/main/java/com/voiceping/android/data/network/dto/SignalingMessage.kt
@android/app/src/main/AndroidManifest.xml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AudioCaptureManager, AudioCaptureService, and enhance AudioRouter</name>
  <files>
    android/app/src/main/java/com/voiceping/android/data/audio/AudioCaptureManager.kt
    android/app/src/main/java/com/voiceping/android/service/AudioCaptureService.kt
    android/app/src/main/java/com/voiceping/android/data/audio/AudioRouter.kt
    android/app/src/main/AndroidManifest.xml
  </files>
  <action>
    1. Create AudioCaptureManager.kt in data/audio/:
       - @Singleton @Inject constructor (no direct dependency on MediasoupClient -- uses callback pattern)
       - Private fields: audioRecord (AudioRecord?), captureThread (Thread?), isCapturing (AtomicBoolean)
       - Constants: sampleRate=48000, channelConfig=CHANNEL_IN_MONO, audioFormat=ENCODING_PCM_16BIT
       - onAudioData: ((ByteArray, Int) -> Unit)? callback -- set by PttManager to route audio data to mediasoup
       - startCapture():
         a. Calculate minBufferSize via AudioRecord.getMinBufferSize(), set bufferSize = minBufferSize * 2 (research: 2x for stability)
         b. Create AudioRecord with MediaRecorder.AudioSource.VOICE_COMMUNICATION (enables built-in AEC/AGC/NS)
         c. Check audioRecord.state == STATE_INITIALIZED, throw if not
         d. Enable AcousticEchoCanceler if available: AcousticEchoCanceler.create(audioRecord.audioSessionId)?.enabled = true
         e. audioRecord.startRecording()
         f. Launch captureThread with Thread { Process.setThreadPriority(THREAD_PRIORITY_URGENT_AUDIO); capture loop }
         g. Capture loop: while isCapturing, audioRecord.read(buffer, 0, bufferSize), if bytesRead > 0 call onAudioData?.invoke(buffer.copyOf(bytesRead), bytesRead)
         h. Use buffer.copyOf(bytesRead) to avoid overwriting buffer before consumer processes it
       - stopCapture():
         a. isCapturing.set(false)
         b. captureThread?.join(1000) then null
         c. audioRecord?.stop(), audioRecord?.release(), audioRecord = null
         d. Log cleanup completion
       - Always release in finally blocks to prevent memory leaks (Pitfall 5 from research)

    2. Create AudioCaptureService.kt in service/ package:
       - @AndroidEntryPoint class extending Service
       - Actions: ACTION_START = "com.voiceping.START_CAPTURE", ACTION_STOP = "com.voiceping.STOP_CAPTURE"
       - onStartCommand: when ACTION_START -> startForeground(notificationId, createNotification()), when ACTION_STOP -> stopForeground(STOP_FOREGROUND_REMOVE) + stopSelf()
       - createNotification(): Create NotificationChannel "audio_capture" with IMPORTANCE_LOW, return NotificationCompat.Builder with "VoicePing PTT Active" title, "Transmitting audio..." content, setOngoing(true), small icon R.drawable.ic_mic (use existing icon or ic_launcher as fallback)
       - onBind returns null
       - Note: This service is started/stopped by PttManager, not by the user directly

    3. Update AndroidManifest.xml:
       - Add permissions: FOREGROUND_SERVICE, FOREGROUND_SERVICE_MICROPHONE, BLUETOOTH_CONNECT (for API 31+), VIBRATE
       - Add <service> element for AudioCaptureService with android:foregroundServiceType="microphone", android:exported="false"

    4. Enhance AudioRouter.kt (MODIFY existing file):
       - Import AudioRoute enum from domain/model/ (will be created by Plan 01 -- if not yet available, define locally and note for integration)
       - Add fields: private var currentRoute = AudioRoute.SPEAKER, private var savedRouteBeforeBluetooth = AudioRoute.SPEAKER
       - Add setAudioRoute(route: AudioRoute) method that dispatches to setSpeakerMode/setEarpieceMode/setBluetoothMode based on route enum
       - Add setBluetoothMode(): audioManager.mode = MODE_IN_COMMUNICATION, startBluetoothSco(), isBluetoothScoOn = true
       - Modify setSpeakerMode() and setEarpieceMode() to also call stopBluetoothSco() and isBluetoothScoOn = false
       - Add getCurrentRoute(): AudioRoute getter
       - When setAudioRoute called with non-BLUETOOTH route, save to savedRouteBeforeBluetooth (fallback on BT disconnect per user decision: "falls back to previous output setting, not always speaker")
       - Keep existing requestAudioFocus(), releaseAudioFocus(), resetAudioMode() unchanged
  </action>
  <verify>
    Build compiles: cd android && ./gradlew assembleDebug (AudioCaptureManager, AudioCaptureService, enhanced AudioRouter compile, manifest validates)
  </verify>
  <done>
    AudioCaptureManager captures mic audio at 48kHz mono with VOICE_COMMUNICATION source, 2x buffer, THREAD_PRIORITY_URGENT_AUDIO, AcousticEchoCanceler enabled. AudioCaptureService provides foreground service with microphone type. AudioRouter supports SPEAKER/EARPIECE/BLUETOOTH routing with saved route fallback on BT disconnect. AndroidManifest has FOREGROUND_SERVICE_MICROPHONE permission and service declaration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PttManager state machine and enhance MediasoupClient with send transport</name>
  <files>
    android/app/src/main/java/com/voiceping/android/data/ptt/PttManager.kt
    android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
  </files>
  <action>
    1. Enhance MediasoupClient.kt (MODIFY existing file -- read it first):
       - Add send transport fields: private var sendTransport: SendTransport?, private var audioProducer: Producer?
       - Add createSendTransport(channelId: String) method:
         a. Request CREATE_TRANSPORT from server with mapOf("channelId" to channelId, "direction" to "send") -- note: direction "send" vs "recv" differentiates transport type
         b. Extract id, iceParameters, iceCandidates, dtlsParameters from response
         c. Create sendTransport via device.createSendTransport() with listener:
            - onConnect: sends CONNECT_TRANSPORT to server (same pattern as recv transport)
            - onProduce: sends PRODUCE to server, returns producerId from response
            - onConnectionStateChange: log state changes
         d. Store in sendTransport field
         e. Add TODO markers where exact libmediasoup-android API needs verification (same pattern as Plan 05-03)
       - Add startProducing() method:
         a. Configure Opus codec: opusStereo=false, opusDtx=true, opusFec=true, opusMaxPlaybackRate=48000, opusPtime=20
         b. Call sendTransport.produce() with codec options
         c. Store result in audioProducer field
       - Add sendAudioData(buffer: ByteArray, length: Int) method:
         a. Forward to audioProducer (producer handles Opus encoding internally)
       - Add stopProducing() method:
         a. audioProducer?.close(), audioProducer = null
       - Update cleanup() to also close send transport and producer (producer first, then transport -- disposal order matters per Pitfall 5)

    2. Create PttManager.kt in data/ptt/ (NEW package):
       - @Singleton @Inject constructor with: SignalingClient, MediasoupClient, AudioCaptureManager, AudioRouter, context (@ApplicationContext)
       - Note: Does NOT inject TonePlayer, HapticFeedback, or SettingsRepository directly -- those are connected later in Plan 04 integration to avoid circular deps between Wave 1 plans
       - Private _pttState = MutableStateFlow<PttState>(PttState.Idle)
       - Public pttState: StateFlow<PttState> = _pttState.asStateFlow()
       - Private transmissionStartTime: Long = 0
       - Private currentChannelId: String? = null
       - Callbacks: var onPttGranted: (() -> Unit)? = null, var onPttDenied: (() -> Unit)? = null, var onPttReleased: (() -> Unit)? = null
       - These callbacks let Plan 04 wire in TonePlayer/HapticFeedback without PttManager needing those as constructor deps

       - requestPtt(channelId: String):
         a. Guard: if _pttState.value != PttState.Idle, return (already in use)
         b. Set _pttState.value = PttState.Requesting
         c. Launch coroutine (CoroutineScope(Dispatchers.IO)):
           - Send PTT_START request via signalingClient.request(SignalingType.PTT_START, mapOf("channelId" to channelId))
           - Check response: if error is null and data contains indication of grant:
             * Set _pttState.value = PttState.Transmitting
             * Set transmissionStartTime = System.currentTimeMillis()
             * Set currentChannelId = channelId
             * Start foreground service: context.startForegroundService(Intent(context, AudioCaptureService::class.java).apply { action = "com.voiceping.START_CAPTURE" })
             * Set audioCaptureManager.onAudioData callback to forward to mediasoupClient.sendAudioData()
             * Create send transport: mediasoupClient.createSendTransport(channelId)
             * Start producing: mediasoupClient.startProducing()
             * Start capture: audioCaptureManager.startCapture()
             * Call onPttGranted?.invoke()
           - Else (denied):
             * Set _pttState.value = PttState.Denied
             * Call onPttDenied?.invoke()
             * delay(500) then set _pttState.value = PttState.Idle
           - Catch exceptions: log error, reset to PttState.Idle

       - releasePtt():
         a. Guard: if _pttState.value != PttState.Transmitting, return
         b. Call onPttReleased?.invoke()
         c. Stop capture: audioCaptureManager.stopCapture()
         d. Stop producing: mediasoupClient.stopProducing()
         e. Stop foreground service: context.startService(Intent(context, AudioCaptureService::class.java).apply { action = "com.voiceping.STOP_CAPTURE" })
         f. Send PTT_STOP via signalingClient.send(SignalingType.PTT_STOP, mapOf("channelId" to currentChannelId!!))
         g. Set _pttState.value = PttState.Idle
         h. Reset transmissionStartTime = 0, currentChannelId = null

       - getTransmissionDurationSeconds(): Long
         a. If transmitting: (System.currentTimeMillis() - transmissionStartTime) / 1000
         b. Else: 0

       - IMPORTANT per user decision: State goes Idle -> Requesting -> Transmitting ONLY after server confirms (NOT optimistic). Requesting state shows subtle loading pulse on button. Transmitting state shows red pulse + elapsed time.
  </action>
  <verify>
    Build compiles: cd android && ./gradlew assembleDebug (PttManager and enhanced MediasoupClient compile, no import errors)
  </verify>
  <done>
    PttManager implements strict state machine: Idle -> Requesting -> (Transmitting | Denied) -> Idle. Server confirmation required before transmitting (not optimistic per user decision). MediasoupClient has send transport creation, producer start/stop, and audio data forwarding. Audio capture starts only after server grants PTT. Foreground service started/stopped around capture lifecycle.
  </done>
</task>

</tasks>

<verification>
1. ./gradlew assembleDebug compiles successfully
2. PttManager.requestPtt() transitions Idle -> Requesting, then waits for server response before Transmitting
3. PttManager NEVER goes directly from Idle to Transmitting (server confirmation required per user decision)
4. AudioCaptureManager uses VOICE_COMMUNICATION source and THREAD_PRIORITY_URGENT_AUDIO
5. AudioCaptureManager enables AcousticEchoCanceler when available
6. MediasoupClient.createSendTransport() follows same pattern as createRecvTransport() from Phase 5
7. AudioCaptureService declared in manifest with foregroundServiceType="microphone"
8. AudioRouter.setAudioRoute(BLUETOOTH) uses startBluetoothSco()
9. AudioRouter saves non-BT route for fallback on BT disconnect
</verification>

<success_criteria>
PTT engine compiles and implements complete flow: requestPtt() -> server request -> grant -> foreground service -> mic capture -> send transport -> produce -> audio data flows. releasePtt() stops in reverse order. Denied flow shows Denied state for 500ms then returns to Idle. No optimistic UI updates. AudioRouter supports all three output routes with Bluetooth SCO fallback.
</success_criteria>

<output>
After completion, create `.planning/phases/06-single-channel-ptt-audio/06-02-SUMMARY.md`
</output>
