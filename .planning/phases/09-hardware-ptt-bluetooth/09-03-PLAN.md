---
phase: 09-hardware-ptt-bluetooth
plan: 03
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified:
  - android/app/src/main/java/com/voiceping/android/service/BootReceiver.kt
  - android/app/src/main/AndroidManifest.xml
  - android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt
  - android/app/src/main/java/com/voiceping/android/presentation/MainActivity.kt
  - android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
autonomous: true

must_haves:
  truths:
    - "Volume key long-press triggers PTT on the correct scan-mode-aware channel"
    - "Bluetooth headset button triggers PTT via MediaButtonHandler callbacks"
    - "PTT auto-releases when Bluetooth headset disconnects mid-transmission (plays interrupted beep)"
    - "Audio device changes are detected and routed automatically on channel join"
    - "App starts as foreground service on boot when user has enabled auto-start setting"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/service/BootReceiver.kt"
      provides: "BroadcastReceiver for BOOT_COMPLETED that launches notification prompt"
      contains: "BOOT_COMPLETED"
    - path: "android/app/src/main/java/com/voiceping/android/presentation/MainActivity.kt"
      provides: "dispatchKeyEvent override wiring HardwareKeyHandler to PTT"
      contains: "dispatchKeyEvent"
    - path: "android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt"
      provides: "AudioDeviceManager and MediaButtonHandler wiring for PTT and audio routing"
      contains: "audioDeviceManager"
  key_links:
    - from: "MainActivity.kt"
      to: "HardwareKeyHandler.kt"
      via: "dispatchKeyEvent delegates to hardwareKeyHandler.handleKeyEvent"
      pattern: "hardwareKeyHandler\\.handleKeyEvent"
    - from: "ChannelRepository.kt"
      to: "AudioDeviceManager.kt"
      via: "starts/stops device manager on channel join/leave"
      pattern: "audioDeviceManager\\.start"
    - from: "ChannelRepository.kt"
      to: "MediaButtonHandler.kt"
      via: "activates/deactivates on channel join/leave, wires PTT callbacks"
      pattern: "mediaButtonHandler\\.setActive"
    - from: "BootReceiver.kt"
      to: "ChannelMonitoringService.kt"
      via: "starts foreground service or shows notification on boot"
      pattern: "startForegroundService|BOOT_COMPLETED"
---

<objective>
Wire hardware PTT handlers to the app lifecycle, implement boot auto-start, and integrate AudioDeviceManager and MediaButtonHandler into ChannelRepository for complete end-to-end hardware PTT functionality.

Purpose: Connects the foundation components (Plan 01 settings + key handler, Plan 02 audio device + BT button handler) to the app's activity, service, and repository layers. This makes hardware PTT actually work.

Output: Working volume key PTT in MainActivity, working BT button PTT via ChannelRepository, boot receiver for auto-start, and AudioDeviceManager lifecycle management.
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-hardware-ptt-bluetooth/09-RESEARCH.md
@.planning/phases/09-hardware-ptt-bluetooth/09-CONTEXT.md
@.planning/phases/09-hardware-ptt-bluetooth/09-01-SUMMARY.md
@.planning/phases/09-hardware-ptt-bluetooth/09-02-SUMMARY.md
@android/app/src/main/java/com/voiceping/android/presentation/MainActivity.kt
@android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
@android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt
@android/app/src/main/AndroidManifest.xml
@android/app/src/main/java/com/voiceping/android/data/ptt/PttManager.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BootReceiver and update manifest for boot auto-start</name>
  <files>
    android/app/src/main/java/com/voiceping/android/service/BootReceiver.kt
    android/app/src/main/AndroidManifest.xml
    android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt
  </files>
  <action>
    1. **Create BootReceiver.kt** in service/ package:

       ```kotlin
       class BootReceiver : BroadcastReceiver() {
           override fun onReceive(context: Context, intent: Intent) {
               if (intent.action == Intent.ACTION_BOOT_COMPLETED ||
                   intent.action == Intent.ACTION_LOCKED_BOOT_COMPLETED) {

                   Log.d(TAG, "Boot completed, checking auto-start setting")

                   // Read auto-start setting from DataStore
                   // NOTE: BootReceiver cannot use Hilt injection, so create SettingsRepository manually
                   // Use the DataStore directly via extension property on Context
                   val autoStartEnabled = runBlocking {
                       // Read directly from DataStore preferences
                       val prefs = context.dataStore.data.first()
                       prefs[booleanPreferencesKey("boot_auto_start_enabled")] ?: false
                   }

                   if (autoStartEnabled) {
                       Log.d(TAG, "Auto-start enabled, showing boot notification")
                       showBootNotification(context)
                   } else {
                       Log.d(TAG, "Auto-start disabled, ignoring boot event")
                   }
               }
           }
       }
       ```

       **CRITICAL per research (Android 15 restriction):** Cannot launch mediaPlayback foreground service from BOOT_COMPLETED. Instead of calling `startForegroundService()`, show a notification that the user can tap to launch the app.

       **showBootNotification(context):**
       - Create notification channel "boot_start" with IMPORTANCE_HIGH (so notification is visible)
       - Build notification with:
         - Title: "VoicePing ready"
         - Text: "Tap to connect to channels"
         - SmallIcon: R.drawable.ic_logo
         - ContentIntent: PendingIntent launching MainActivity (FLAG_ACTIVITY_NEW_TASK)
         - AutoCancel: true (dismiss on tap)
       - Post notification via NotificationManager

       For accessing DataStore from BootReceiver (non-Hilt context):
       - Import the same `Context.dataStore` extension property from SettingsRepository's package
       - IMPORTANT: The `preferencesDataStore` extension is file-level in SettingsRepository.kt. Either:
         (a) Move the `Context.dataStore` definition to a separate file accessible from both BootReceiver and SettingsRepository, OR
         (b) Read directly from file using PreferenceDataStoreFactory in BootReceiver
       - Simplest approach: Extract `Context.dataStore` to a new top-level Kotlin file `DataStoreExt.kt` in data/storage/ package, then import from both SettingsRepository and BootReceiver. Update SettingsRepository to import from DataStoreExt instead of declaring its own.

       Add companion object with `TAG = "BootReceiver"` and `BOOT_NOTIFICATION_ID = 1002`.

    2. **Update AndroidManifest.xml:**
       - Add permission: `<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />`
       - Add receiver inside `<application>`:
         ```xml
         <receiver
             android:name=".service.BootReceiver"
             android:enabled="true"
             android:exported="false">
             <intent-filter>
                 <action android:name="android.intent.action.BOOT_COMPLETED" />
                 <action android:name="android.intent.action.LOCKED_BOOT_COMPLETED" />
             </intent-filter>
         </receiver>
         ```

    3. **Add ACTION_BOOT_START to ChannelMonitoringService companion object:**
       - Add `const val ACTION_BOOT_START = "com.voiceping.BOOT_START"` (for future use if Android 15 restriction is lifted)
       - No other changes to service needed — boot now uses notification tap instead of direct service launch.
  </action>
  <verify>
    Run `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` — compilation passes. Verify AndroidManifest.xml has RECEIVE_BOOT_COMPLETED permission and BootReceiver declaration.
  </verify>
  <done>
    BootReceiver handles BOOT_COMPLETED by showing notification (respects Android 15 restriction). User taps notification to launch app. Manifest has RECEIVE_BOOT_COMPLETED permission and receiver declaration. DataStore extension extracted for shared access.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire HardwareKeyHandler to MainActivity and AudioDeviceManager/MediaButtonHandler to ChannelRepository</name>
  <files>
    android/app/src/main/java/com/voiceping/android/presentation/MainActivity.kt
    android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
  </files>
  <action>
    1. **Update MainActivity.kt** to intercept volume keys:

       Add Hilt injection for HardwareKeyHandler:
       ```kotlin
       @Inject lateinit var hardwareKeyHandler: HardwareKeyHandler
       ```

       Also inject ChannelListViewModel is NOT appropriate here (Activity doesn't own ViewModel). Instead, inject PttManager and ChannelRepository directly for PTT targeting:
       ```kotlin
       @Inject lateinit var pttManager: PttManager
       @Inject lateinit var channelRepository: ChannelRepository
       ```

       Wait — actually, the PTT target channel logic lives in ChannelListViewModel (which reads pttTargetMode and displayedChannelId). But we can't inject ViewModel into Activity like that. Instead, wire the callbacks:

       In `onCreate`, after `setContent`:
       ```kotlin
       // Wire hardware PTT callbacks
       hardwareKeyHandler.onPttPress = {
           // Send a broadcast or use a shared flow to trigger PTT
           // The simplest approach: call pttManager.requestPtt() directly
           // But we need the target channel ID...
       }
       ```

       Better approach: Create a simple `HardwarePttBridge` interface or just use a callback holder pattern. Actually, the simplest pattern that avoids ViewModel injection: expose a `hardwarePttTargetChannelId` from ChannelRepository that combines the scan mode logic.

       **Revised approach — add to ChannelRepository:**
       - Add `fun getHardwarePttTargetChannelId(): String?` method that:
         - Reads pttTargetMode from SettingsRepository (cached)
         - If ALWAYS_PRIMARY: returns primaryChannelId.value
         - If DISPLAYED_CHANNEL: returns the displayed channel ID (need to compute or cache this)
       - Since displayedChannelId logic is in ViewModel, simpler: add `var currentDisplayedChannelId: String? = null` to ChannelRepository, updated by ViewModel whenever displayedChannelId changes.

       Then in MainActivity:
       ```kotlin
       hardwareKeyHandler.onPttPress = {
           val targetChannelId = channelRepository.getHardwarePttTargetChannelId()
           if (targetChannelId != null) {
               pttManager.requestPtt(targetChannelId)
           }
       }
       hardwareKeyHandler.onPttRelease = {
           pttManager.releasePtt()
       }
       ```

       Override `dispatchKeyEvent`:
       ```kotlin
       override fun dispatchKeyEvent(event: KeyEvent): Boolean {
           if (event.keyCode == KeyEvent.KEYCODE_VOLUME_DOWN ||
               event.keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
               if (hardwareKeyHandler.isVolumeKeyPttEnabled(event.keyCode)) {
                   val handled = hardwareKeyHandler.handleKeyEvent(event)
                   if (handled) return true
               }
           }
           return super.dispatchKeyEvent(event)
       }
       ```

    2. **Update ChannelRepository** to integrate AudioDeviceManager and MediaButtonHandler:

       Add constructor parameters (Hilt-injected):
       ```kotlin
       private val audioDeviceManager: AudioDeviceManager,
       private val mediaButtonHandler: MediaButtonHandler,
       ```

       **In init block (alongside existing callback wiring):**

       a) Wire AudioDeviceManager Bluetooth disconnect callback:
       ```kotlin
       audioDeviceManager.onBluetoothDisconnected = {
           // Per user decision: auto-release PTT on BT disconnect, play interrupted beep
           Log.d(TAG, "Bluetooth disconnected, force-releasing PTT")
           pttManager.forceReleasePtt()
       }
       ```

       b) Wire MediaButtonHandler PTT callbacks:
       ```kotlin
       mediaButtonHandler.onPttPress = {
           val targetChannelId = getHardwarePttTargetChannelId()
           if (targetChannelId != null) {
               pttManager.requestPtt(targetChannelId)
           }
       }
       mediaButtonHandler.onPttRelease = {
           pttManager.releasePtt()
       }
       ```

       **In joinChannel() (after existing service start logic):**
       - Start AudioDeviceManager: `audioDeviceManager.start()`
       - Activate MediaButtonHandler: `mediaButtonHandler.setActive(true)`
       - Load configured BT keycode from SettingsRepository: `mediaButtonHandler.setConfiguredKeyCode(settingsRepository.getCachedBluetoothPttButtonKeycode())`
       - Only start these on FIRST channel join (use existing `isServiceRunning` flag pattern)

       **In leaveChannel() and disconnectAll() (alongside existing service stop logic):**
       - When last channel is left (no more monitored channels):
         - Stop AudioDeviceManager: `audioDeviceManager.stop()`
         - Deactivate MediaButtonHandler: `mediaButtonHandler.setActive(false)`

       **Add method `fun getHardwarePttTargetChannelId(): String?`:**
       - Read pttTargetMode from settingsRepository (cached)
       - ALWAYS_PRIMARY: return primaryChannelId.value
       - DISPLAYED_CHANNEL: return currentDisplayedChannelId (see below)

       **Add field `var currentDisplayedChannelId: String? = null`:**
       - Updated by ChannelListViewModel whenever displayedChannelId changes
       - Add to ChannelListViewModel init block: collect displayedChannelId and update channelRepository.currentDisplayedChannelId

       Also add SettingsRepository injection to ChannelRepository constructor if not already present (check existing code — it may already be there via transitive dependencies through PttManager).
  </action>
  <verify>
    Run `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` — compilation passes. Verify:
    - MainActivity has dispatchKeyEvent override
    - ChannelRepository has audioDeviceManager and mediaButtonHandler
    - ChannelRepository starts/stops device manager on channel join/leave
    - ChannelListViewModel updates channelRepository.currentDisplayedChannelId
  </verify>
  <done>
    MainActivity intercepts volume keys via dispatchKeyEvent and delegates to HardwareKeyHandler for PTT. ChannelRepository manages AudioDeviceManager and MediaButtonHandler lifecycle (start on first join, stop on last leave). BT disconnect auto-releases PTT with interrupted beep. Hardware PTT targets correct scan-mode-aware channel via getHardwarePttTargetChannelId().
  </done>
</task>

</tasks>

<verification>
1. `./gradlew compileDebugKotlin` passes without errors
2. MainActivity.dispatchKeyEvent() delegates to HardwareKeyHandler
3. Volume key long-press triggers pttManager.requestPtt() with correct channel ID
4. Volume key short-tap passes through to system (volume adjusts normally)
5. ChannelRepository starts AudioDeviceManager on first channel join
6. ChannelRepository stops AudioDeviceManager when last channel left
7. MediaButtonHandler activated/deactivated on channel join/leave
8. BT disconnect invokes pttManager.forceReleasePtt()
9. BootReceiver shows notification on BOOT_COMPLETED when auto-start enabled
10. AndroidManifest has RECEIVE_BOOT_COMPLETED permission and BootReceiver
</verification>

<success_criteria>
End-to-end hardware PTT works: volume key long-press and BT headset button trigger PTT on the correct scan-mode-aware channel. Audio auto-routes on device connection. Boot notification shows when auto-start enabled. All integration wiring compiles.
</success_criteria>

<output>
After completion, create `.planning/phases/09-hardware-ptt-bluetooth/09-03-SUMMARY.md`
</output>
