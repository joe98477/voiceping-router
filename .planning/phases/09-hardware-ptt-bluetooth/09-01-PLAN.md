---
phase: 09-hardware-ptt-bluetooth
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - android/app/src/main/java/com/voiceping/android/data/storage/SettingsRepository.kt
  - android/app/src/main/java/com/voiceping/android/domain/model/VolumeKeyPttConfig.kt
  - android/app/src/main/java/com/voiceping/android/domain/model/AudioOutputDevice.kt
  - android/app/src/main/java/com/voiceping/android/data/hardware/HardwareKeyHandler.kt
autonomous: true

must_haves:
  truths:
    - "Volume key long-press (>300ms) triggers PTT while short tap adjusts volume normally"
    - "User-configured volume key preference (up, down, or both) is persisted across app restarts"
    - "Hardware PTT settings are stored and retrievable from SettingsRepository"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/domain/model/VolumeKeyPttConfig.kt"
      provides: "Enum for volume key configuration (DISABLED, VOLUME_UP, VOLUME_DOWN, BOTH)"
    - path: "android/app/src/main/java/com/voiceping/android/domain/model/AudioOutputDevice.kt"
      provides: "Enum for current audio output device type (SPEAKER, EARPIECE, BLUETOOTH, WIRED_HEADSET)"
    - path: "android/app/src/main/java/com/voiceping/android/data/storage/SettingsRepository.kt"
      provides: "Hardware button settings persistence (volume key config, BT button keycode, boot auto-start, long-press threshold)"
      contains: "VOLUME_KEY_PTT_CONFIG"
    - path: "android/app/src/main/java/com/voiceping/android/data/hardware/HardwareKeyHandler.kt"
      provides: "Volume key dual-purpose logic: short tap = volume, long press = PTT"
      contains: "handleKeyEvent"
  key_links:
    - from: "HardwareKeyHandler.kt"
      to: "SettingsRepository.kt"
      via: "reads volume key config to determine which keys to intercept"
      pattern: "settingsRepository.*volumeKeyPttConfig"
---

<objective>
Create the settings foundation for hardware button configuration and implement the core volume key PTT handler with dual-purpose behavior (short tap = volume, long press = PTT).

Purpose: Establishes the data layer for all hardware button settings and implements the critical volume key interception logic that distinguishes between normal volume adjustment and PTT activation. This foundation is required by all subsequent Phase 9 plans.

Output: Domain model enums, extended SettingsRepository with hardware settings, and HardwareKeyHandler class ready to be wired into MainActivity.
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-hardware-ptt-bluetooth/09-RESEARCH.md
@.planning/phases/09-hardware-ptt-bluetooth/09-CONTEXT.md
@android/app/src/main/java/com/voiceping/android/data/storage/SettingsRepository.kt
@android/app/src/main/java/com/voiceping/android/data/ptt/PttManager.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hardware button settings to SettingsRepository and create domain models</name>
  <files>
    android/app/src/main/java/com/voiceping/android/domain/model/VolumeKeyPttConfig.kt
    android/app/src/main/java/com/voiceping/android/domain/model/AudioOutputDevice.kt
    android/app/src/main/java/com/voiceping/android/data/storage/SettingsRepository.kt
  </files>
  <action>
    1. Create `VolumeKeyPttConfig.kt` enum in domain/model/:
       - Values: DISABLED, VOLUME_UP, VOLUME_DOWN, BOTH
       - DISABLED is default (user must opt-in to volume key PTT)

    2. Create `AudioOutputDevice.kt` enum in domain/model/:
       - Values: SPEAKER, EARPIECE, BLUETOOTH, WIRED_HEADSET
       - Used for the audio output device indicator icon in the top bar
       - SPEAKER is default

    3. Extend SettingsRepository with new DataStore keys and accessors:
       - `VOLUME_KEY_PTT_CONFIG` (stringPreferencesKey) — stores VolumeKeyPttConfig enum name, default DISABLED
       - `BLUETOOTH_PTT_BUTTON_KEYCODE` (intPreferencesKey) — stores detected BT button KeyEvent keyCode, default KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE (85)
       - `BLUETOOTH_PTT_ENABLED` (booleanPreferencesKey) — BT PTT button enabled, default false
       - `BOOT_AUTO_START_ENABLED` (booleanPreferencesKey) — boot auto-start toggle, default false
       - `LONG_PRESS_THRESHOLD_MS` (intPreferencesKey) — long press threshold in ms, default 300

       For each key, add:
       - suspend setter (edit DataStore)
       - Flow getter (map from DataStore)
       - For VOLUME_KEY_PTT_CONFIG and LONG_PRESS_THRESHOLD_MS: also add getCached* sync accessor (runBlocking pattern from existing code) for use from key event handler on main thread

       Follow exact patterns from existing SettingsRepository code (e.g., getPttMode/setPttMode pattern for enums, getToggleMaxDuration/setToggleMaxDuration for ints, getPttStartToneEnabled/setPttStartToneEnabled for booleans).
  </action>
  <verify>
    Run `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` — compilation passes with no errors in new/modified files.
  </verify>
  <done>
    VolumeKeyPttConfig enum has 4 values (DISABLED default), AudioOutputDevice enum has 4 values, SettingsRepository has 5 new DataStore keys with getters/setters/cached accessors, all following existing patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HardwareKeyHandler for volume key dual-purpose PTT logic</name>
  <files>
    android/app/src/main/java/com/voiceping/android/data/hardware/HardwareKeyHandler.kt
  </files>
  <action>
    Create `HardwareKeyHandler.kt` in data/hardware/ package:

    ```kotlin
    @Singleton
    class HardwareKeyHandler @Inject constructor(
        private val settingsRepository: SettingsRepository
    )
    ```

    **Core logic — dual-purpose volume key handling per user decision:**

    The handler receives KeyEvent from Activity.dispatchKeyEvent() and determines whether to consume it (PTT) or pass through (volume adjustment).

    **State tracking:**
    - `keyDownTime: Long = 0` — timestamp of initial key press
    - `isLongPressActive: Boolean = false` — whether PTT has been activated for current press
    - `activeKeyCode: Int = 0` — which key is currently being tracked

    **Callback:**
    - `var onPttPress: (() -> Unit)? = null` — called when long press threshold reached (PTT start)
    - `var onPttRelease: (() -> Unit)? = null` — called when key released after long press (PTT stop)

    **Method: `fun isVolumeKeyPttEnabled(keyCode: Int): Boolean`**
    - Read cached VolumeKeyPttConfig from SettingsRepository
    - Return true if:
      - Config is VOLUME_UP and keyCode is KEYCODE_VOLUME_UP
      - Config is VOLUME_DOWN and keyCode is KEYCODE_VOLUME_DOWN
      - Config is BOTH and keyCode is either VOLUME_UP or VOLUME_DOWN
      - Config is DISABLED → always false

    **Method: `fun handleKeyEvent(event: KeyEvent): Boolean`**
    - Per user decision: press-and-hold only, 300ms threshold, dual-purpose
    - Read cached long-press threshold from SettingsRepository

    - ACTION_DOWN with repeatCount == 0 (initial press):
      - Record keyDownTime = event.eventTime
      - Record activeKeyCode = event.keyCode
      - Return false (DON'T consume — allow system volume adjustment for short tap)

    - ACTION_DOWN with repeatCount > 0 (repeat/held):
      - Calculate duration = event.eventTime - keyDownTime
      - If duration >= threshold AND !isLongPressActive:
        - isLongPressActive = true
        - Call onPttPress callback
        - Return true (consume — prevent further volume adjustment)
      - If isLongPressActive:
        - Return true (consume repeat events during PTT)
      - Else return false

    - ACTION_UP:
      - val wasLongPress = isLongPressActive
      - Reset: isLongPressActive = false, keyDownTime = 0, activeKeyCode = 0
      - If wasLongPress:
        - Call onPttRelease callback
        - Return true (consume — don't adjust volume after PTT release)
      - Else:
        - Return false (short tap — let system handle volume)

    CRITICAL per research: Do NOT consume the initial ACTION_DOWN event. Volume adjustment must work for short taps. Only consume events after long press threshold is confirmed via repeat events.

    Add companion object with TAG = "HardwareKeyHandler" and use Log.d for state transitions.
  </action>
  <verify>
    Run `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` — compilation passes. Verify HardwareKeyHandler has handleKeyEvent method, onPttPress/onPttRelease callbacks, and isVolumeKeyPttEnabled method.
  </verify>
  <done>
    HardwareKeyHandler implements dual-purpose volume key logic: short tap (<300ms) passes through for normal volume adjustment, long press (>=300ms) triggers PTT via callbacks. Configurable via SettingsRepository cached accessors.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew compileDebugKotlin` passes without errors
2. VolumeKeyPttConfig has DISABLED, VOLUME_UP, VOLUME_DOWN, BOTH values
3. AudioOutputDevice has SPEAKER, EARPIECE, BLUETOOTH, WIRED_HEADSET values
4. SettingsRepository has 5 new keys with getters/setters
5. HardwareKeyHandler.handleKeyEvent returns false for initial ACTION_DOWN (allows volume)
6. HardwareKeyHandler.handleKeyEvent returns true for repeat events after threshold
7. HardwareKeyHandler.handleKeyEvent calls onPttPress on threshold crossing
8. HardwareKeyHandler.handleKeyEvent calls onPttRelease on ACTION_UP after long press
</verification>

<success_criteria>
Settings foundation and volume key handler compile, follow existing code patterns, and implement the dual-purpose volume key behavior specified in user decisions: short tap adjusts volume, long press (300ms) activates PTT.
</success_criteria>

<output>
After completion, create `.planning/phases/09-hardware-ptt-bluetooth/09-01-SUMMARY.md`
</output>
