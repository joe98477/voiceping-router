---
phase: 07-foreground-service-background-audio
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt
  - android/app/src/main/java/com/voiceping/android/service/NotificationActionReceiver.kt
  - android/app/src/main/AndroidManifest.xml
  - android/app/src/main/java/com/voiceping/android/data/audio/TonePlayer.kt
autonomous: true

must_haves:
  truths:
    - "Foreground service can be started with mediaPlayback type and shows persistent notification"
    - "Notification displays channel name with Mute and Disconnect action buttons"
    - "Notification action buttons trigger BroadcastReceiver which relays to service"
    - "Notification updates only on channel change, not on every speaker change"
    - "Distinct double beep tone exists for phone call interruption scenario"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt"
      provides: "Foreground service for channel monitoring with persistent notification"
      contains: "FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK"
    - path: "android/app/src/main/java/com/voiceping/android/service/NotificationActionReceiver.kt"
      provides: "BroadcastReceiver handling Mute and Disconnect notification actions"
      contains: "ACTION_TOGGLE_MUTE"
    - path: "android/app/src/main/AndroidManifest.xml"
      provides: "Service and receiver declarations with required permissions"
      contains: "FOREGROUND_SERVICE_MEDIA_PLAYBACK"
    - path: "android/app/src/main/java/com/voiceping/android/data/audio/TonePlayer.kt"
      provides: "Call interruption double beep tone"
      contains: "playCallInterruptionBeep"
  key_links:
    - from: "NotificationActionReceiver"
      to: "ChannelMonitoringService"
      via: "startService intent with action"
      pattern: "context.startService.*ChannelMonitoringService"
    - from: "ChannelMonitoringService notification actions"
      to: "NotificationActionReceiver"
      via: "PendingIntent.getBroadcast"
      pattern: "PendingIntent.getBroadcast.*NotificationActionReceiver"
---

<objective>
Create ChannelMonitoringService foreground service with persistent notification (Mute/Disconnect actions), NotificationActionReceiver for handling notification button taps, update AndroidManifest with required permissions and declarations, and add call interruption double beep tone to TonePlayer.

Purpose: Establishes the service infrastructure that keeps the app alive as a "pocket radio" when the screen is off. The persistent notification provides minimal controls (Mute, Disconnect) without requiring the user to open the app.

Output: ChannelMonitoringService.kt, NotificationActionReceiver.kt, updated AndroidManifest.xml, updated TonePlayer.kt
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-foreground-service-background-audio/07-CONTEXT.md
@.planning/phases/07-foreground-service-background-audio/07-RESEARCH.md
@.planning/phases/06-single-channel-ptt-audio/06-02-SUMMARY.md (AudioCaptureService pattern reference)

Key existing files to reference:
@android/app/src/main/java/com/voiceping/android/service/AudioCaptureService.kt (existing foreground service pattern)
@android/app/src/main/AndroidManifest.xml (current permissions and declarations)
@android/app/src/main/java/com/voiceping/android/data/audio/TonePlayer.kt (add call interruption tone)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChannelMonitoringService and update AndroidManifest</name>
  <files>
    android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt
    android/app/src/main/AndroidManifest.xml
  </files>
  <action>
Create ChannelMonitoringService.kt in the service/ package. This is a foreground service (type: mediaPlayback) that keeps WebSocket and audio alive when screen is off.

**Service class structure:**

1. **Annotate with `@AndroidEntryPoint`** for Hilt injection (same pattern as AudioCaptureService).

2. **onStartCommand() handles these actions:**
   - `ACTION_START` — Create notification channel, build notification, call startForeground() with FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK. Store initial channel name from intent extra.
   - `ACTION_UPDATE_CHANNEL` — Update notification with new channel name (only on channel change per user decision: minimal updates, NOT on every speaker change).
   - `ACTION_TOGGLE_MUTE` — Toggle internal `isMuted` boolean, update notification Mute button label ("Mute"/"Unmute"), expose mute state. This action will be called by NotificationActionReceiver.
   - `ACTION_STOP` — Call stopForeground(STOP_FOREGROUND_REMOVE), stopSelf().

3. **Return `START_NOT_STICKY`** from onStartCommand (user decision: no auto-restart after force-kill).

4. **Notification channel creation:**
   - Channel ID: `"channel_monitoring"`
   - Channel name: `"Channel Monitoring"`
   - Importance: `NotificationManager.IMPORTANCE_LOW` (per research: no sound from notification, user hears squelch tone + audio itself; pocket radio is unobtrusive)
   - setShowBadge(false) — pocket radio doesn't need badge
   - lockscreenVisibility = Notification.VISIBILITY_PUBLIC — show on lock screen

5. **buildNotification(channelName, isMuted):**
   - Title: channelName or "VoicePing" fallback
   - Content text: "Monitoring" (user decision: minimal, like a music player)
   - SmallIcon: R.drawable.ic_logo
   - setOngoing(true) — persistent, cannot be swiped away
   - Priority: NotificationCompat.PRIORITY_DEFAULT
   - Content intent: PendingIntent to open MainActivity (tapping notification opens app)
   - **Mute action:** PendingIntent.getBroadcast to NotificationActionReceiver with ACTION_TOGGLE_MUTE. Label changes: "Mute" when not muted, "Unmute" when muted. Icon: R.drawable.ic_logo (reuse for now, placeholder).
   - **Disconnect action:** PendingIntent.getBroadcast to NotificationActionReceiver with ACTION_DISCONNECT. Icon: R.drawable.ic_logo (placeholder).
   - Both PendingIntents use `PendingIntent.FLAG_IMMUTABLE` (Android 12+ requirement) and `PendingIntent.FLAG_UPDATE_CURRENT` (so label updates work).

6. **Notification update method:**
   - `updateNotification(channelName)` — Only updates if channelName changed (user decision: minimal updates). Uses NotificationManager.notify() to update in place.
   - Track `currentChannelName: String?` to detect changes.

7. **Mute state:**
   - `private var isMuted = false`
   - Expose via companion object or static accessor for ChannelRepository to read.
   - Better approach: Use a MutableStateFlow in a shared holder or pass via intent. For simplicity, use a companion `val isMutedFlow = MutableStateFlow(false)` that ChannelRepository can observe.

8. **API 34+ handling for startForeground:**
   - `if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE)` use three-param startForeground with `ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK`
   - Else use two-param startForeground

9. **Companion constants:**
   - ACTION_START = "com.voiceping.START_MONITORING"
   - ACTION_UPDATE_CHANNEL = "com.voiceping.UPDATE_CHANNEL"
   - ACTION_TOGGLE_MUTE = "com.voiceping.TOGGLE_MUTE_SERVICE"
   - ACTION_STOP = "com.voiceping.STOP_MONITORING"
   - EXTRA_CHANNEL_NAME = "channel_name"
   - CHANNEL_ID = "channel_monitoring"
   - NOTIFICATION_ID = 1000 (different from AudioCaptureService's 1001)

**Update AndroidManifest.xml:**

Add these permissions (before `<application>`):
```xml
<uses-permission android:name="android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK" />
<uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS" />
```

Add service declaration (inside `<application>`, after AudioCaptureService):
```xml
<service
    android:name=".service.ChannelMonitoringService"
    android:foregroundServiceType="mediaPlayback"
    android:exported="false" />
```

Add receiver declaration (inside `<application>`):
```xml
<receiver
    android:name=".service.NotificationActionReceiver"
    android:exported="false" />
```
  </action>
  <verify>
Verify ChannelMonitoringService.kt exists and contains:
- `@AndroidEntryPoint` annotation
- `startForeground` call with FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK
- `START_NOT_STICKY` return
- `IMPORTANCE_LOW` notification channel
- `PendingIntent.FLAG_IMMUTABLE` on all PendingIntents
- Mute and Disconnect actions in notification
- `isMutedFlow` companion StateFlow
- API 34 version check for startForeground

Verify AndroidManifest.xml contains:
- FOREGROUND_SERVICE_MEDIA_PLAYBACK permission
- REQUEST_IGNORE_BATTERY_OPTIMIZATIONS permission
- ChannelMonitoringService declaration with foregroundServiceType="mediaPlayback"
- NotificationActionReceiver declaration with exported="false"
  </verify>
  <done>
ChannelMonitoringService.kt exists with foreground service type mediaPlayback, persistent notification with Mute/Disconnect actions, IMPORTANCE_LOW channel, START_NOT_STICKY, and API 34+ compatibility. AndroidManifest.xml declares all required permissions, service, and receiver.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create NotificationActionReceiver and add call interruption beep to TonePlayer</name>
  <files>
    android/app/src/main/java/com/voiceping/android/service/NotificationActionReceiver.kt
    android/app/src/main/java/com/voiceping/android/data/audio/TonePlayer.kt
  </files>
  <action>
**Create NotificationActionReceiver.kt** in the service/ package:

1. Extends BroadcastReceiver
2. `onReceive(context, intent)` handles two actions:
   - `ACTION_TOGGLE_MUTE`: Creates intent to ChannelMonitoringService with ACTION_TOGGLE_MUTE, calls context.startService(). This relays the mute toggle from notification button tap to the service.
   - `ACTION_DISCONNECT`: Creates intent to ChannelMonitoringService with ACTION_STOP, calls context.startService(). This stops the monitoring service from notification.
3. Companion constants:
   - `ACTION_TOGGLE_MUTE = "com.voiceping.TOGGLE_MUTE"`
   - `ACTION_DISCONNECT = "com.voiceping.DISCONNECT"`

Pattern reference: Research Pattern 5 (BroadcastReceiver for Notification Actions).

**Update TonePlayer.kt** - add `playCallInterruptionBeep()`:

Add a new method after `playErrorTone()`:

```kotlin
/**
 * Play call interruption beep - distinct double beep when phone call interrupts PTT.
 *
 * Tone: Two DTMF_A tones (697 Hz + 1633 Hz) separated by 100ms pause
 * Configurable: No (always plays - user must know PTT was interrupted)
 * Purpose: Signals to other channel users that the speaker was interrupted
 *          by a phone call (distinct from normal roger beep which means
 *          intentional stop)
 */
fun playCallInterruptionBeep() {
    try {
        // Always play (no toggle) - signals call interruption to other users
        // First beep
        toneGenerator?.startTone(ToneGenerator.TONE_DTMF_A, 100)
        // Schedule second beep after pause
        // Note: ToneGenerator.startTone is async, so we use Thread.sleep for timing
        Thread.sleep(200) // 100ms tone + 100ms pause
        toneGenerator?.startTone(ToneGenerator.TONE_DTMF_A, 100)
        Log.d(TAG, "Playing call interruption double beep")
    } catch (e: Exception) {
        Log.e(TAG, "Error playing call interruption beep", e)
    }
}
```

User decision: "Double beep for call interruption should be distinct from normal roger beep." This uses DTMF_A (1633 Hz + 697 Hz) which is distinct from roger beep (DTMF_0 at 1336 Hz + 941 Hz) and error tone (PROP_BEEP2). Two short beeps separated by pause create a recognizable "interrupted" signal.
  </action>
  <verify>
Verify NotificationActionReceiver.kt exists and contains:
- Extends BroadcastReceiver
- Handles ACTION_TOGGLE_MUTE and ACTION_DISCONNECT
- Creates intents to ChannelMonitoringService
- Uses context.startService() to relay actions

Verify TonePlayer.kt contains:
- New `playCallInterruptionBeep()` method
- Uses TONE_DTMF_A (distinct from roger beep DTMF_0 and error PROP_BEEP2)
- Two beeps with pause between them
- Always plays (no settings toggle check)
  </verify>
  <done>
NotificationActionReceiver handles Mute and Disconnect notification actions by relaying to ChannelMonitoringService. TonePlayer has distinct call interruption double beep (DTMF_A x2) that signals phone call interruption to other channel users.
  </done>
</task>

</tasks>

<verification>
1. ChannelMonitoringService.kt compiles (correct imports, @AndroidEntryPoint, Service extension)
2. NotificationActionReceiver.kt compiles (correct imports, BroadcastReceiver extension)
3. AndroidManifest.xml has all required permissions and declarations
4. TonePlayer.kt has playCallInterruptionBeep() using distinct DTMF tone
5. Notification uses IMPORTANCE_LOW channel with VISIBILITY_PUBLIC lockscreen
6. All PendingIntents use FLAG_IMMUTABLE
7. Service uses START_NOT_STICKY (no auto-restart per user decision)
8. API 34+ startForeground uses three-param version with service type
</verification>

<success_criteria>
- ChannelMonitoringService can be started as foreground service with mediaPlayback type
- Persistent notification shows channel name with Mute and Disconnect buttons
- NotificationActionReceiver correctly relays notification button taps to service
- TonePlayer has distinct double beep for call interruption (different from roger beep and error tone)
- AndroidManifest declares all required permissions and components
</success_criteria>

<output>
After completion, create `.planning/phases/07-foreground-service-background-audio/07-01-SUMMARY.md`
</output>
