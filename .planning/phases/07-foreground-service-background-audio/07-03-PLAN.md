---
phase: 07-foreground-service-background-audio
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
  - android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListViewModel.kt
  - android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListScreen.kt
autonomous: true

must_haves:
  truths:
    - "Monitoring service starts when user first joins a channel"
    - "Monitoring service stops when user disconnects, logs out, or leaves all channels"
    - "Phone call immediately pauses all channel audio and force-releases PTT with double beep"
    - "Channel audio auto-resumes immediately after phone call ends"
    - "Mute toggle from notification silences incoming audio"
    - "Battery optimization exemption prompted on first channel join"
    - "Service does not start on login or app launch (only on channel join)"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt"
      provides: "Service lifecycle management, phone call handling wiring, mute state"
      contains: "ChannelMonitoringService"
    - path: "android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListViewModel.kt"
      provides: "Battery optimization check trigger and service lifecycle coordination"
      contains: "REQUEST_IGNORE_BATTERY_OPTIMIZATIONS"
    - path: "android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListScreen.kt"
      provides: "Battery optimization dialog and intent launcher"
      contains: "ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS"
  key_links:
    - from: "ChannelRepository.joinChannel"
      to: "ChannelMonitoringService.ACTION_START"
      via: "context.startForegroundService intent"
      pattern: "startForegroundService.*ACTION_START"
    - from: "ChannelRepository.leaveChannel"
      to: "ChannelMonitoringService.ACTION_STOP"
      via: "context.startService intent"
      pattern: "startService.*ACTION_STOP"
    - from: "AudioRouter.onPhoneCallStarted"
      to: "PttManager.forceReleasePtt + mediasoupClient.pauseAllConsumers"
      via: "callback wired in ChannelRepository init"
      pattern: "onPhoneCallStarted.*forceReleasePtt"
    - from: "AudioRouter.onPhoneCallEnded"
      to: "mediasoupClient.resumeAllConsumers"
      via: "callback wired in ChannelRepository init"
      pattern: "onPhoneCallEnded.*resume"
---

<objective>
Wire ChannelMonitoringService lifecycle to channel join/leave, integrate phone call handling callbacks (AudioRouter -> PttManager force release + audio pause/resume), add notification mute state management, and implement battery optimization exemption prompt on first channel join.

Purpose: This is the integration plan that makes the "pocket radio" actually work. Service starts when user joins a channel (not before), phone calls properly interrupt transmission with distinct feedback, mute toggle silences incoming audio, and battery optimization exemption ensures Doze mode survival.

Output: Enhanced ChannelRepository.kt, ChannelListViewModel.kt, ChannelListScreen.kt
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-foreground-service-background-audio/07-CONTEXT.md
@.planning/phases/07-foreground-service-background-audio/07-RESEARCH.md
@.planning/phases/07-foreground-service-background-audio/07-01-SUMMARY.md (ChannelMonitoringService, NotificationActionReceiver, TonePlayer)
@.planning/phases/07-foreground-service-background-audio/07-02-SUMMARY.md (AudioRouter focus listener, PttManager forceReleasePtt)
@.planning/phases/06-single-channel-ptt-audio/06-04-SUMMARY.md (current ChannelRepository and ViewModel integration)

Key existing files to reference:
@android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt (add service lifecycle + phone call wiring)
@android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListViewModel.kt (add battery optimization)
@android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListScreen.kt (add battery optimization UI)
@android/app/src/main/java/com/voiceping/android/service/ChannelMonitoringService.kt (from Plan 01)
@android/app/src/main/java/com/voiceping/android/data/audio/AudioRouter.kt (from Plan 02)
@android/app/src/main/java/com/voiceping/android/data/ptt/PttManager.kt (from Plan 02)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire service lifecycle and phone call handling into ChannelRepository</name>
  <files>android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt</files>
  <action>
Enhance ChannelRepository with three major additions: (A) monitoring service lifecycle, (B) phone call handling wiring, (C) mute state observation.

**A. Monitoring Service Lifecycle**

Add import for ChannelMonitoringService. Add a `private var isServiceRunning = false` field.

**In `joinChannel()`, after the existing Step 5 (update joinedChannelId), add Step 6:**

```kotlin
// 6. Start monitoring service (user decision: service starts on first channel join)
if (!isServiceRunning) {
    val serviceIntent = Intent(context, ChannelMonitoringService::class.java).apply {
        action = ChannelMonitoringService.ACTION_START
        putExtra(ChannelMonitoringService.EXTRA_CHANNEL_NAME, channelId) // Will be replaced with channel name in future
    }
    context.startForegroundService(serviceIntent)
    isServiceRunning = true
    Log.d(TAG, "Started ChannelMonitoringService")
}
```

**In `leaveChannel()`, after existing Step 6 (clear joinedChannelId), add Step 7:**

```kotlin
// 7. Stop monitoring service (user decision: service stops when user leaves all channels)
if (isServiceRunning) {
    val serviceIntent = Intent(context, ChannelMonitoringService::class.java).apply {
        action = ChannelMonitoringService.ACTION_STOP
    }
    context.startService(serviceIntent)
    isServiceRunning = false
    Log.d(TAG, "Stopped ChannelMonitoringService")
}
```

**In `disconnectAll()`, add service stop before the existing leaveChannel call:**

```kotlin
// Stop monitoring service
if (isServiceRunning) {
    val serviceIntent = Intent(context, ChannelMonitoringService::class.java).apply {
        action = ChannelMonitoringService.ACTION_STOP
    }
    context.startService(serviceIntent)
    isServiceRunning = false
    Log.d(TAG, "Stopped ChannelMonitoringService (disconnectAll)")
}
```

**B. Phone Call Handling Wiring**

Wire AudioRouter callbacks in the init block, after the existing PttManager callback wiring:

```kotlin
// Wire phone call handling via AudioRouter (audio focus listener)
// User decision: immediate pause, force-release PTT, auto-resume after call ends
audioRouter.onPhoneCallStarted = {
    Log.d(TAG, "Phone call started: pausing audio, force-releasing PTT")

    // Force-release PTT if transmitting (plays call interruption double beep)
    // User decision: "force-release PTT with a distinct double beep"
    if (pttManager.pttState.value is PttState.Transmitting) {
        pttManager.forceReleasePtt()
    }

    // Pause all incoming audio (user decision: immediate, no fade)
    mediasoupClient.pauseAllConsumers()
}

audioRouter.onPhoneCallEnded = {
    Log.d(TAG, "Phone call ended: resuming audio")

    // Resume all incoming audio (user decision: auto-resume immediately, no delay)
    mediasoupClient.resumeAllConsumers()
}
```

**Also wire the PttManager call interruption callback (in init, after existing callbacks):**

```kotlin
// Wire call interruption beep (distinct from roger beep)
pttManager.onPttInterrupted = {
    tonePlayer.playCallInterruptionBeep()
}
```

**C. Mute State Observation**

Add mute state observation from ChannelMonitoringService. In the init block:

```kotlin
// Observe mute state from monitoring service notification
CoroutineScope(Dispatchers.IO).launch {
    ChannelMonitoringService.isMutedFlow.collect { isMuted ->
        if (isMuted) {
            mediasoupClient.pauseAllConsumers()
            Log.d(TAG, "Muted: pausing all consumers")
        } else {
            // Only resume if not in phone call
            if (!audioRouter.isInPhoneCall()) {
                mediasoupClient.resumeAllConsumers()
                Log.d(TAG, "Unmuted: resuming all consumers")
            }
        }
    }
}
```

**Add missing methods to MediasoupClient if needed:**

The plan assumes MediasoupClient has `pauseAllConsumers()` and `resumeAllConsumers()` methods. If these don't exist, add TODO comments in ChannelRepository noting they need to be implemented. These methods should pause/resume the active consumer's audio track.

Actually, the existing MediasoupClient may not have these methods. In that case, add them as no-op methods with TODO comments:

In ChannelRepository, for the mute/phone call handling, use a simpler approach:
- Track `_isMuted: MutableStateFlow<Boolean>(false)` in ChannelRepository
- In observeSpeakerChanges, check mute state before calling `consumeAudio()`
- For immediate mute: close current consumer. For unmute: re-consume if speaker is active.

But the simpler approach for Phase 7: just track mute state and let the audio routing handle it. When muted, don't play incoming audio by closing the consumer. This is already how the existing code works (close/create consumers).

Add to ChannelRepository:

```kotlin
private val _isMuted = MutableStateFlow(false)
val isMuted: StateFlow<Boolean> = _isMuted.asStateFlow()
```

Wire mute from service:
```kotlin
// In init block
CoroutineScope(Dispatchers.IO).launch {
    ChannelMonitoringService.isMutedFlow.collect { muted ->
        _isMuted.value = muted
        if (muted) {
            // Close current consumer to silence audio
            currentConsumerId?.let { mediasoupClient.closeConsumer(it) }
            Log.d(TAG, "Muted: closed consumer")
        }
        // Unmute is handled automatically by next speaker change creating new consumer
    }
}
```

In observeSpeakerChanges, add mute guard before consuming audio:
```kotlin
// Before mediasoupClient.consumeAudio() call, add:
if (!_isMuted.value) {
    mediasoupClient.consumeAudio(producerId, speakerUserId)
    currentConsumerId = producerId
}
```

Similarly, for phone call pause/resume, use the same consumer close approach:
```kotlin
audioRouter.onPhoneCallStarted = {
    if (pttManager.pttState.value is PttState.Transmitting) {
        pttManager.forceReleasePtt()
    }
    // Close consumer to pause audio (user decision: immediate, no fade)
    currentConsumerId?.let { mediasoupClient.closeConsumer(it) }
    Log.d(TAG, "Phone call: closed consumer")
}

audioRouter.onPhoneCallEnded = {
    // Audio will resume on next speaker change event
    // If there's an active speaker, we need to re-consume
    // For now, log it — the speaker observation will handle new speaker events
    Log.d(TAG, "Phone call ended: ready to receive audio")
}
```

**Add TAG constant:**

Add `private const val TAG = "ChannelRepository"` to a companion object (or use inline string if no companion exists).

**Required imports to add:**
- `android.content.Intent`
- `com.voiceping.android.service.ChannelMonitoringService`
- `android.util.Log`
  </action>
  <verify>
Verify ChannelRepository.kt contains:
- Import for ChannelMonitoringService
- `isServiceRunning` field
- Service start intent in joinChannel() with ACTION_START and startForegroundService
- Service stop intent in leaveChannel() with ACTION_STOP
- Service stop in disconnectAll()
- `audioRouter.onPhoneCallStarted` callback wired in init
- `audioRouter.onPhoneCallEnded` callback wired in init
- `pttManager.onPttInterrupted` callback wired in init (for call interruption beep)
- Phone call handler calls `pttManager.forceReleasePtt()` when transmitting
- `_isMuted` StateFlow tracking mute state
- Mute state observation from ChannelMonitoringService.isMutedFlow
- Mute guard in observeSpeakerChanges before consumeAudio
- All existing functionality preserved (join/leave/speaker observation/PTT callbacks)
  </verify>
  <done>
ChannelRepository manages monitoring service lifecycle (start on join, stop on leave/disconnect), handles phone calls (force-release PTT + pause audio via consumer close), observes mute state from notification, and guards audio consumption against mute state. Service starts only on first channel join per user decision.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add battery optimization prompt and service coordination to ViewModel and Screen</name>
  <files>
    android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListViewModel.kt
    android/app/src/main/java/com/voiceping/android/presentation/channels/ChannelListScreen.kt
  </files>
  <action>
**ChannelListViewModel.kt changes:**

1. **Add battery optimization check.** Add a `private var hasCheckedBatteryOptimization = false` field.

2. **Add battery optimization state flow:**
```kotlin
private val _showBatteryOptimizationPrompt = MutableStateFlow(false)
val showBatteryOptimizationPrompt: StateFlow<Boolean> = _showBatteryOptimizationPrompt.asStateFlow()
```

3. **Add muted state exposure:**
```kotlin
val isMuted: StateFlow<Boolean> = channelRepository.isMuted
```

4. **Modify `toggleChannel()`** to trigger battery optimization check on first join. After the successful `joinChannelUseCase(channel.id)` call (where `result.isSuccess`), add:

```kotlin
// Check battery optimization on first channel join
// User decision: prompt when user first joins a channel (when service starts)
if (!hasCheckedBatteryOptimization) {
    checkBatteryOptimization()
    hasCheckedBatteryOptimization = true
}
```

5. **Add `checkBatteryOptimization()` private method:**

```kotlin
private fun checkBatteryOptimization() {
    val powerManager = context.getSystemService(Context.POWER_SERVICE) as android.os.PowerManager
    val packageName = context.packageName
    if (!powerManager.isIgnoringBatteryOptimizations(packageName)) {
        _showBatteryOptimizationPrompt.value = true
    }
}
```

Note: ChannelListViewModel already has access to `@ApplicationContext context` through its dependencies. However, looking at the existing code, it doesn't inject Context directly. It injects specific repositories and managers.

Better approach: inject PowerManager via Hilt or check via a utility. Simplest: add `@ApplicationContext private val context: Context` to the constructor. But ChannelListViewModel is @HiltViewModel, so we need to verify it can accept @ApplicationContext.

Actually, looking at the existing ChannelListViewModel constructor, it doesn't have Context. Add it:
```kotlin
@ApplicationContext private val context: Context,
```
as a new constructor parameter. This is safe for @HiltViewModel with Hilt injection.

6. **Add `dismissBatteryOptimizationPrompt()` method:**
```kotlin
fun dismissBatteryOptimizationPrompt() {
    _showBatteryOptimizationPrompt.value = false
}
```

7. **Override `onCleared()`** is already implemented and calls `channelRepository.disconnectAll()` which now stops the monitoring service. No changes needed.

**Required ViewModel imports to add:**
- `android.content.Context`
- `android.provider.Settings`
- `dagger.hilt.android.qualifiers.ApplicationContext`

**ChannelListScreen.kt changes:**

1. **Collect battery optimization prompt state:**
```kotlin
val showBatteryPrompt by viewModel.showBatteryOptimizationPrompt.collectAsState()
```

2. **Add battery optimization intent launcher** (before the existing mic permission launcher):
```kotlin
val batteryOptimizationLauncher = rememberLauncherForActivityResult(
    contract = ActivityResultContracts.StartActivityForResult()
) { _ ->
    // Result doesn't matter — user either allowed or denied. Dismiss either way.
    viewModel.dismissBatteryOptimizationPrompt()
}
```

3. **Add LaunchedEffect to show battery optimization dialog when prompted:**
```kotlin
LaunchedEffect(showBatteryPrompt) {
    if (showBatteryPrompt) {
        val intent = Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS).apply {
            data = Uri.parse("package:${context.packageName}")
        }
        batteryOptimizationLauncher.launch(intent)
    }
}
```

Note: ChannelListScreen needs access to `context`. Use `LocalContext.current` if not already available.

4. **Collect muted state for potential UI indicator (optional):**
```kotlin
val isMuted by viewModel.isMuted.collectAsState()
```

This can be passed to BottomBar or ChannelRow in the future for visual mute indicator, but for now just collecting it is sufficient. The mute toggle happens via notification, and the audio effect is handled in ChannelRepository.

**Required Screen imports to add:**
- `android.content.Intent`
- `android.net.Uri`
- `android.provider.Settings`
- `androidx.activity.compose.rememberLauncherForActivityResult`
- `androidx.activity.result.contract.ActivityResultContracts`
- `androidx.compose.ui.platform.LocalContext` (if not already imported)
  </action>
  <verify>
Verify ChannelListViewModel.kt contains:
- `@ApplicationContext private val context: Context` constructor parameter
- `showBatteryOptimizationPrompt` StateFlow
- `hasCheckedBatteryOptimization` field
- `checkBatteryOptimization()` using PowerManager.isIgnoringBatteryOptimizations
- Battery check triggered after first successful channel join
- `dismissBatteryOptimizationPrompt()` method
- `isMuted` StateFlow exposed from ChannelRepository
- Existing onCleared() still calls channelRepository.disconnectAll()

Verify ChannelListScreen.kt contains:
- Battery optimization launcher using rememberLauncherForActivityResult
- LaunchedEffect responding to showBatteryPrompt
- Intent with ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS
- Collects showBatteryOptimizationPrompt state from viewModel
  </verify>
  <done>
Battery optimization exemption prompted on first channel join (not on app launch per user decision). ViewModel exposes muted state from ChannelRepository. Battery prompt uses system dialog via ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS intent. Service lifecycle already coordinated through ChannelRepository (Plan 03 Task 1).
  </done>
</task>

</tasks>

<verification>
1. ChannelRepository starts ChannelMonitoringService on first joinChannel() call
2. ChannelRepository stops ChannelMonitoringService on leaveChannel() and disconnectAll()
3. Phone call triggers: forceReleasePtt() if transmitting + close consumer for audio pause
4. PttManager.onPttInterrupted wired to TonePlayer.playCallInterruptionBeep()
5. Mute state observed from ChannelMonitoringService.isMutedFlow
6. Mute guard prevents audio consumption when muted
7. Battery optimization check runs after first successful channel join
8. Battery optimization uses system dialog (ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS)
9. All existing ChannelRepository, ViewModel, and Screen functionality preserved
10. Service does NOT start on login or app launch (only on channel join)
</verification>

<success_criteria>
- Monitoring service starts when user joins first channel (persistent notification visible)
- Monitoring service stops when user leaves channel or disconnects
- Phone call immediately pauses audio and force-releases PTT with double beep
- Audio resumes after phone call ends
- Mute from notification silences incoming channel audio
- Battery optimization exemption prompted once on first channel join
- All existing PTT, channel join/leave, and audio functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/07-foreground-service-background-audio/07-03-SUMMARY.md`
</output>
