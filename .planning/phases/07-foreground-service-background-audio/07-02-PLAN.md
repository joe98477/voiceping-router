---
phase: 07-foreground-service-background-audio
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - android/app/src/main/java/com/voiceping/android/data/audio/AudioRouter.kt
  - android/app/src/main/java/com/voiceping/android/data/ptt/PttManager.kt
autonomous: true

must_haves:
  truths:
    - "AudioRouter detects phone calls via audio focus loss and invokes callbacks"
    - "Audio focus uses AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK to duck other apps"
    - "PttManager can force-release PTT during phone call interruption"
    - "Phone call detection works without READ_PHONE_STATE permission"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/data/audio/AudioRouter.kt"
      provides: "Audio focus change listener with phone call detection callbacks"
      contains: "OnAudioFocusChangeListener"
    - path: "android/app/src/main/java/com/voiceping/android/data/ptt/PttManager.kt"
      provides: "Force-release PTT method for phone call interruption"
      contains: "forceReleasePtt"
  key_links:
    - from: "AudioRouter.onAudioFocusChangeListener"
      to: "AudioRouter.onPhoneCallStarted callback"
      via: "AUDIOFOCUS_LOSS_TRANSIENT triggers callback"
      pattern: "AUDIOFOCUS_LOSS_TRANSIENT.*onPhoneCallStarted"
    - from: "AudioRouter.onAudioFocusChangeListener"
      to: "AudioRouter.onPhoneCallEnded callback"
      via: "AUDIOFOCUS_GAIN triggers callback"
      pattern: "AUDIOFOCUS_GAIN.*onPhoneCallEnded"
---

<objective>
Enhance AudioRouter with OnAudioFocusChangeListener for phone call detection and add forceReleasePtt() to PttManager for call interruption handling.

Purpose: Phone calls must immediately pause channel audio and force-release PTT. Using audio focus changes (AUDIOFOCUS_LOSS_TRANSIENT) detects phone calls without requiring the dangerous READ_PHONE_STATE permission. PttManager needs a force-release path distinct from normal release (plays call interruption double beep instead of roger beep).

Output: Enhanced AudioRouter.kt with audio focus listener, enhanced PttManager.kt with forceReleasePtt()
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-foreground-service-background-audio/07-CONTEXT.md
@.planning/phases/07-foreground-service-background-audio/07-RESEARCH.md
@.planning/phases/06-single-channel-ptt-audio/06-02-SUMMARY.md (PttManager structure)
@.planning/phases/06-single-channel-ptt-audio/06-04-SUMMARY.md (callback wiring pattern)

Key existing files to reference:
@android/app/src/main/java/com/voiceping/android/data/audio/AudioRouter.kt (enhance with focus listener)
@android/app/src/main/java/com/voiceping/android/data/ptt/PttManager.kt (add forceReleasePtt)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OnAudioFocusChangeListener to AudioRouter for phone call detection</name>
  <files>android/app/src/main/java/com/voiceping/android/data/audio/AudioRouter.kt</files>
  <action>
Enhance AudioRouter.kt with an OnAudioFocusChangeListener that detects phone calls and provides callbacks for pausing/resuming audio. This replaces the need for READ_PHONE_STATE permission.

**Add callback properties (after `audioFocusRequest` field):**

```kotlin
// Phone call detection callbacks (wired by ChannelRepository in Plan 03)
var onPhoneCallStarted: (() -> Unit)? = null
var onPhoneCallEnded: (() -> Unit)? = null

// Track phone call state
private var isInPhoneCall = false
```

**Create the audio focus change listener (as a private val):**

```kotlin
private val audioFocusChangeListener = AudioManager.OnAudioFocusChangeListener { focusChange ->
    when (focusChange) {
        AudioManager.AUDIOFOCUS_LOSS_TRANSIENT -> {
            // Phone call started (incoming or outgoing)
            // User decision: immediate pause of all channel audio (no fade)
            Log.d(TAG, "Audio focus lost (transient): phone call detected")
            isInPhoneCall = true
            onPhoneCallStarted?.invoke()
        }
        AudioManager.AUDIOFOCUS_GAIN -> {
            if (isInPhoneCall) {
                // Phone call ended â€” resume audio
                // User decision: auto-resume channel audio immediately, no delay
                Log.d(TAG, "Audio focus regained after phone call: resuming")
                isInPhoneCall = false
                onPhoneCallEnded?.invoke()
            } else {
                Log.d(TAG, "Audio focus regained (not from phone call)")
            }
        }
        AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK -> {
            // Another app wants to duck (e.g., navigation prompt)
            // User decision: duck other audio apps, restore volume after
            // System handles ducking automatically on API 26+ when setWillPauseWhenDucked(false)
            Log.d(TAG, "Audio focus: ducking for transient sound")
        }
        AudioManager.AUDIOFOCUS_LOSS -> {
            // Permanent loss (e.g., music app started playing)
            // User decision: duck our audio, don't pause. Radio takes priority but doesn't kill music.
            // Note: With AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK, music apps duck us,
            // but if they request permanent focus, we log it. Audio continues playing.
            Log.d(TAG, "Audio focus lost permanently: another app claimed focus")
        }
    }
}
```

**Modify `requestAudioFocus()`** to register the listener:

Replace the existing `requestAudioFocus()` method. The key change is adding `.setOnAudioFocusChangeListener(audioFocusChangeListener)` and `.setWillPauseWhenDucked(false)` to the AudioFocusRequest builder:

```kotlin
fun requestAudioFocus() {
    val focusRequest = AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)
        .setAudioAttributes(
            AudioAttributes.Builder()
                .setUsage(AudioAttributes.USAGE_VOICE_COMMUNICATION)
                .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                .build()
        )
        .setWillPauseWhenDucked(false) // Enable automatic ducking (API 26+)
        .setOnAudioFocusChangeListener(audioFocusChangeListener)
        .build()

    val result = audioManager.requestAudioFocus(focusRequest)
    if (result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
        Log.d(TAG, "Audio focus granted (with phone call listener)")
        audioFocusRequest = focusRequest
    } else {
        Log.w(TAG, "Audio focus request failed: $result")
    }
}
```

**Add isInPhoneCall() accessor:**

```kotlin
/**
 * Check if currently in a phone call (detected via audio focus loss).
 */
fun isInPhoneCall(): Boolean = isInPhoneCall
```

**Modify `releaseAudioFocus()`** to also reset phone call state:

Add `isInPhoneCall = false` after abandoning focus request.

Keep all existing methods (setEarpieceMode, setSpeakerMode, resetAudioMode) unchanged.
  </action>
  <verify>
Verify AudioRouter.kt contains:
- `OnAudioFocusChangeListener` handling AUDIOFOCUS_LOSS_TRANSIENT, AUDIOFOCUS_GAIN, AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK, AUDIOFOCUS_LOSS
- `onPhoneCallStarted` and `onPhoneCallEnded` callback properties
- `isInPhoneCall` tracking boolean
- `setWillPauseWhenDucked(false)` in requestAudioFocus
- `setOnAudioFocusChangeListener(audioFocusChangeListener)` in requestAudioFocus
- All existing methods preserved (setEarpieceMode, setSpeakerMode, resetAudioMode)
  </verify>
  <done>
AudioRouter detects phone calls via AUDIOFOCUS_LOSS_TRANSIENT and exposes onPhoneCallStarted/onPhoneCallEnded callbacks. Audio focus uses AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK with automatic ducking enabled. No READ_PHONE_STATE permission needed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add forceReleasePtt() to PttManager for phone call interruption</name>
  <files>android/app/src/main/java/com/voiceping/android/data/ptt/PttManager.kt</files>
  <action>
Add a `forceReleasePtt()` method to PttManager that handles the phone call interruption scenario. This is distinct from normal `releasePtt()`:

- Normal release: plays roger beep + release haptic (signals intentional stop)
- Force release: plays call interruption double beep (signals phone call interrupted transmission)

**Add callback for call interruption (after existing callbacks):**

```kotlin
/**
 * Callback for phone call interruption (Plan 07-03 will wire TonePlayer.playCallInterruptionBeep())
 * Distinct from onPttReleased which plays roger beep (intentional stop).
 */
var onPttInterrupted: (() -> Unit)? = null
```

**Add forceReleasePtt() method (after releasePtt()):**

```kotlin
/**
 * Force-release PTT due to phone call interruption.
 *
 * Distinct from normal releasePtt():
 * - Uses onPttInterrupted callback (double beep) instead of onPttReleased (roger beep)
 * - Signals to other users that speaker was interrupted by phone call
 *
 * User decision: "If user was transmitting during call: force-release PTT with
 * a distinct double beep (different from normal roger beep) to signal call
 * interruption to other users"
 */
fun forceReleasePtt() {
    if (_pttState.value !is PttState.Transmitting) {
        Log.d(TAG, "Not transmitting, nothing to force-release")
        return
    }

    Log.d(TAG, "Force-releasing PTT (phone call interruption)")

    // Step 1: Cancel max duration timer if active
    maxDurationJob?.cancel()
    maxDurationJob = null

    // Step 2: Play call interruption beep (distinct from roger beep)
    onPttInterrupted?.invoke()

    // Step 3: Reset state immediately
    _pttState.value = PttState.Idle
    val channelId = currentChannelId
    transmissionStartTime = 0
    currentChannelId = null

    // Step 4: Cleanup on IO thread
    scope.launch {
        try {
            audioCaptureManager.stopCapture()
            mediasoupClient.stopProducing()

            val stopIntent = Intent(context, AudioCaptureService::class.java).apply {
                action = AudioCaptureService.ACTION_STOP
            }
            context.startService(stopIntent)

            channelId?.let {
                signalingClient.send(
                    SignalingType.PTT_STOP,
                    mapOf("channelId" to it)
                )
            }

            Log.d(TAG, "PTT force-released (phone call interruption)")
        } catch (e: Exception) {
            Log.e(TAG, "Error during force PTT release cleanup", e)
        }
    }
}
```

The cleanup logic mirrors releasePtt() but uses `onPttInterrupted` instead of `onPttReleased`. This keeps the two code paths intentionally separate so the correct audio feedback plays in each scenario.
  </action>
  <verify>
Verify PttManager.kt contains:
- `onPttInterrupted: (() -> Unit)?` callback property
- `forceReleasePtt()` method that:
  - Checks for Transmitting state
  - Cancels maxDurationJob
  - Invokes onPttInterrupted (not onPttReleased)
  - Resets state to Idle
  - Cleans up audio capture, mediasoup producer, foreground service
  - Sends PTT_STOP to server
- Existing releasePtt() unchanged (still uses onPttReleased)
  </verify>
  <done>
PttManager has forceReleasePtt() that handles phone call interruption with distinct onPttInterrupted callback (for double beep). Normal releasePtt() unchanged (uses onPttReleased for roger beep). Two separate code paths ensure correct audio feedback for each scenario.
  </done>
</task>

</tasks>

<verification>
1. AudioRouter.kt has OnAudioFocusChangeListener registered in requestAudioFocus()
2. AUDIOFOCUS_LOSS_TRANSIENT triggers onPhoneCallStarted callback
3. AUDIOFOCUS_GAIN triggers onPhoneCallEnded callback (only after phone call)
4. setWillPauseWhenDucked(false) enables automatic ducking
5. PttManager.forceReleasePtt() invokes onPttInterrupted (not onPttReleased)
6. PttManager.releasePtt() unchanged (still invokes onPttReleased)
7. No READ_PHONE_STATE permission needed (audio focus handles phone call detection)
8. All existing AudioRouter methods preserved
9. All existing PttManager methods preserved
</verification>

<success_criteria>
- AudioRouter detects incoming/outgoing phone calls via audio focus changes
- AudioRouter exposes onPhoneCallStarted/onPhoneCallEnded callbacks for ChannelRepository wiring
- PttManager.forceReleasePtt() force-releases PTT with call interruption callback (not roger beep)
- Phone call detection works purely through audio focus (no dangerous permissions)
- Existing AudioRouter and PttManager functionality fully preserved
</success_criteria>

<output>
After completion, create `.planning/phases/07-foreground-service-background-audio/07-02-SUMMARY.md`
</output>
