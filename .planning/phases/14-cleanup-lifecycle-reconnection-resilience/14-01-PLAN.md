---
phase: 14-cleanup-lifecycle-reconnection-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
autonomous: true

must_haves:
  truths:
    - "Transport creation is serialized via Mutex (no duplicate transports during rapid reconnection)"
    - "cleanupChannel() closes consumers for a channel before closing its RecvTransport (correct disposal order)"
    - "createRecvTransport() skips creation if transport already exists for channel (guard check)"
    - "createSendTransport() is Mutex-protected (prevents concurrent creation during network flapping)"
    - "startProducing() has guard check preventing duplicate Producer creation"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt"
      provides: "Mutex-protected transport lifecycle with correct disposal order"
      contains: "transportMutex"
  key_links:
    - from: "MediasoupClient.createSendTransport()"
      to: "transportMutex.withLock"
      via: "Kotlin Mutex wrapping transport creation critical section"
      pattern: "transportMutex\\.withLock"
    - from: "MediasoupClient.cleanupChannel()"
      to: "consumers"
      via: "Close consumers before transport"
      pattern: "consumers.*close.*recvTransports.*close"
---

<objective>
Add Mutex-based concurrency protection and correct disposal ordering to MediasoupClient transport lifecycle.

Purpose: Prevent duplicate transport creation during network flapping and ensure resources are disposed in the correct dependency order (consumers before transports) to avoid native crashes.

Output: MediasoupClient.kt with Mutex-protected `createSendTransport()`, `createRecvTransport()`, `cleanupChannel()`, guard-checked `startProducing()`, and self-contained consumer cleanup in `cleanupChannel()`.
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-cleanup-lifecycle-reconnection-resilience/14-RESEARCH.md
@android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Mutex and protect transport creation methods</name>
  <files>android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt</files>
  <action>
Add Mutex import and field to MediasoupClient:

```kotlin
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
```

Add private field:
```kotlin
private val transportMutex = Mutex()
```

**Modify `createSendTransport()`:**
Wrap the entire body (inside `withContext(Dispatchers.IO)`) with `transportMutex.withLock { ... }`. The existing guard check (`if (sendTransport != null)`) stays inside the lock. This prevents concurrent createSendTransport() calls from creating duplicate transports during network flapping.

**Modify `createRecvTransport(channelId)`:**
Wrap the entire body (inside `withContext(Dispatchers.IO)`) with `transportMutex.withLock { ... }`. Add a guard check at the top of the locked section:
```kotlin
if (recvTransports.containsKey(channelId)) {
    Log.d(TAG, "RecvTransport already exists for channel: $channelId")
    return@withContext
}
```
This prevents duplicate RecvTransport creation when multiple joinChannel() calls fire during rapid reconnection for the same channel.

**Modify `startProducing()`:**
Add a guard check at the beginning (before existing guard) to prevent duplicate Producer creation:
```kotlin
if (audioProducer != null) {
    Log.d(TAG, "Producer already exists, skipping")
    return@withContext
}
```
This prevents rapid PTT press from creating duplicate producers if startProducing() is called twice while the first is still completing.

Use Mutex (not synchronized) because these are suspend functions running in coroutine context. synchronized would block the IO thread, preventing other coroutines from running. Mutex.withLock() suspends the coroutine without blocking the thread.
  </action>
  <verify>
Run `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` — must pass with no errors.
Verify with grep:
- `grep -n "transportMutex" MediasoupClient.kt` — should show Mutex field declaration and withLock usage in createSendTransport, createRecvTransport, and cleanupChannel
- `grep -n "containsKey(channelId)" MediasoupClient.kt` — should show guard check in createRecvTransport
- `grep -n "audioProducer != null" MediasoupClient.kt` — should show guard check in startProducing
  </verify>
  <done>
createSendTransport() and createRecvTransport() are protected by transportMutex.withLock(). createRecvTransport() has guard check preventing duplicate per-channel transport. startProducing() has guard check preventing duplicate Producer. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix cleanupChannel() to close consumers before transport</name>
  <files>android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt</files>
  <action>
**Modify `cleanupChannel(channelId)` method:**

The current implementation only closes the RecvTransport for a channel and relies on the caller (ChannelRepository) to close consumers first. This is fragile — if any caller forgets, consumers are orphaned or crash when trying to access a closed transport.

Make cleanupChannel() self-contained and Mutex-protected. Change the method signature to `suspend fun cleanupChannel(channelId: String)` and rewrite the body:

```kotlin
suspend fun cleanupChannel(channelId: String) {
    transportMutex.withLock {
        Log.d(TAG, "Cleaning up channel: $channelId")

        // Step 1: Close consumers for this channel BEFORE transport
        // CRITICAL: Consumer.close() may access transport reference
        val consumersToRemove = consumers.entries.filter { it.key.startsWith(channelId) }
        consumersToRemove.forEach { (consumerId, consumer) ->
            consumer.close()
            consumers.remove(consumerId)
            Log.d(TAG, "Consumer closed: $consumerId")
        }

        // Step 2: Close RecvTransport AFTER consumers
        recvTransports.remove(channelId)?.let { transport ->
            transport.close()
            Log.d(TAG, "RecvTransport closed for channel: $channelId")
        }
    }
}
```

The key changes:
1. Method is now `suspend fun` (was `fun`) because `transportMutex.withLock` is a suspend call
2. Consumers for the channel are closed BEFORE the transport (prevents null pointer crashes)
3. Protected by transportMutex to prevent race with concurrent transport creation/destruction
4. Self-contained: callers don't need to close consumers first

Note: The consumer key convention uses channelId prefix. Check the consumeAudio() method — consumers are stored by consumerId (not channelId prefix). The consumer-to-channel mapping needs to match. Looking at existing code, consumers map uses `consumerId` as key (from server). ChannelRepository tracks `channelConsumers` map (channelId -> producerId -> consumerId). Since MediasoupClient doesn't have this mapping, iterate ALL consumers and close those whose keys match (or close all if no mapping).

IMPORTANT: Looking at the actual code more carefully — consumers are stored with consumerId as key (e.g., "abc-123-def"), NOT prefixed with channelId. The cleanupChannel() method in MediasoupClient cannot filter by channelId. Instead, accept a list of consumerIds to close:

```kotlin
suspend fun cleanupChannel(channelId: String, consumerIds: List<String> = emptyList()) {
    transportMutex.withLock {
        Log.d(TAG, "Cleaning up channel: $channelId")

        // Step 1: Close specified consumers BEFORE transport
        consumerIds.forEach { consumerId ->
            consumers.remove(consumerId)?.let { consumer ->
                consumer.close()
                Log.d(TAG, "Consumer closed: $consumerId")
            }
        }

        // Step 2: Close RecvTransport AFTER consumers
        recvTransports.remove(channelId)?.let { transport ->
            transport.close()
            Log.d(TAG, "RecvTransport closed for channel: $channelId")
        }
    }
}
```

Then update ChannelRepository.leaveChannel() to pass consumerIds when calling cleanupChannel:

Actually — ChannelRepository already closes consumers before calling cleanupChannel(). The existing pattern works. Instead, keep the original approach but add Mutex protection and make it suspend:

```kotlin
suspend fun cleanupChannel(channelId: String) {
    transportMutex.withLock {
        Log.d(TAG, "Cleaning up channel: $channelId")

        // Close RecvTransport for channel
        // Note: Consumers for this channel should already be closed by caller
        // (ChannelRepository closes consumers before calling this method)
        recvTransports.remove(channelId)?.let { transport ->
            transport.close()
            Log.d(TAG, "RecvTransport closed for channel: $channelId")
        }
    }
}
```

This is the safest approach since ChannelRepository already manages the consumer-to-channel mapping and closes consumers first. The Mutex protection prevents concurrent cleanup/creation races.

Since the method signature changes from `fun` to `suspend fun`, check that all callers in ChannelRepository call it from a coroutine context (they do — `leaveChannel()` is already a suspend function).
  </action>
  <verify>
Run `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` — must pass with no errors.
Verify:
- `grep -n "suspend fun cleanupChannel" MediasoupClient.kt` — confirms suspend signature
- `grep -n "transportMutex.withLock" MediasoupClient.kt` — should appear in cleanupChannel, createSendTransport, createRecvTransport
  </verify>
  <done>
cleanupChannel() is Mutex-protected and uses suspend fun signature. All transport lifecycle methods (create, cleanup) are serialized through transportMutex. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` passes
2. `grep "transportMutex" android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt` shows Mutex field and usage in 3+ methods
3. `grep "containsKey(channelId)" android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt` shows RecvTransport guard check
4. `grep "audioProducer != null" android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt` shows Producer guard check
5. `grep "suspend fun cleanupChannel" android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt` shows suspend signature
</verification>

<success_criteria>
- MediasoupClient.kt compiles with Mutex imports and field
- createSendTransport() wrapped in transportMutex.withLock
- createRecvTransport() wrapped in transportMutex.withLock with guard check
- cleanupChannel() is suspend fun with transportMutex.withLock
- startProducing() has guard check for existing Producer
- Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-cleanup-lifecycle-reconnection-resilience/14-01-SUMMARY.md`
</output>
