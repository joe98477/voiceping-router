---
phase: 14-cleanup-lifecycle-reconnection-resilience
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
  - android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
autonomous: true

must_haves:
  truths:
    - "SendTransport onConnectionStateChange differentiates 'disconnected' (wait for auto-recovery) from 'failed' (cleanup resources)"
    - "RecvTransport onConnectionStateChange differentiates 'disconnected' (wait) from 'failed' (cleanup channel resources)"
    - "SendTransport failure cleans up producer, audio resources, and nulls the transport (next PTT press recreates)"
    - "RecvTransport failure closes consumers for that channel and removes transport from map"
    - "ChannelRepository calls mediasoupClient.cleanup() on full disconnect (already exists, verify wiring)"
  artifacts:
    - path: "android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt"
      provides: "Transport error handlers with auto-recovery window and proper failure cleanup"
      contains: "\"disconnected\""
    - path: "android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt"
      provides: "Connection-aware cleanup that calls mediasoupClient.cleanup() on disconnect"
      contains: "mediasoupClient.cleanup()"
  key_links:
    - from: "MediasoupClient onConnectionStateChange (SendTransport)"
      to: "cleanupAudioResources(), sendTransport = null"
      via: "failed state triggers full producer/transport cleanup"
      pattern: "\"failed\".*audioProducer.*close.*sendTransport.*null"
    - from: "MediasoupClient onConnectionStateChange (RecvTransport)"
      to: "consumers.remove, recvTransports.remove"
      via: "failed state triggers consumer and transport cleanup for channel"
      pattern: "\"failed\".*consumers.*recvTransports"
---

<objective>
Implement Transport connection state error recovery with proper auto-recovery window handling and failure cleanup.

Purpose: Differentiate transient network drops (WebRTC auto-recovers within ~15 seconds) from permanent failures (require manual resource recreation) to prevent unnecessary reconnection churn while ensuring failed transports are cleaned up correctly.

Output: MediasoupClient.kt with proper onConnectionStateChange handlers for both SendTransport and RecvTransport. ChannelRepository.kt verified to call cleanup on disconnection.
</objective>

<execution_context>
@/home/earthworm/.claude/get-shit-done/workflows/execute-plan.md
@/home/earthworm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-cleanup-lifecycle-reconnection-resilience/14-RESEARCH.md
@.planning/phases/14-cleanup-lifecycle-reconnection-resilience/14-01-SUMMARY.md
@android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt
@android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement proper Transport onConnectionStateChange handlers</name>
  <files>android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt</files>
  <action>
**Fix SendTransport onConnectionStateChange handler** in `createSendTransport()`:

The current handler treats "disconnected" and "failed" identically (closes audioProducer on both). This is wrong — "disconnected" means WebRTC is attempting ICE restart and may auto-recover within ~15 seconds. Only "failed" means permanent failure requiring manual cleanup.

Replace the current handler:
```kotlin
// CURRENT (wrong):
if (newState == "failed" || newState == "disconnected") {
    audioProducer?.close()
    audioProducer = null
}
```

With proper state differentiation:
```kotlin
when (newState) {
    "disconnected" -> {
        // ICE connectivity lost — WebRTC will attempt auto-recovery (~15s window)
        // Do NOT cleanup resources yet, transport may reconnect
        Log.w(TAG, "SendTransport disconnected, waiting for auto-recovery")
    }
    "failed" -> {
        // Auto-recovery failed — manual cleanup required
        // Close producer and audio resources, null the transport
        // Next PTT press will recreate SendTransport
        Log.e(TAG, "SendTransport failed, cleaning up producer and transport")
        audioProducer?.close()
        audioProducer = null
        cleanupAudioResources()
        sendTransport = null
    }
    "connected" -> {
        Log.d(TAG, "SendTransport (re)connected")
    }
}
```

Key change: On "failed", also set `sendTransport = null` and call `cleanupAudioResources()`. This ensures next PTT press creates a fresh transport. On "disconnected", do nothing (wait for auto-recovery).

**Fix RecvTransport onConnectionStateChange handler** in `createRecvTransport()`:

The current handler removes the transport from the map on both "disconnected" and "failed":
```kotlin
// CURRENT (wrong):
if (newState == "failed" || newState == "disconnected") {
    recvTransports.remove(channelId)
}
```

Replace with proper state differentiation:
```kotlin
when (newState) {
    "disconnected" -> {
        // ICE connectivity lost — WebRTC will attempt auto-recovery (~15s window)
        // Do NOT remove transport, it may reconnect
        Log.w(TAG, "RecvTransport disconnected, waiting for auto-recovery (channel: $channelId)")
    }
    "failed" -> {
        // Auto-recovery failed — cleanup this channel's resources
        Log.e(TAG, "RecvTransport failed, cleaning up channel: $channelId")

        // Close consumers for this transport (safe: Consumer.close() is idempotent)
        val consumersToRemove = consumers.entries.filter { (_, consumer) ->
            // Consumer doesn't expose transport reference directly,
            // so we remove all consumers associated with this channel.
            // ChannelRepository's channelConsumers map is the source of truth.
            // As safety net, try to close — if consumer already closed (by onTransportClose),
            // close() is idempotent and won't crash.
            true // We'll use a different approach below
        }

        // Actually — we cannot filter consumers by channelId in MediasoupClient
        // because consumers are keyed by consumerId (not channelId).
        // The onTransportClose callback on each Consumer will fire when transport closes,
        // removing consumers from the map (already wired in consumeAudio()).
        // So just remove the transport — Consumer.Listener.onTransportClose will handle consumer cleanup.
        recvTransports.remove(channelId)
    }
    "connected" -> {
        Log.d(TAG, "RecvTransport (re)connected: $channelId")
    }
}
```

Wait — reviewing the Consumer.Listener in consumeAudio():
```kotlin
override fun onTransportClose(consumer: Consumer) {
    Log.d(TAG, "Consumer transport closed: $consumerId")
    consumers.remove(consumerId)
}
```

The onTransportClose listener already removes consumers from the map when transport closes. So in the RecvTransport "failed" handler, we just need to remove and close the transport — consumers will be cleaned up by their onTransportClose callbacks.

Final RecvTransport handler:
```kotlin
when (newState) {
    "disconnected" -> {
        Log.w(TAG, "RecvTransport disconnected, waiting for auto-recovery (channel: $channelId)")
    }
    "failed" -> {
        Log.e(TAG, "RecvTransport failed, cleaning up channel: $channelId")
        // Remove transport — Consumer.onTransportClose will clean up consumers
        recvTransports.remove(channelId)
    }
    "connected" -> {
        Log.d(TAG, "RecvTransport (re)connected: $channelId")
    }
}
```

This is correct because:
1. Transport.close() is NOT called here (transport already in "failed" state, close() would be redundant)
2. Consumer.Listener.onTransportClose fires automatically when transport enters failed state, removing consumers from the map
3. On "disconnected", we wait for auto-recovery (no cleanup)
  </action>
  <verify>
Run `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` — must pass with no errors.
Verify with grep:
- `grep -n "disconnected" MediasoupClient.kt` — should show "waiting for auto-recovery" log messages (not resource cleanup)
- `grep -n '"failed"' MediasoupClient.kt` — should show cleanup logic for both send and recv transports
- `grep -n "sendTransport = null" MediasoupClient.kt` — should appear in the "failed" handler for SendTransport
  </verify>
  <done>
SendTransport and RecvTransport onConnectionStateChange handlers properly differentiate "disconnected" (wait for auto-recovery) from "failed" (cleanup resources). SendTransport failure cleans up producer, audio resources, and nulls transport. RecvTransport failure removes transport from map (consumers cleaned via onTransportClose). Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify and strengthen ChannelRepository disconnect cleanup</name>
  <files>android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt</files>
  <action>
**Verify existing cleanup wiring in ChannelRepository:**

Review the current disconnect handling in ChannelRepository:
1. `disconnectAll()` — calls `leaveChannel()` for each channel, which calls `mediasoupClient.cleanup()` on last channel leave. This is correct.
2. `leaveChannel()` — closes consumers, then calls `mediasoupClient.cleanupChannel()`, then calls `mediasoupClient.cleanup()` if last channel. This is correct.
3. Connection state observer — calls `rejoinAllMonitoredChannels()` after extended disconnect (30+s). This is correct for signaling reconnection.

**Add mediasoup cleanup on signaling disconnection:**

Currently, when signaling connection drops (DISCONNECTED state), ChannelRepository only tracks timing and plays tones. It does NOT clean up mediasoup resources. This is partially correct (transports have their own connection state), but when a FULL signaling disconnect happens, transport connection states become meaningless because the server may have already cleaned up its side.

Add cleanup in the connection state observer. When transitioning to DISCONNECTED (not RECONNECTING), call mediasoupClient.cleanup() to prevent orphaned resources:

In the `scope.launch { signalingClient.connectionState.collect { ... } }` block, add handling for DISCONNECTED state:

```kotlin
// Handle transition to DISCONNECTED (full connection loss)
if (currentState == com.voiceping.android.domain.model.ConnectionState.DISCONNECTED &&
    prevState != com.voiceping.android.domain.model.ConnectionState.DISCONNECTED) {
    Log.d(TAG, "Signaling disconnected, cleaning up mediasoup resources")
    mediasoupClient.cleanup()
}
```

Place this AFTER the existing RECONNECTING handling block. This ensures that if the connection fully drops (goes to DISCONNECTED state rather than RECONNECTING), mediasoup resources are cleaned up. The resources will be recreated when channels are rejoined after reconnection.

Note: RECONNECTING state means SignalingClient is still trying (exponential backoff from Phase 10). In this state, we do NOT cleanup mediasoup because the transports have independent connection state and may still be working (transport ICE connection is separate from WebSocket signaling). Only on full DISCONNECTED do we cleanup.

Also note: `mediasoupClient.cleanupChannel()` is now a suspend function (changed in Plan 14-01). Verify that the call in `leaveChannel()` compiles correctly — it should, since `leaveChannel()` is already a suspend function.
  </action>
  <verify>
Run `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` — must pass with no errors.
Verify with grep:
- `grep -n "DISCONNECTED.*cleanup" ChannelRepository.kt` — should show cleanup call on disconnect
- `grep -n "mediasoupClient.cleanup()" ChannelRepository.kt` — should appear in leaveChannel (last channel), disconnectAll (via leaveChannel), and connection state observer (DISCONNECTED)
  </verify>
  <done>
ChannelRepository cleans up mediasoup resources on signaling DISCONNECTED state. leaveChannel() calls suspend cleanupChannel() correctly. Full disconnect triggers mediasoupClient.cleanup() to prevent orphaned resources. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `cd /home/earthworm/Github-repos/voiceping-router/android && ./gradlew compileDebugKotlin` passes
2. `grep '"disconnected"' android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt` shows auto-recovery wait (no cleanup)
3. `grep '"failed"' android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt` shows proper cleanup for both transport types
4. `grep "sendTransport = null" android/app/src/main/java/com/voiceping/android/data/network/MediasoupClient.kt` appears in "failed" handler
5. `grep "mediasoupClient.cleanup()" android/app/src/main/java/com/voiceping/android/data/repository/ChannelRepository.kt` appears in DISCONNECTED handler
</verification>

<success_criteria>
- SendTransport "disconnected" handler logs warning and waits (no cleanup)
- SendTransport "failed" handler closes producer, cleans audio resources, nulls transport
- RecvTransport "disconnected" handler logs warning and waits (no cleanup)
- RecvTransport "failed" handler removes transport from map (consumer cleanup via onTransportClose)
- ChannelRepository cleans up mediasoup on signaling DISCONNECTED state
- Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-cleanup-lifecycle-reconnection-resilience/14-02-SUMMARY.md`
</output>
