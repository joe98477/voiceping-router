---
phase: 02-user-management-access-control
plan: 08
type: execute
wave: 5
depends_on: ["02-07"]
files_modified:
  - src/server/test/loadTest.ts
  - src/client/test/e2e-phase2.ts
  - docker-compose.yml
  - src/server/index.ts
autonomous: false

must_haves:
  truths:
    - "System handles 100 concurrent WebSocket connections without degradation"
    - "Permission checks do not add measurable latency to channel join"
    - "Dispatch priority PTT interrupts General user within 100ms"
    - "Emergency broadcast reaches all channels within 500ms"
    - "Rate limiting correctly slows repeated failures without blocking legitimate users"
    - "All Phase 2 success criteria verified"
  artifacts:
    - path: "src/server/test/loadTest.ts"
      provides: "Load test script for 100 concurrent users"
    - path: "src/client/test/e2e-phase2.ts"
      provides: "End-to-end test page for Phase 2 features"
  key_links:
    - from: "src/server/test/loadTest.ts"
      to: "src/server/signaling/websocketServer.ts"
      via: "WebSocket connections with JWT auth"
      pattern: "new WebSocket.*ws"
    - from: "src/client/test/e2e-phase2.ts"
      to: "src/shared/protocol.ts"
      via: "All Phase 2 signaling message types"
      pattern: "SignalingType\\."
---

<objective>
Create load testing scripts for 100 concurrent users, build an end-to-end test page for Phase 2 features (permission checks, dispatch priority, emergency broadcast, force-disconnect), and verify all Phase 2 success criteria. This is the final verification plan.

Purpose: Validate that the entire Phase 2 system works under load and all success criteria are met before declaring the phase complete.
Output: Load test scripts, E2E test page, verified success criteria.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-user-management-access-control/02-CONTEXT.md
@.planning/phases/02-user-management-access-control/02-07-SUMMARY.md
@src/server/index.ts
@src/server/config.ts
@src/shared/protocol.ts
@src/shared/types.ts
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create load test script for 100 concurrent users</name>
  <files>
    src/server/test/loadTest.ts
  </files>
  <action>
Create src/server/test/loadTest.ts that simulates 100 concurrent users connecting to the WebSocket server.

**Load Test Script:**

1. **JWT token generation:** Create a helper function that generates valid JWT tokens for test users. Use the same ROUTER_JWT_SECRET from config. Generate tokens with:
   - userId: `test-user-{N}` (N = 1 to 100)
   - userName: `Test User {N}`
   - eventId: `test-event-1`
   - role: Mix of roles (80 GENERAL, 15 DISPATCH, 5 ADMIN per the realistic distribution)
   - channelIds: Assign users to channels (10 channels, ~10 users each)

2. **Redis seed for test data (critical -- simulates control-plane state):**

Before the test, seed Redis with the user-channel mappings that match the JWT claims. Without this, permission checks will fail because there is no control-plane running during tests.

```typescript
import { createClient } from 'redis';

async function seedRedisTestData(redisClient: RedisClientType) {
  // Clear any existing test data
  const testKeys = await redisClient.keys('test-*');
  if (testKeys.length > 0) await redisClient.del(testKeys);

  // Seed user-channel mappings using control-plane key patterns
  // Pattern: u.{userId}.g -> SET of channelIds (user's assigned channels)
  // Pattern: g.{channelId}.u -> SET of userIds (channel's assigned users)
  for (let i = 1; i <= 100; i++) {
    const userId = `test-user-${i}`;
    const assignedChannels = getAssignedChannels(i); // Returns array of channelIds

    // User -> channels mapping
    await redisClient.sAdd(`u.${userId}.g`, assignedChannels);

    // Channel -> users reverse mapping
    for (const channelId of assignedChannels) {
      await redisClient.sAdd(`g.${channelId}.u`, userId);
    }
  }

  // Seed event -> channels mapping
  const allChannels = Array.from({ length: 10 }, (_, i) => `test-channel-${i + 1}`);
  await redisClient.sAdd('e.test-event-1.g', allChannels);

  console.log('Redis test data seeded: 100 users, 10 channels, 1 event');
}
```

This ensures the load test is self-contained and does not require a running control-plane. Call `seedRedisTestData` at the start of the test, and add a cleanup function that removes all test keys after the test completes.

3. **Test phases:**
   a. **Connection phase:** Connect all 100 users over 10 seconds (10 per second ramp-up to avoid thundering herd). Measure connection time, success rate.
   b. **Channel join phase:** Each user joins their assigned channels. Measure join latency, permission check overhead.
   c. **PTT load phase:** Simulate PTT activity -- 10% of users start PTT simultaneously across different channels. Measure lock acquisition time.
   d. **Dispatch priority phase:** One Dispatch user uses priority PTT to interrupt a General user. Measure interrupt latency.
   e. **Permission revocation phase:** Revoke 5 users' channel access via Redis (remove from `u.{userId}.g` and `g.{channelId}.u` sets, simulating control-plane action) and verify they're removed within 30 seconds (heartbeat interval).
   f. **Disconnect phase:** Gracefully disconnect all users. Measure cleanup time.

4. **Metrics collection:**
   - Connection success rate (target: 100%)
   - Average connection time (target: < 500ms)
   - Average channel join time (target: < 200ms)
   - Average PTT lock acquisition time (target: < 50ms)
   - Dispatch priority interrupt time (target: < 100ms)
   - Memory usage before/after connections
   - Redis operation count

5. **Output:** Print test results to console in a clear table format. Include PASS/FAIL for each metric.

6. **Run command:** Add a script to package.json: `"test:load": "npx tsx src/server/test/loadTest.ts"`

The script should be runnable standalone: `npm run test:load` assumes the server is already running on localhost:3000 and Redis is accessible.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify the script file exists and can be parsed. Run `npm run test:load` against a running server to execute the test (requires Docker environment running).
  </verify>
  <done>
Load test script simulates 100 concurrent users with realistic role distribution. Seeds Redis with test user-channel mappings before test (no control-plane needed). Cleans up test data after completion. Tests connection, channel join, PTT, dispatch priority, permission revocation. Collects metrics and reports PASS/FAIL. Runnable via npm run test:load.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create E2E test page for Phase 2 feature verification</name>
  <files>
    src/client/test/e2e-phase2.ts
  </files>
  <action>
Create src/client/test/e2e-phase2.ts -- a browser-based test page (similar to Phase 1's test demo page) that allows manual verification of all Phase 2 features.

**Test Page Layout:**

Three panels side by side:
- Panel 1: Admin User (global admin role)
- Panel 2: Dispatch User (dispatch role in test event)
- Panel 3: General User (general role in test event)

Each panel has:
- Connection status indicator (connected/disconnected)
- Role badge (ADMIN/DISPATCH/GENERAL)
- Channel list showing authorized channels with join/leave buttons
- PTT button (for channels they've joined)
- Status log (scrolling text area showing all signaling messages)

**Dispatch Panel extras:**
- Priority PTT button (distinct from regular PTT)
- Emergency Broadcast button (with visual 2-second hold indicator)
- Force Disconnect button (select target user from dropdown of connected users)

**Admin Panel extras:**
- Force Disconnect button
- Ban/Unban user controls

**Test Scenarios to verify manually:**

1. **Permission enforcement:** General user tries to join a channel they're not assigned to -- should fail
2. **Channel join:** General user joins an authorized channel -- should succeed
3. **PTT:** General user PTTs on joined channel -- should work
4. **Dispatch priority:** Dispatch user uses priority PTT while General is transmitting -- General should be interrupted
5. **Emergency broadcast:** Dispatch user holds emergency broadcast button for 2+ seconds -- should transmit to all channels
6. **Force disconnect:** Dispatch force-disconnects General user -- should immediately disconnect
7. **Permission revocation:** Remove General user's channel access (via separate Redis command) -- user should be removed within 30s
8. **Rate limiting:** Connect rapidly (>20 times/minute) -- should see progressive slowdown

**Token generation:** Include a simple form to generate JWT tokens with configurable userId, role, eventId, and channelIds. Use the existing token generation pattern from Phase 1's test page.

**Redis seed button:** Add a "Seed Test Data" button that calls a dev-only API endpoint (e.g., POST /dev/seed-test-data) which runs the same Redis seeding logic from the load test script. This ensures the E2E test page can set up its own test state without requiring manual Redis commands. The endpoint should:
- Create 3 test users (admin-1, dispatch-1, general-1) with appropriate roles
- Assign them to test channels (test-channel-1 through test-channel-5)
- Assign general-1 to only test-channel-1 and test-channel-2 (so permission denial can be tested on test-channel-3+)
- Return the created user/channel mappings for display in the UI

Build with esbuild (same pattern as Phase 1's test page): add a build script for the test bundle.

Serve the test page only in development mode (NODE_ENV !== 'production'), at path /test/phase2.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Run the esbuild bundle command to verify the browser bundle builds. Start the server and visit https://localhost/test/phase2 to verify the page loads.
  </verify>
  <done>
E2E test page with Admin, Dispatch, and General user panels. Each panel has connection controls, channel list, PTT, and role-specific actions. Dispatch has priority PTT, emergency broadcast, force-disconnect. Admin has force-disconnect and ban/unban. "Seed Test Data" button sets up Redis state for testing without a running control-plane. Status logs show all signaling messages. Test page served at /test/phase2 in dev mode only.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 2: User Management and Access Control system including:
- Permission-checked channel join (General users restricted to assigned channels)
- Heartbeat-based permission refresh every 30 seconds
- Real-time permission sync via Redis pub/sub
- Dispatch PTT priority interrupt with interrupted user notification
- Emergency broadcast (2-second hold, all-channel override)
- Force-disconnect for Dispatch and Admin
- Ban/unban user management
- Progressive rate limiting (no hard lockout)
- Full audit logging
- Server-side jitter buffer configuration
- Worker pool optimization for 1000+ users
- 100 concurrent user load test
  </what-built>
  <how-to-verify>
**Setup (no control-plane needed):**
1. Start the Docker environment: `docker-compose up --build`
2. Visit https://localhost/test/phase2
3. Click "Seed Test Data" to populate Redis with test users and channel assignments

**Test permission enforcement:**
4. Connect as General user (general-1) with channelIds=['test-channel-1', 'test-channel-2']
5. Try to join 'test-channel-3' -- should fail with "Not authorized"
6. Join 'test-channel-1' -- should succeed

**Test Dispatch priority:**
7. Connect General user and start PTT on test-channel-1
8. Connect Dispatch user and use Priority PTT on test-channel-1
9. General user should be interrupted, Dispatch should be speaking
10. General panel should show "Dispatch [name] has priority"

**Test emergency broadcast:**
11. Connect Dispatch user
12. Hold Emergency Broadcast button for 2+ seconds
13. All channels should show Dispatch as speaker
14. Short press (< 2s) should be rejected

**Test force-disconnect:**
15. Connect General user
16. As Dispatch, force-disconnect the General user
17. General user should immediately disconnect

**Test load:**
18. Run `npm run test:load` (seeds its own Redis data)
19. All 100 connections should succeed
20. Metrics should show PASS for all targets

**Verify all Phase 2 success criteria:**
Note: Criteria 1-3 below involve control-plane operations (create events, create channels, assign users). These are verified indirectly: the load test seeds Redis with the equivalent state, and the router correctly enforces it. Full control-plane integration testing is deferred to when the control-plane is built.

- [ ] Admin user can create events and assign users to roles (verified via Redis seed -- router reads role from JWT)
- [ ] Dispatch user can create teams/channels within assigned events (verified via Redis seed -- router reads channel assignments from Redis)
- [ ] Dispatch user can assign/remove users from channels (verified via Redis revocation in load test -- router detects and enforces within 30s)
- [ ] General user can only PTT on assigned channels (permission check at join -- tested directly)
- [ ] Authorization checked before channel access (permission manager -- tested directly)
- [ ] 100 concurrent users handled successfully (load test -- tested directly)
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Phase 2 Success Criteria from ROADMAP.md:
1. Admin user can create events and assign users to Admin, Dispatch, or General roles -- verified via Redis-seeded JWT claims
2. Dispatch user can create teams and channels within assigned events only -- verified via Redis-seeded channel state
3. Dispatch user can assign and remove users from channels -- verified via Redis revocation in load test
4. General user can only PTT on channels they are assigned to -- verified directly
5. User authorization is checked before granting channel access -- verified directly
6. System successfully handles 100 concurrent users in testing environment -- verified via load test
</verification>

<success_criteria>
- 100 concurrent WebSocket connections sustained without errors
- Permission enforcement blocks unauthorized channel access
- Dispatch priority interrupt completes within 100ms
- Emergency broadcast reaches all channels within 500ms
- Rate limiting slows attackers without blocking legitimate users
- All 6 Phase 2 success criteria verified by human tester (criteria 1-3 via Redis seed, criteria 4-6 directly)
</success_criteria>

<output>
After completion, create `.planning/phases/02-user-management-access-control/02-08-SUMMARY.md`
</output>
