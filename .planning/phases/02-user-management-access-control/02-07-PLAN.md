---
phase: 02-user-management-access-control
plan: 07
type: execute
wave: 4
depends_on: ["02-03", "02-04", "02-05", "02-06"]
files_modified:
  - src/server/index.ts
  - src/server/signaling/websocketServer.ts
  - src/server/signaling/handlers.ts
  - src/shared/protocol.ts
autonomous: true

must_haves:
  truths:
    - "All Phase 2 modules are wired together in the server entry point"
    - "New signaling message types are routed to correct handlers"
    - "Permission sync pushes real-time updates to connected clients"
    - "Ban check happens on WebSocket connection"
    - "Server starts cleanly with all Phase 2 modules initialized"
    - "Graceful shutdown cleans up all Phase 2 resources"
  artifacts:
    - path: "src/server/index.ts"
      provides: "Updated server entry point wiring all Phase 2 modules"
    - path: "src/server/signaling/websocketServer.ts"
      provides: "Updated routing for all new signaling message types, disconnectUser method"
  key_links:
    - from: "src/server/index.ts"
      to: "src/server/auth/permissionManager.ts"
      via: "Instantiation and injection into signaling server"
      pattern: "new PermissionManager"
    - from: "src/server/index.ts"
      to: "src/server/state/permissionSync.ts"
      via: "Start permission sync with callback to push updates"
      pattern: "permissionSyncManager\\.start"
    - from: "src/server/signaling/websocketServer.ts"
      to: "src/server/signaling/handlers.ts"
      via: "Route new message types through switch statement"
      pattern: "case SignalingType\\.(PRIORITY_PTT|EMERGENCY_BROADCAST|FORCE_DISCONNECT)"
---

<objective>
Wire all Phase 2 modules together: update the server entry point (index.ts) to instantiate and inject PermissionManager, AuditLogger, RateLimiter, SecurityEventsManager, DispatchHandlers, AdminHandlers, and PermissionSyncManager. Update the WebSocket server's message router to handle all new signaling types. Add disconnectUser method. Connect PermissionSyncManager's callback to push real-time permission updates to connected clients.

Purpose: This is the integration plan that connects all independently-built modules into a working system. Without this wiring, the modules exist but don't function together.
Output: Fully wired server with all Phase 2 capabilities active.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-user-management-access-control/02-CONTEXT.md
@.planning/phases/02-user-management-access-control/02-03-SUMMARY.md
@.planning/phases/02-user-management-access-control/02-04-SUMMARY.md
@.planning/phases/02-user-management-access-control/02-05-SUMMARY.md
@.planning/phases/02-user-management-access-control/02-06-SUMMARY.md
@src/server/index.ts
@src/server/signaling/websocketServer.ts
@src/server/signaling/handlers.ts
@src/server/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update server entry point to wire all Phase 2 modules</name>
  <files>
    src/server/index.ts
  </files>
  <action>
Read the existing src/server/index.ts to understand current module instantiation order. Then modify it to wire Phase 2 modules.

Add these imports:
```typescript
import { PermissionManager } from './auth/permissionManager';
import { AuditLogger } from './auth/auditLogger';
import { RateLimiter } from './auth/rateLimiter';
import { SecurityEventsManager } from './auth/securityEvents';
import { DispatchHandlers } from './signaling/dispatchHandlers';
import { AdminHandlers } from './signaling/adminHandlers';
import { PermissionSyncManager } from './state/permissionSync';
```

In the server initialization sequence (after Redis is connected, before WebSocket server starts):

1. Create PermissionManager: `const permissionManager = new PermissionManager();`
2. Create AuditLogger: `const auditLogger = new AuditLogger();`
3. Create RateLimiter: `const rateLimiter = new RateLimiter();`
4. Create SecurityEventsManager: `const securityEventsManager = new SecurityEventsManager(auditLogger);`

After SignalingServer is created (need the broadcastToChannel and sendToUser callbacks):

5. Create DispatchHandlers with all dependencies
6. Create AdminHandlers with disconnectUser callback from signalingServer
7. Pass all new modules to SignalingHandlers constructor
8. Pass PermissionManager, AuditLogger, RateLimiter, SecurityEventsManager to SignalingServer constructor

9. Create PermissionSyncManager with callback:
```typescript
const permissionSyncManager = new PermissionSyncManager((userId, eventId, newChannelIds, action) => {
  // Find connected client by userId and push PERMISSION_UPDATE
  signalingServer.pushPermissionUpdate(userId, newChannelIds, action);
});
await permissionSyncManager.start();
```

10. Update graceful shutdown to also stop permissionSyncManager and log pool status.

Note: The exact instantiation order depends on what the current index.ts does. Read it first, then integrate Phase 2 modules following the existing patterns. The key constraint is Redis must be connected before any module that uses Redis is instantiated.

Log at startup: "Phase 2 modules initialized: PermissionManager, AuditLogger, RateLimiter, SecurityEvents, PermissionSync"
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Then run `npm run build` (or equivalent) to verify the full build succeeds. Check that index.ts imports all Phase 2 modules and creates instances.
  </verify>
  <done>
Server entry point instantiates and wires all Phase 2 modules: PermissionManager, AuditLogger, RateLimiter, SecurityEventsManager, DispatchHandlers, AdminHandlers, PermissionSyncManager. Graceful shutdown stops all new modules. Startup logs confirm initialization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Complete message routing and add integration methods to WebSocket server</name>
  <files>
    src/server/signaling/websocketServer.ts
    src/shared/protocol.ts
  </files>
  <action>
**Update websocketServer.ts routeMessage():**

Add cases to the switch statement in routeMessage() for all new Phase 2 signaling types:

```typescript
case SignalingType.PRIORITY_PTT_START:
  await this.handlers.handlePriorityPttStart(ctx, message);
  break;

case SignalingType.PRIORITY_PTT_STOP:
  await this.handlers.handlePriorityPttStop(ctx, message);
  break;

case SignalingType.EMERGENCY_BROADCAST_START:
  await this.handlers.handleEmergencyBroadcastStart(ctx, message);
  break;

case SignalingType.EMERGENCY_BROADCAST_STOP:
  await this.handlers.handleEmergencyBroadcastStop(ctx, message);
  break;

case SignalingType.FORCE_DISCONNECT:
  await this.handlers.handleForceDisconnect(ctx, message);
  break;
```

Note: BAN_USER and UNBAN_USER are admin operations that may come via signaling or REST API. Add them as signaling types if not already present in protocol.ts:
- Add BAN_USER = 'ban-user' and UNBAN_USER = 'unban-user' to SignalingType enum in protocol.ts
- Add routing cases for them

**Add disconnectUser() public method:**
```typescript
disconnectUser(targetUserId: string, reason: string): boolean {
  for (const [connectionId, ctx] of this.clients.entries()) {
    if (ctx.userId === targetUserId) {
      // Send force-disconnect notification before closing
      this.sendToClient(ctx.ws, createMessage(SignalingType.FORCE_DISCONNECT, { reason }));
      // Use code 4003 for forced disconnect (custom WebSocket close code)
      ctx.ws.close(4003, reason);
      return true;
    }
  }
  return false;
}
```

**Add sendToUser() public method:**
```typescript
sendToUser(targetUserId: string, message: SignalingMessage): boolean {
  for (const ctx of this.clients.values()) {
    if (ctx.userId === targetUserId) {
      this.sendToClient(ctx.ws, message);
      return true;
    }
  }
  return false;
}
```

**Add pushPermissionUpdate() public method:**
```typescript
pushPermissionUpdate(userId: string, newChannelIds: string[], action: string): void {
  for (const ctx of this.clients.values()) {
    if (ctx.userId === userId) {
      // Update client's authorized channels
      ctx.authorizedChannels = new Set(newChannelIds);

      // Push update to client
      this.sendToClient(ctx.ws, createMessage(SignalingType.PERMISSION_UPDATE, {
        channelIds: newChannelIds,
        action,
      }));

      logger.info(`Permission update pushed to ${userId}: ${action} (${newChannelIds.length} channels)`);
    }
  }
}
```

**Add ban check to verifyClient():**
After JWT verification succeeds and before calling callback(true), add:
```typescript
const isBanned = await this.securityEventsManager.checkBanOnConnect(decoded.userId);
if (isBanned) {
  logger.warn(`Connection rejected: User ${decoded.userId} is banned`);
  callback(false, 403, 'Account is suspended');
  return;
}
```

This requires SecurityEventsManager to be injected into SignalingServer constructor. Update constructor to accept it.

**Update protocol.ts if needed:**
Ensure BAN_USER and UNBAN_USER are in the SignalingType enum. If they were not added in Plan 01's protocol extension, add them now.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify all new SignalingType cases are in routeMessage switch. Verify disconnectUser, sendToUser, pushPermissionUpdate methods exist. Verify ban check in verifyClient.

Then start the server to verify runtime initialization succeeds:
```bash
# Start the server (use timeout to auto-kill after 10s)
timeout 10 npx tsx src/server/index.ts 2>&1 || true
```
Check the output for:
- "Phase 2 modules initialized" log line (confirms all modules wired)
- No unhandled errors or missing dependency exceptions
- No "Cannot find module" or "is not a constructor" errors

If the server requires Redis/mediasoup to be running (likely), use `npx tsc --noEmit` as primary check and verify that all import paths resolve and all constructor calls match their class signatures by inspecting the compiled output.
  </verify>
  <done>
WebSocket server routes all Phase 2 message types. disconnectUser terminates target connections. sendToUser delivers messages to specific users. pushPermissionUpdate pushes real-time channel changes. Ban check blocks suspended users on connect. All new SignalingType values handled. Server startup verified (either via runtime start or constructor signature validation). TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Server starts with all Phase 2 modules initialized (check startup log or validate constructor wiring)
3. All new SignalingType values have routing cases
4. Permission sync callback pushes updates to connected clients
5. Force-disconnect terminates target user's connection
6. Ban check blocks suspended users at WebSocket auth
7. Graceful shutdown stops all Phase 2 modules
</verification>

<success_criteria>
- Server starts cleanly with all Phase 2 modules wired together
- All signaling message types route to correct handlers
- Real-time permission sync delivers updates within seconds
- Force-disconnect works via signaling message
- Banned users cannot establish WebSocket connections
- Graceful shutdown properly tears down all new resources
</success_criteria>

<output>
After completion, create `.planning/phases/02-user-management-access-control/02-07-SUMMARY.md`
</output>
