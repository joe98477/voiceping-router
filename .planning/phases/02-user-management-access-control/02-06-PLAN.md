---
phase: 02-user-management-access-control
plan: 06
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - src/server/signaling/adminHandlers.ts
  - src/server/auth/securityEvents.ts
  - src/server/signaling/handlers.ts
autonomous: true

must_haves:
  truths:
    - "Dispatch and Admin can force-disconnect a user immediately from a channel"
    - "Force-disconnect bypasses graceful removal (no waiting for PTT to finish)"
    - "Security events are stored and queryable via API endpoints"
    - "Rate limiting data is persisted for security review"
    - "Ban/unban API endpoints exist for managing disruptive users"
  artifacts:
    - path: "src/server/signaling/adminHandlers.ts"
      provides: "Force-disconnect handler for Admin and Dispatch roles"
      exports: ["AdminHandlers"]
    - path: "src/server/auth/securityEvents.ts"
      provides: "Security events storage, ban/unban management, rate limit data access"
      exports: ["SecurityEventsManager"]
  key_links:
    - from: "src/server/signaling/adminHandlers.ts"
      to: "src/server/signaling/websocketServer.ts"
      via: "Find and terminate target user's WebSocket connection"
      pattern: "disconnectUser"
    - from: "src/server/auth/securityEvents.ts"
      to: "src/server/state/redisClient.ts"
      via: "Redis storage for security events and ban list"
      pattern: "getRedisClient"
    - from: "src/server/auth/securityEvents.ts"
      to: "src/server/auth/auditLogger.ts"
      via: "Audit logging for ban/unban actions"
      pattern: "auditLogger\\.log"
---

<objective>
Implement force-disconnect capability for Dispatch and Admin (instantly removes a user, bypassing graceful removal), and create the security events backend: ban/unban management, rate limiting data persistence, and security event querying. The UI for security events is deferred to Phase 3; this plan builds the backend/API.

Purpose: Force-disconnect handles malicious/disruptive transmissions. Security events backend enables Dispatch and Admin to review incidents and manage bans. These are critical operational security features.
Output: AdminHandlers class, SecurityEventsManager class.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-user-management-access-control/02-CONTEXT.md
@.planning/phases/02-user-management-access-control/02-03-SUMMARY.md
@src/server/signaling/handlers.ts
@src/server/signaling/websocketServer.ts
@src/server/auth/auditLogger.ts
@src/server/auth/rateLimiter.ts
@src/server/state/redisClient.ts
@src/shared/protocol.ts
@src/shared/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AdminHandlers for force-disconnect</name>
  <files>
    src/server/signaling/adminHandlers.ts
  </files>
  <action>
Create src/server/signaling/adminHandlers.ts implementing Admin and Dispatch operational controls.

Per user decision: "Dispatch and Admin can force-disconnect a user immediately (bypasses graceful removal for malicious/disruptive transmissions)."

**AdminHandlers class:**

Constructor accepts: AuditLogger, a `disconnectUser(userId: string, reason: string) -> boolean` callback function (provided by websocketServer.ts to terminate a user's connection), and SecurityEventsManager.

**1. handleForceDisconnect(ctx: ClientContext, message: SignalingMessage):**

- Validate ctx.role is DISPATCH or ADMIN (General users cannot force-disconnect)
- Extract targetUserId from message.data.targetUserId
- Extract reason from message.data.reason (optional, defaults to "Force disconnected by admin")
- Prevent self-disconnect: if targetUserId === ctx.userId, reject with error
- Call disconnectUser callback to immediately terminate the target user's WebSocket connection
- This triggers the existing handleDisconnect cleanup (releases speaker locks, removes from channels, cleans up transports)
- Send FORCE_DISCONNECT notification to the target user BEFORE closing their connection: `{ reason, disconnectedBy: ctx.userName, role: ctx.role }`
- Audit log: AuditAction.FORCE_DISCONNECT with actorId=ctx.userId, targetId=targetUserId, metadata including reason and actor role
- Send success response to the requesting admin/dispatch user

The disconnectUser callback should be implemented in websocketServer.ts (added as a public method in Plan 07 integration):
```typescript
disconnectUser(targetUserId: string, reason: string): boolean {
  for (const [connectionId, ctx] of this.clients.entries()) {
    if (ctx.userId === targetUserId) {
      // Send force-disconnect notification before closing
      this.sendToClient(ctx.ws, createMessage(SignalingType.FORCE_DISCONNECT, { reason }));
      ctx.ws.close(4003, reason);
      return true;
    }
  }
  return false; // User not connected
}
```

**2. handleBanUser(ctx: ClientContext, message: SignalingMessage):**
- Validate ctx.role is DISPATCH or ADMIN
- Extract targetUserId and duration (optional, default permanent) from message.data
- Call securityEventsManager.banUser(targetUserId, ctx.userId, duration, reason)
- Force-disconnect the banned user if currently connected
- Audit log: AuditAction.SECURITY_BAN

**3. handleUnbanUser(ctx: ClientContext, message: SignalingMessage):**
- Validate ctx.role is DISPATCH or ADMIN
- Extract targetUserId from message.data
- Call securityEventsManager.unbanUser(targetUserId, ctx.userId)
- Audit log: AuditAction.SECURITY_UNBAN

Use createLogger('AdminHandlers') for logging.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify AdminHandlers exports with handleForceDisconnect, handleBanUser, handleUnbanUser methods. Verify force-disconnect checks role is DISPATCH or ADMIN. Verify self-disconnect is prevented.
  </verify>
  <done>
AdminHandlers class exists with force-disconnect (immediate, bypasses graceful removal), ban/unban user management. Only DISPATCH and ADMIN can use these. Self-disconnect prevented. Audit trail for all actions. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SecurityEventsManager for ban/unban and security data persistence</name>
  <files>
    src/server/auth/securityEvents.ts
  </files>
  <action>
Create src/server/auth/securityEvents.ts managing security state and events.

Per user decision: "Security events backend in Phase 2: rate limiting data storage, ban/unban API endpoints, security event logging -- UI panel deferred to Phase 3."

**SecurityEventsManager class:**

Constructor accepts: AuditLogger.

**1. Ban/Unban Management:**

- `banUser(userId: string, bannedBy: string, durationMs?: number, reason?: string) -> void`:
  Store in Redis sorted set `security:banned` with userId as member and unban timestamp as score. If durationMs is undefined, use Infinity score (permanent ban). Also store ban details in hash `security:ban:{userId}` with fields: bannedBy, reason, bannedAt, expiresAt.

- `unbanUser(userId: string, unbannedBy: string) -> void`:
  Remove from sorted set and delete ban details hash. Audit log the unban.

- `isUserBanned(userId: string) -> { banned: boolean, reason?: string, bannedBy?: string, expiresAt?: number }`:
  Check if userId is in the sorted set with a score >= current timestamp (or Infinity for permanent). Also return ban details from hash.

- `getActiveBans() -> Array<{ userId, reason, bannedBy, bannedAt, expiresAt }>`:
  Query all active bans (score >= now or Infinity).

**2. Security Event Storage:**

- `recordSecurityEvent(event: { type: string, actorId?: string, targetId?: string, ip?: string, metadata: Record<string, unknown> }) -> void`:
  Store in Redis sorted set `security:events` with score=timestamp and member=JSON of event. Trim to last 5000 entries.

- `getSecurityEvents(options: { limit?: number, type?: string, since?: number }) -> SecurityEvent[]`:
  Query security events with optional filtering. Use ZRANGEBYSCORE for time-based filtering.

**3. Rate Limit Data Access:**

- `getRateLimitStatus(ip: string) -> { connectionAttempts: number, authFailures: number, lastAttempt?: number }`:
  Read rate limiter Redis keys to surface current rate limit status for an IP. Key patterns from rateLimiter: `rl:conn:{ip}`, `rl:auth:{ip}`, `rl:fail:{ip}`.

- `getRateLimitedIPs(limit?: number) -> Array<{ ip: string, failures: number }>`:
  Scan Redis for active rate limit entries. Used by admin/dispatch to see which IPs are being rate-limited.

**4. Integration with WebSocket auth:**
- `checkBanOnConnect(userId: string) -> boolean`: Called during WebSocket verifyClient. If user is banned, reject connection with 403 Forbidden.

**Redis key structure:**
- `security:banned` -- sorted set (member=userId, score=expiresAt timestamp)
- `security:ban:{userId}` -- hash with ban details
- `security:events` -- sorted set (member=JSON event, score=timestamp)

Use createLogger('SecurityEvents') for logging.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify SecurityEventsManager exports with banUser, unbanUser, isUserBanned, getActiveBans, recordSecurityEvent, getSecurityEvents, getRateLimitStatus, checkBanOnConnect methods. Verify ban storage uses Redis sorted set with expiry-based scoring.
  </verify>
  <done>
SecurityEventsManager class exists with ban/unban management (permanent and timed), security event storage and querying, rate limit data access, and ban checking on WebSocket connect. Redis sorted set for time-based ban expiry. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire admin handlers into signaling handlers</name>
  <files>
    src/server/signaling/handlers.ts
  </files>
  <action>
Modify src/server/signaling/handlers.ts to integrate AdminHandlers:

**1. Add AdminHandlers to constructor:**
Add `adminHandlers: AdminHandlers` parameter. Store as private member.

**2. Add delegating methods:**
- `handleForceDisconnect(ctx, message)` -> check ctx.role is DISPATCH or ADMIN, then delegate to adminHandlers.handleForceDisconnect
- `handleBanUser(ctx, message)` -> check role, delegate to adminHandlers.handleBanUser
- `handleUnbanUser(ctx, message)` -> check role, delegate to adminHandlers.handleUnbanUser

On unauthorized attempt (GENERAL role), audit log AuditAction.PERMISSION_DENIED and send error response.

**3. Update handleJoinChannel:**
Add ban check at the very beginning of handleJoinChannel (before permission check):
```typescript
const banStatus = await this.securityEventsManager.isUserBanned(ctx.userId);
if (banStatus.banned) {
  this.sendError(ctx, message.id, 'Account is suspended');
  return;
}
```

Wait -- the ban check should actually happen at WebSocket connection time, not channel join time. The plan already has checkBanOnConnect in SecurityEventsManager. The integration in verifyClient happens in Plan 07. For now, just add the handler methods.

Keep all existing handler methods unchanged. Only add new methods and the AdminHandlers dependency.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify handlers.ts has handleForceDisconnect, handleBanUser, handleUnbanUser methods. Verify role checks protect all admin actions.
  </verify>
  <done>
SignalingHandlers delegates admin actions to AdminHandlers with role checks. Force-disconnect, ban, and unban require DISPATCH or ADMIN role. GENERAL users attempting admin actions get permission denied with audit log. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Force-disconnect immediately terminates target user's connection
3. Ban prevents user from connecting (checked on WebSocket auth)
4. Unban restores user's ability to connect
5. Security events are queryable by type and time range
6. Rate limit data is accessible for admin review
7. All actions audit logged
</verification>

<success_criteria>
- Dispatch and Admin can force-disconnect disruptive users immediately
- Ban/unban system prevents and restores WebSocket connections
- Security events backend stores and queries incidents
- Rate limit data is persisted for security review
- All actions have complete audit trail
- UI panel is correctly deferred to Phase 3 (no UI code in this plan)
</success_criteria>

<output>
After completion, create `.planning/phases/02-user-management-access-control/02-06-SUMMARY.md`
</output>
