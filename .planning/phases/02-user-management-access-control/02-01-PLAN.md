---
phase: 02-user-management-access-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/auth/permissionManager.ts
  - src/server/auth/auditLogger.ts
  - src/shared/types.ts
  - src/shared/protocol.ts
  - src/server/config.ts
autonomous: true

must_haves:
  truths:
    - "JWT token contains userId, eventId, role, and channelIds claims"
    - "Permission manager can validate user access to a channel given JWT claims"
    - "All auth events are logged to audit trail with actor, action, and metadata"
  artifacts:
    - path: "src/server/auth/permissionManager.ts"
      provides: "Permission validation logic for channel access, role checking"
      exports: ["PermissionManager"]
    - path: "src/server/auth/auditLogger.ts"
      provides: "Structured audit logging for all auth and security events"
      exports: ["AuditLogger", "AuditAction"]
    - path: "src/shared/types.ts"
      provides: "Extended types with UserRole, EventRole, AuthenticatedUser, PermissionSet"
    - path: "src/shared/protocol.ts"
      provides: "New signaling types for permission events and dispatch actions"
  key_links:
    - from: "src/server/auth/permissionManager.ts"
      to: "src/server/state/redisClient.ts"
      via: "Redis queries for real-time permission state"
      pattern: "getRedisClient"
    - from: "src/server/auth/auditLogger.ts"
      to: "src/server/state/redisClient.ts"
      via: "Redis pub/sub for audit event publishing"
      pattern: "publish.*audit"
---

<objective>
Build the authorization foundation: enhanced JWT claims parsing, a PermissionManager that validates user access to channels based on role and membership, and an AuditLogger that records all auth/security events. Also extend shared types and protocol with Phase 2 signaling types.

Purpose: This is the foundation layer that all other Phase 2 plans depend on. Without permission validation and audit logging, no authorization enforcement is possible.
Output: PermissionManager class, AuditLogger class, extended shared types/protocol, updated config.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-user-management-access-control/02-CONTEXT.md
@.planning/phases/02-user-management-access-control/02-RESEARCH.md
@src/shared/types.ts
@src/shared/protocol.ts
@src/server/config.ts
@src/server/state/redisClient.ts
@src/server/signaling/websocketServer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend shared types and signaling protocol for Phase 2</name>
  <files>
    src/shared/types.ts
    src/shared/protocol.ts
    src/server/config.ts
  </files>
  <action>
Extend src/shared/types.ts with these new types:

1. `UserRole` enum: ADMIN, DISPATCH, GENERAL (maps to existing Prisma GlobalRole ADMIN + EventRole DISPATCH/USER)
2. `AuthenticatedUser` interface: userId, userName, eventId, role (UserRole), channelIds (string[]), globalRole (string)
3. `PermissionSet` interface: canJoinChannel (boolean), canPtt (boolean), canPriorityPtt (boolean), canEmergencyBroadcast (boolean), canForceDisconnect (boolean), canManageChannels (boolean)
4. `ChannelPermission` interface: channelId, canListen (boolean), canSpeak (boolean)
5. `AuditEvent` interface: id (string), actorId (string), eventId (string | null), action (string), targetId (string | null), metadata (Record<string, unknown>), timestamp (number)

Extend src/shared/protocol.ts with new SignalingType enum values:

- PERMISSION_UPDATE = 'permission-update' (server pushes new channel list to client)
- CHANNEL_LIST = 'channel-list' (server pushes full channel list on connect)
- FORCE_DISCONNECT = 'force-disconnect' (dispatch/admin kicks a user)
- PRIORITY_PTT_START = 'priority-ptt-start' (dispatch overrides current speaker)
- PRIORITY_PTT_STOP = 'priority-ptt-stop'
- EMERGENCY_BROADCAST_START = 'emergency-broadcast-start'
- EMERGENCY_BROADCAST_STOP = 'emergency-broadcast-stop'
- PTT_INTERRUPTED = 'ptt-interrupted' (notification to interrupted speaker)
- ROLE_INFO = 'role-info' (server sends role badges/info to channel members)

Update src/server/config.ts to add Phase 2 configuration:

```typescript
auth: {
  jwtSecret: process.env.ROUTER_JWT_SECRET || 'change-me',
  tokenTtlSeconds: 3600, // 1 hour per user decision
  permissionRefreshIntervalMs: 30000, // 30s heartbeat-based permission refresh
},
dispatch: {
  emergencyBroadcastHoldMs: 2000, // 2-second long press guard
  priorityPttEnabled: true,
},
channels: {
  defaultMaxUsersPerChannel: 100,
  defaultSimultaneousChannelLimit: 10,
},
jitterBuffer: {
  minMs: 40,
  maxMs: 80,
  defaultMs: 60,
},
```

Keep all existing config values intact. Add new sections alongside existing ones.
  </action>
  <verify>
Run `npx tsc --noEmit` from the project root to verify TypeScript compilation succeeds with no errors. Verify the new types are importable: `import { UserRole, AuthenticatedUser } from '../../shared/types'` and `import { SignalingType } from '../../shared/protocol'` both resolve.
  </verify>
  <done>
shared/types.ts exports UserRole, AuthenticatedUser, PermissionSet, ChannelPermission, AuditEvent. shared/protocol.ts exports all new SignalingType values. config.ts has auth.tokenTtlSeconds, auth.permissionRefreshIntervalMs, dispatch, channels, and jitterBuffer sections. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PermissionManager for role-based channel access validation</name>
  <files>
    src/server/auth/permissionManager.ts
  </files>
  <action>
Create src/server/auth/permissionManager.ts that validates user permissions based on JWT claims and Redis state.

The PermissionManager class should:

1. **Constructor:** Accept a Redis client getter (same pattern as other state modules).

2. **parseJwtClaims(token decoded payload) -> AuthenticatedUser:** Extract userId, userName, eventId, role, channelIds, globalRole from the JWT payload. Map EventRole.DISPATCH to UserRole.DISPATCH, EventRole.USER to UserRole.GENERAL. If globalRole is ADMIN, set role to UserRole.ADMIN.

3. **canJoinChannel(user: AuthenticatedUser, channelId: string) -> boolean:** Check if channelId is in user.channelIds array. Admin users (globalRole ADMIN) bypass this check and can join any channel in their event.

4. **getPermissionSet(user: AuthenticatedUser) -> PermissionSet:** Return permission flags based on role:
   - ADMIN: canJoinChannel=true, canPtt=true, canPriorityPtt=false (per user decision: Admin does NOT have PTT priority), canEmergencyBroadcast=false, canForceDisconnect=true, canManageChannels=true
   - DISPATCH: canJoinChannel=true, canPtt=true, canPriorityPtt=true, canEmergencyBroadcast=true, canForceDisconnect=true, canManageChannels=true
   - GENERAL: canJoinChannel=true (only assigned channels), canPtt=true (only assigned channels), canPriorityPtt=false, canEmergencyBroadcast=false, canForceDisconnect=false, canManageChannels=false

5. **refreshPermissions(userId: string, eventId: string) -> string[]:** Query Redis for the user's current channel list (key pattern: `u.{userId}.g` -- this matches control-plane's syncUserChannelsToRedis). Returns the current list of channel IDs the user is authorized for. This is called during heartbeat permission refresh.

6. **getUserChannelsFromRedis(userId: string) -> string[]:** Read the set at Redis key `u.{userId}.g` and return as string array. This integrates with the existing control-plane's syncUserChannelsToRedis which writes to this exact key pattern.

7. **Redis key constants:** Store the key patterns as class constants matching control-plane conventions: `u.{userId}.g` for user channels, `g.{channelId}.u` for channel users.

Use the established logging pattern: `import { createLogger } from '../logger'` with label 'PermissionManager'.

IMPORTANT: Per user decision, permission checks happen at channel join time only -- no per-PTT-action checks (except for Dispatch priority which is a special override). This class validates at join time and during heartbeat refreshes.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify the file exists at src/server/auth/permissionManager.ts and exports PermissionManager class. Check that it imports from shared/types.ts (AuthenticatedUser, PermissionSet, UserRole) and from state/redisClient.ts.
  </verify>
  <done>
PermissionManager class exists with parseJwtClaims, canJoinChannel, getPermissionSet, refreshPermissions, getUserChannelsFromRedis methods. Role mapping correctly maps ADMIN/DISPATCH/GENERAL. Admin does NOT have PTT priority (per locked decision). Redis key patterns match control-plane conventions (u.{userId}.g, g.{channelId}.u). TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AuditLogger for security event tracking</name>
  <files>
    src/server/auth/auditLogger.ts
  </files>
  <action>
Create src/server/auth/auditLogger.ts for structured audit logging of all auth and security events.

The AuditLogger class should:

1. **AuditAction enum** with values:
   - AUTH_LOGIN, AUTH_LOGOUT, AUTH_TOKEN_REFRESH
   - PERMISSION_CHECK, PERMISSION_DENIED, PERMISSION_GRANTED
   - CHANNEL_JOIN, CHANNEL_LEAVE, CHANNEL_JOIN_DENIED
   - PTT_START, PTT_STOP, PTT_DENIED
   - PRIORITY_PTT_START, PRIORITY_PTT_INTERRUPTED
   - EMERGENCY_BROADCAST_START, EMERGENCY_BROADCAST_STOP
   - FORCE_DISCONNECT
   - RATE_LIMIT_HIT, RATE_LIMIT_BLOCK
   - ROLE_CHANGE
   - SECURITY_BAN, SECURITY_UNBAN

2. **log(event: Partial<AuditEvent> & { action: AuditAction }) -> void:** Non-blocking audit log. Uses Redis LPUSH to append to an audit log list (key: `audit:log`). Auto-generates id (UUID) and timestamp. CRITICAL: audit logging failure must NEVER break core functionality -- wrap in try/catch, log warning on failure, but never throw.

3. **getRecentEvents(limit?: number) -> AuditEvent[]:** Read last N events from Redis list (LRANGE). Default limit 100.

4. **getEventsByActor(actorId: string, limit?: number) -> AuditEvent[]:** Filter audit events by actor. Uses Redis sorted set with actor index (key: `audit:actor:{actorId}`).

5. **exportToDatabase() -> void:** Batch export Redis audit events to control-plane database via Redis pub/sub publish on channel `vp:audit_export`. The control-plane can subscribe and persist to Prisma AuditLog table. This is a periodic operation, not called on every log.

6. **Redis key structure:**
   - `audit:log` -- list of all audit events (capped at 10000 entries via LTRIM)
   - `audit:actor:{actorId}` -- sorted set for per-actor lookup (score = timestamp)
   - Auto-trim: After each LPUSH, run LTRIM to keep list at max 10000 entries

Use Winston logger for internal error logging. Never throw from log() method.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify file exists at src/server/auth/auditLogger.ts and exports AuditLogger class and AuditAction enum. Confirm the log() method has try/catch that prevents throwing.
  </verify>
  <done>
AuditLogger class exists with log(), getRecentEvents(), getEventsByActor(), exportToDatabase() methods. AuditAction enum covers all auth/security events. log() is non-blocking (wrapped in try/catch). Redis keys use audit:log list with LTRIM capping. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. src/server/auth/permissionManager.ts exports PermissionManager
3. src/server/auth/auditLogger.ts exports AuditLogger and AuditAction
4. src/shared/types.ts exports UserRole, AuthenticatedUser, PermissionSet, ChannelPermission, AuditEvent
5. src/shared/protocol.ts includes all new SignalingType values
6. src/server/config.ts has auth.tokenTtlSeconds, dispatch, channels, jitterBuffer sections
</verification>

<success_criteria>
- Permission manager can determine if a user (by role and channelIds) is allowed to join a specific channel
- Audit logger records events to Redis without blocking core operations
- All new types are importable and the TypeScript project compiles cleanly
- Config has all Phase 2 settings with sensible defaults
</success_criteria>

<output>
After completion, create `.planning/phases/02-user-management-access-control/02-01-SUMMARY.md`
</output>
