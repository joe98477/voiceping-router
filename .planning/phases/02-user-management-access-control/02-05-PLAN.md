---
phase: 02-user-management-access-control
plan: 05
type: execute
wave: 3
depends_on: ["02-03", "02-04"]
files_modified:
  - src/server/signaling/dispatchHandlers.ts
  - src/server/signaling/handlers.ts
autonomous: true

must_haves:
  truths:
    - "Dispatch user can immediately take over a channel, cutting off the current General user speaker"
    - "Interrupted user hears audio cutoff + receives notification with Dispatch name"
    - "Dispatch can transmit to ALL channels in event simultaneously via emergency broadcast"
    - "Emergency broadcast requires 2-second long press to prevent accidental activation"
    - "Admin does NOT have PTT priority (management role, not communication role)"
  artifacts:
    - path: "src/server/signaling/dispatchHandlers.ts"
      provides: "Dispatch-specific signaling handlers: priority PTT, emergency broadcast"
      exports: ["DispatchHandlers"]
    - path: "src/server/signaling/handlers.ts"
      provides: "Updated message routing for dispatch actions"
  key_links:
    - from: "src/server/signaling/dispatchHandlers.ts"
      to: "src/server/state/channelState.ts"
      via: "pauseAllSpeakers for emergency broadcast, startPtt override for priority"
      pattern: "channelStateManager\\.(pauseAllSpeakers|startPtt|stopPtt)"
    - from: "src/server/signaling/dispatchHandlers.ts"
      to: "src/server/mediasoup/producerConsumerManager.ts"
      via: "Pause interrupted user's producer, resume Dispatch producer"
      pattern: "producerConsumerManager\\.(pauseProducer|resumeProducer)"
    - from: "src/server/signaling/dispatchHandlers.ts"
      to: "src/server/signaling/handlers.ts"
      via: "Temporary channel join for emergency broadcast uses internal join flow"
      pattern: "signalingHandlers\\.handleJoinChannel|signalingHandlers\\.handleLeaveChannel"
    - from: "src/server/signaling/handlers.ts"
      to: "src/server/signaling/dispatchHandlers.ts"
      via: "Route dispatch message types to dispatch handlers"
      pattern: "dispatchHandlers\\.handle"
---

<objective>
Implement Dispatch PTT priority interrupt (Dispatch immediately preempts General user mid-transmission) and emergency broadcast (Dispatch transmits to ALL channels in event simultaneously). These are Dispatch-only capabilities that mirror real radio system operations.

Purpose: Dispatch priority ensures critical communications override general chatter. Emergency broadcast enables Dispatch to reach all teams at once during emergencies. These are core operational capabilities for event coordination.
Output: DispatchHandlers class with priority PTT and emergency broadcast, updated message routing.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-user-management-access-control/02-CONTEXT.md
@.planning/phases/02-user-management-access-control/02-03-SUMMARY.md
@.planning/phases/02-user-management-access-control/02-04-SUMMARY.md
@src/server/signaling/handlers.ts
@src/server/signaling/websocketServer.ts
@src/server/state/channelState.ts
@src/server/mediasoup/producerConsumerManager.ts
@src/shared/protocol.ts
@src/shared/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DispatchHandlers for priority PTT and emergency broadcast</name>
  <files>
    src/server/signaling/dispatchHandlers.ts
  </files>
  <action>
Create src/server/signaling/dispatchHandlers.ts implementing Dispatch-only capabilities.

**DispatchHandlers class:**

Constructor accepts: ChannelStateManager, ProducerConsumerManager, SessionStore, broadcastToChannel function, sendToUser function (sends message to a specific connected user), AuditLogger, and a reference to the main SignalingHandlers (for accessing userProducers map and for internal join/leave calls during emergency broadcast).

**1. handlePriorityPttStart(ctx: ClientContext, message: SignalingMessage):**

Per user decisions: "Dispatch has PTT priority interrupt: can immediately take over channel, cutting off current General user speaker" and "Admin does NOT have PTT priority."

- Validate ctx.role === UserRole.DISPATCH (not ADMIN, not GENERAL)
- Extract channelId from message.data
- Get current channel state: check if someone is currently speaking
- If channel is idle: just do normal PTT start (delegate to existing handler)
- If channel is busy (General user speaking):
  a. Pause the current speaker's producer (find their producerId via userProducers map)
  b. Override the speaker lock: call channelStateManager.stopPtt for the current speaker, then channelStateManager.startPtt for Dispatch
  c. Resume Dispatch's producer
  d. Send PTT_INTERRUPTED notification to the interrupted user: `{ channelId, interruptedBy: ctx.userName, message: "Dispatch [name] has priority" }` (exact message per user decision)
  e. Broadcast SPEAKER_CHANGED to all channel members showing Dispatch as speaker
  f. Audit log: AuditAction.PRIORITY_PTT_START with metadata including interrupted user

- If channel is busy (another Dispatch speaking): deny with PTT_DENIED (only one speaker at a time, even for Dispatch -- Dispatch can interrupt General but not other Dispatch)

**2. handlePriorityPttStop(ctx: ClientContext, message: SignalingMessage):**
- Same as regular PTT stop (delegate to existing handlePttStop)
- The interrupted General user must re-press PTT after Dispatch finishes (per user decision: "must re-press PTT after Dispatch finishes")

**3. handleEmergencyBroadcastStart(ctx: ClientContext, message: SignalingMessage):**

Per user decisions: "Emergency broadcast: Dispatch can transmit to ALL channels in an event simultaneously, overriding all active speakers" and "2-second long press on distinct broadcast button (prevents accidental activation, no dialog)."

- Validate ctx.role === UserRole.DISPATCH
- Extract eventId from ctx.eventId
- Validate holdDuration from message.data.holdDuration >= config.dispatch.emergencyBroadcastHoldMs (2000ms) -- server-side verification of the 2-second hold guard
- If holdDuration < 2000ms, reject with error "Emergency broadcast requires 2-second hold"
- Get all channels for event: channelStateManager.getChannelsForEvent(ctx.eventId)
- Pause ALL active speakers across ALL channels: channelStateManager.pauseAllSpeakers(ctx.eventId)
- For each paused speaker, pause their producer and send PTT_INTERRUPTED notification

**Temporary channel join wiring for emergency broadcast:**

The Dispatch user's audio must reach ALL channels, including ones they have not explicitly joined. Implement this using internal join calls:

a. Determine which event channels the Dispatch user is NOT already joined to:
   ```typescript
   const allEventChannels = channelStateManager.getChannelsForEvent(ctx.eventId);
   const alreadyJoined = ctx.channels; // Set<string> of currently joined channels
   const needsTemporaryJoin = allEventChannels.filter(ch => !alreadyJoined.has(ch));
   ```

b. Track temporary joins in a class-level Set per broadcast:
   ```typescript
   // Class property:
   private temporaryChannelJoins = new Map<string, Set<string>>(); // broadcastId -> Set<channelId>
   ```
   Generate a broadcastId (e.g., `${ctx.userId}:${Date.now()}`).

c. For each channel in needsTemporaryJoin, call signalingHandlers.handleJoinChannel internally (synthesize a JOIN_CHANNEL message). This reuses the existing join flow to set up mediasoup router, transport, producer, and consumers -- no separate audio forwarding path needed.

d. After all temporary joins complete, acquire speaker lock on ALL event channels for the Dispatch user (channelStateManager.startPtt on each).

e. Resume Dispatch's producer in each channel.

f. Store the broadcastId and temporary channel set: `this.temporaryChannelJoins.set(broadcastId, new Set(needsTemporaryJoin));`

g. Also store the broadcastId in the activeEmergencyBroadcasts map (see below).

- Broadcast EMERGENCY_BROADCAST_START to all channels in the event with Dispatch identity
- Audit log: AuditAction.EMERGENCY_BROADCAST_START with channelCount, temporaryJoinCount, and interrupted speaker list
- Track active emergency broadcast state:
  ```typescript
  private activeEmergencyBroadcasts = new Map<string, {
    broadcastId: string,
    userId: string,
    eventId: string,
    channels: string[],
    temporaryChannels: Set<string>
  }>();
  ```

**4. handleEmergencyBroadcastStop(ctx: ClientContext, message: SignalingMessage):**
- Look up active broadcast for ctx.userId in activeEmergencyBroadcasts
- Release speaker locks on ALL channels (channelStateManager.stopPtt on each)
- Pause Dispatch's producers in all channels

**Temporary channel cleanup (critical -- distinguishes temporary from permanent):**
- Retrieve the temporaryChannels Set from the activeEmergencyBroadcasts entry
- For each channel in temporaryChannels ONLY (not the channels Dispatch was already in):
  - Call signalingHandlers.handleLeaveChannel internally (synthesize a LEAVE_CHANNEL message)
  - This cleans up the mediasoup router, transport, producer, and consumers for that channel
- Do NOT leave channels the Dispatch user had joined before the broadcast -- those are permanent
- Remove from temporaryChannelJoins map
- Remove from activeEmergencyBroadcasts map

- Broadcast EMERGENCY_BROADCAST_STOP to all channels in the event
- Audit log: AuditAction.EMERGENCY_BROADCAST_STOP with temporaryChannelsCleanedUp count

**5. Helper method: sendToUser(userId: string, message: SignalingMessage):**
Accept a function reference from constructor that finds a connected client by userId and sends a message. This is needed to send PTT_INTERRUPTED to specific users who were interrupted.

Use createLogger('DispatchHandlers') for logging.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify file exports DispatchHandlers class. Verify handlePriorityPttStart checks role === DISPATCH (not ADMIN). Verify handleEmergencyBroadcastStart validates holdDuration >= 2000ms. Verify PTT_INTERRUPTED message includes "Dispatch [name] has priority" text. Verify temporaryChannelJoins Map exists and is populated during broadcast start. Verify handleEmergencyBroadcastStop only leaves temporary channels (not permanent ones).
  </verify>
  <done>
DispatchHandlers class exists with priority PTT (Dispatch-only, not Admin), emergency broadcast with explicit temporary channel join wiring (internal join calls for unjoined channels, tracked in temporaryChannelJoins Map), and PTT interruption notifications. Cleanup on broadcast stop only leaves temporary channels, preserving permanent joins. Interrupted users receive "Dispatch [name] has priority" message. All actions audit logged. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire dispatch handlers into signaling message router</name>
  <files>
    src/server/signaling/handlers.ts
  </files>
  <action>
Modify src/server/signaling/handlers.ts to integrate DispatchHandlers:

**1. Add DispatchHandlers to constructor:**
Add `dispatchHandlers: DispatchHandlers` parameter. Store as private member.

Note: The SignalingHandlers constructor is getting crowded. This is acceptable for Phase 2. If it exceeds 8 parameters, a future refactor should use an options object pattern. For now, add the parameter.

**2. Expose userProducers map:**
The DispatchHandlers needs access to the userProducers Map to find producer IDs for interrupted users. Add a getter method: `getUserProducerId(userId: string, channelId: string) -> string | undefined` that looks up `${userId}:${channelId}` in the userProducers map.

**3. The routing happens in websocketServer.ts routeMessage():**
This task does NOT modify websocketServer.ts (that's Plan 07's integration work). Instead, this task:
- Adds the new handler methods to SignalingHandlers that delegate to DispatchHandlers
- `handlePriorityPttStart(ctx, message)` -> delegates to dispatchHandlers.handlePriorityPttStart
- `handlePriorityPttStop(ctx, message)` -> delegates to dispatchHandlers.handlePriorityPttStop
- `handleEmergencyBroadcastStart(ctx, message)` -> delegates to dispatchHandlers.handleEmergencyBroadcastStart
- `handleEmergencyBroadcastStop(ctx, message)` -> delegates to dispatchHandlers.handleEmergencyBroadcastStop

Each delegating method first checks role authorization:
- Priority PTT: ctx.role must be DISPATCH (reject with error for ADMIN and GENERAL)
- Emergency broadcast: ctx.role must be DISPATCH (reject with error for ADMIN and GENERAL)
- On unauthorized attempt, audit log AuditAction.PERMISSION_DENIED

Keep all existing handler methods unchanged.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify handlers.ts has handlePriorityPttStart, handlePriorityPttStop, handleEmergencyBroadcastStart, handleEmergencyBroadcastStop methods. Verify each checks role === DISPATCH before delegating. Verify getUserProducerId method exists.
  </verify>
  <done>
SignalingHandlers delegates dispatch actions to DispatchHandlers with role checks. getUserProducerId exposes producer lookup for interrupt operations. Priority PTT and emergency broadcast are Dispatch-only (ADMIN and GENERAL rejected). Unauthorized attempts audit logged. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. DispatchHandlers.handlePriorityPttStart pauses General user's producer and resumes Dispatch
3. PTT_INTERRUPTED sent to interrupted user with "Dispatch [name] has priority"
4. Emergency broadcast validates holdDuration >= 2000ms
5. Emergency broadcast temporarily joins Dispatch to unjoined channels via internal join calls
6. temporaryChannelJoins Map tracks which channels are temporary vs permanent
7. Emergency broadcast stop only leaves temporary channels, preserving permanent joins
8. Emergency broadcast pauses ALL speakers in event, broadcasts to ALL channels
9. Admin cannot use priority PTT or emergency broadcast
10. All dispatch actions are audit logged
</verification>

<success_criteria>
- Dispatch can interrupt General users mid-PTT and immediately start speaking
- Interrupted users are notified and must re-press PTT
- Emergency broadcast reaches all channels in event with 2-second safety guard
- Temporary channel joins are properly tracked and cleaned up on broadcast stop
- Admin role correctly excluded from real-time communication priority features
- All actions have complete audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/02-user-management-access-control/02-05-SUMMARY.md`
</output>
