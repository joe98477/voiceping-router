---
phase: 02-user-management-access-control
plan: 05
type: execute
wave: 3
depends_on: ["02-03", "02-04"]
files_modified:
  - src/server/signaling/dispatchHandlers.ts
  - src/server/signaling/handlers.ts
autonomous: true

must_haves:
  truths:
    - "Dispatch user can immediately take over a channel, cutting off the current General user speaker"
    - "Interrupted user hears audio cutoff + receives notification with Dispatch name"
    - "Dispatch can transmit to ALL channels in event simultaneously via emergency broadcast"
    - "Emergency broadcast requires 2-second long press to prevent accidental activation"
    - "Admin does NOT have PTT priority (management role, not communication role)"
  artifacts:
    - path: "src/server/signaling/dispatchHandlers.ts"
      provides: "Dispatch-specific signaling handlers: priority PTT, emergency broadcast"
      exports: ["DispatchHandlers"]
    - path: "src/server/signaling/handlers.ts"
      provides: "Updated message routing for dispatch actions"
  key_links:
    - from: "src/server/signaling/dispatchHandlers.ts"
      to: "src/server/state/channelState.ts"
      via: "pauseAllSpeakers for emergency broadcast, startPtt override for priority"
      pattern: "channelStateManager\\.(pauseAllSpeakers|startPtt|stopPtt)"
    - from: "src/server/signaling/dispatchHandlers.ts"
      to: "src/server/mediasoup/producerConsumerManager.ts"
      via: "Pause interrupted user's producer, resume Dispatch producer"
      pattern: "producerConsumerManager\\.(pauseProducer|resumeProducer)"
    - from: "src/server/signaling/handlers.ts"
      to: "src/server/signaling/dispatchHandlers.ts"
      via: "Route dispatch message types to dispatch handlers"
      pattern: "dispatchHandlers\\.handle"
---

<objective>
Implement Dispatch PTT priority interrupt (Dispatch immediately preempts General user mid-transmission) and emergency broadcast (Dispatch transmits to ALL channels in event simultaneously). These are Dispatch-only capabilities that mirror real radio system operations.

Purpose: Dispatch priority ensures critical communications override general chatter. Emergency broadcast enables Dispatch to reach all teams at once during emergencies. These are core operational capabilities for event coordination.
Output: DispatchHandlers class with priority PTT and emergency broadcast, updated message routing.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-user-management-access-control/02-CONTEXT.md
@.planning/phases/02-user-management-access-control/02-03-SUMMARY.md
@.planning/phases/02-user-management-access-control/02-04-SUMMARY.md
@src/server/signaling/handlers.ts
@src/server/signaling/websocketServer.ts
@src/server/state/channelState.ts
@src/server/mediasoup/producerConsumerManager.ts
@src/shared/protocol.ts
@src/shared/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DispatchHandlers for priority PTT and emergency broadcast</name>
  <files>
    src/server/signaling/dispatchHandlers.ts
  </files>
  <action>
Create src/server/signaling/dispatchHandlers.ts implementing Dispatch-only capabilities.

**DispatchHandlers class:**

Constructor accepts: ChannelStateManager, ProducerConsumerManager, SessionStore, broadcastToChannel function, sendToUser function (sends message to a specific connected user), AuditLogger, and a reference to the main SignalingHandlers (for accessing userProducers map).

**1. handlePriorityPttStart(ctx: ClientContext, message: SignalingMessage):**

Per user decisions: "Dispatch has PTT priority interrupt: can immediately take over channel, cutting off current General user speaker" and "Admin does NOT have PTT priority."

- Validate ctx.role === UserRole.DISPATCH (not ADMIN, not GENERAL)
- Extract channelId from message.data
- Get current channel state: check if someone is currently speaking
- If channel is idle: just do normal PTT start (delegate to existing handler)
- If channel is busy (General user speaking):
  a. Pause the current speaker's producer (find their producerId via userProducers map)
  b. Override the speaker lock: call channelStateManager.stopPtt for the current speaker, then channelStateManager.startPtt for Dispatch
  c. Resume Dispatch's producer
  d. Send PTT_INTERRUPTED notification to the interrupted user: `{ channelId, interruptedBy: ctx.userName, message: "Dispatch [name] has priority" }` (exact message per user decision)
  e. Broadcast SPEAKER_CHANGED to all channel members showing Dispatch as speaker
  f. Audit log: AuditAction.PRIORITY_PTT_START with metadata including interrupted user

- If channel is busy (another Dispatch speaking): deny with PTT_DENIED (only one speaker at a time, even for Dispatch -- Dispatch can interrupt General but not other Dispatch)

**2. handlePriorityPttStop(ctx: ClientContext, message: SignalingMessage):**
- Same as regular PTT stop (delegate to existing handlePttStop)
- The interrupted General user must re-press PTT after Dispatch finishes (per user decision: "must re-press PTT after Dispatch finishes")

**3. handleEmergencyBroadcastStart(ctx: ClientContext, message: SignalingMessage):**

Per user decisions: "Emergency broadcast: Dispatch can transmit to ALL channels in an event simultaneously, overriding all active speakers" and "2-second long press on distinct broadcast button (prevents accidental activation, no dialog)."

- Validate ctx.role === UserRole.DISPATCH
- Extract eventId from ctx.eventId
- Validate holdDuration from message.data.holdDuration >= config.dispatch.emergencyBroadcastHoldMs (2000ms) -- server-side verification of the 2-second hold guard
- If holdDuration < 2000ms, reject with error "Emergency broadcast requires 2-second hold"
- Get all channels for event: channelStateManager.getChannelsForEvent(ctx.eventId)
- Pause ALL active speakers across ALL channels: channelStateManager.pauseAllSpeakers(ctx.eventId)
- For each paused speaker, pause their producer and send PTT_INTERRUPTED notification
- Acquire speaker lock on ALL channels for the Dispatch user
- Resume Dispatch's producer (single producer, routed to all channels)
- Broadcast EMERGENCY_BROADCAST_START to all channels in the event with Dispatch identity
- Audit log: AuditAction.EMERGENCY_BROADCAST_START with channelCount and interrupted speaker list
- Track active emergency broadcast state: store in class property `activeEmergencyBroadcasts = new Map<string, { userId: string, eventId: string, channels: string[] }>()`

Note on producer management for emergency broadcast: The Dispatch user's existing producer in their current channel is reused. The audio is delivered to consumers across all channels because:
- For channels the Dispatch user is already joined to: their existing producer is resumed
- For channels the Dispatch user is NOT joined to: This plan creates temporary producer forwarding. Use the existing producer and create consumers in each target channel's router via PipeTransport (mediasoup's built-in cross-router forwarding mechanism). If PipeTransport is complex, a simpler approach: temporarily join the Dispatch user to all event channels, create producers in each, and clean up after broadcast ends.

Use the simpler approach: temporarily join all event channels, leverage existing join/produce flow, and clean up on stop.

**4. handleEmergencyBroadcastStop(ctx: ClientContext, message: SignalingMessage):**
- Release speaker locks on ALL channels
- Pause Dispatch's producers in all temporarily-joined channels
- Clean up temporary channel joins (leave channels that were not originally joined)
- Remove from activeEmergencyBroadcasts map
- Broadcast EMERGENCY_BROADCAST_STOP to all channels in the event
- Audit log: AuditAction.EMERGENCY_BROADCAST_STOP

**5. Helper method: sendToUser(userId: string, message: SignalingMessage):**
Accept a function reference from constructor that finds a connected client by userId and sends a message. This is needed to send PTT_INTERRUPTED to specific users who were interrupted.

Use createLogger('DispatchHandlers') for logging.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify file exports DispatchHandlers class. Verify handlePriorityPttStart checks role === DISPATCH (not ADMIN). Verify handleEmergencyBroadcastStart validates holdDuration >= 2000ms. Verify PTT_INTERRUPTED message includes "Dispatch [name] has priority" text.
  </verify>
  <done>
DispatchHandlers class exists with priority PTT (Dispatch-only, not Admin), emergency broadcast (2-second hold guard, all-channel override), and PTT interruption notifications. Interrupted users receive "Dispatch [name] has priority" message. All actions audit logged. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire dispatch handlers into signaling message router</name>
  <files>
    src/server/signaling/handlers.ts
  </files>
  <action>
Modify src/server/signaling/handlers.ts to integrate DispatchHandlers:

**1. Add DispatchHandlers to constructor:**
Add `dispatchHandlers: DispatchHandlers` parameter. Store as private member.

Note: The SignalingHandlers constructor is getting crowded. This is acceptable for Phase 2. If it exceeds 8 parameters, a future refactor should use an options object pattern. For now, add the parameter.

**2. Expose userProducers map:**
The DispatchHandlers needs access to the userProducers Map to find producer IDs for interrupted users. Add a getter method: `getUserProducerId(userId: string, channelId: string) -> string | undefined` that looks up `${userId}:${channelId}` in the userProducers map.

**3. The routing happens in websocketServer.ts routeMessage():**
This task does NOT modify websocketServer.ts (that's Plan 07's integration work). Instead, this task:
- Adds the new handler methods to SignalingHandlers that delegate to DispatchHandlers
- `handlePriorityPttStart(ctx, message)` -> delegates to dispatchHandlers.handlePriorityPttStart
- `handlePriorityPttStop(ctx, message)` -> delegates to dispatchHandlers.handlePriorityPttStop
- `handleEmergencyBroadcastStart(ctx, message)` -> delegates to dispatchHandlers.handleEmergencyBroadcastStart
- `handleEmergencyBroadcastStop(ctx, message)` -> delegates to dispatchHandlers.handleEmergencyBroadcastStop

Each delegating method first checks role authorization:
- Priority PTT: ctx.role must be DISPATCH (reject with error for ADMIN and GENERAL)
- Emergency broadcast: ctx.role must be DISPATCH (reject with error for ADMIN and GENERAL)
- On unauthorized attempt, audit log AuditAction.PERMISSION_DENIED

Keep all existing handler methods unchanged.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify handlers.ts has handlePriorityPttStart, handlePriorityPttStop, handleEmergencyBroadcastStart, handleEmergencyBroadcastStop methods. Verify each checks role === DISPATCH before delegating. Verify getUserProducerId method exists.
  </verify>
  <done>
SignalingHandlers delegates dispatch actions to DispatchHandlers with role checks. getUserProducerId exposes producer lookup for interrupt operations. Priority PTT and emergency broadcast are Dispatch-only (ADMIN and GENERAL rejected). Unauthorized attempts audit logged. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. DispatchHandlers.handlePriorityPttStart pauses General user's producer and resumes Dispatch
3. PTT_INTERRUPTED sent to interrupted user with "Dispatch [name] has priority"
4. Emergency broadcast validates holdDuration >= 2000ms
5. Emergency broadcast pauses ALL speakers in event, broadcasts to ALL channels
6. Admin cannot use priority PTT or emergency broadcast
7. All dispatch actions are audit logged
</verification>

<success_criteria>
- Dispatch can interrupt General users mid-PTT and immediately start speaking
- Interrupted users are notified and must re-press PTT
- Emergency broadcast reaches all channels in event with 2-second safety guard
- Admin role correctly excluded from real-time communication priority features
- All actions have complete audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/02-user-management-access-control/02-05-SUMMARY.md`
</output>
