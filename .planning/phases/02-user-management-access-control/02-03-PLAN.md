---
phase: 02-user-management-access-control
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/server/signaling/websocketServer.ts
  - src/server/signaling/handlers.ts
autonomous: true

must_haves:
  truths:
    - "User cannot join a channel they are not assigned to"
    - "JWT claims are parsed to extract role and channelIds on WebSocket connect"
    - "Heartbeat refreshes permissions every 30 seconds, catching revocations"
    - "Graceful removal on revocation: current PTT finishes, then user is removed"
    - "All permission checks and denials are audit logged"
  artifacts:
    - path: "src/server/signaling/websocketServer.ts"
      provides: "Enhanced JWT parsing with role/channelIds, permission refresh on heartbeat, rate limiting integration"
    - path: "src/server/signaling/handlers.ts"
      provides: "Permission-checked channel join, graceful permission revocation handling"
  key_links:
    - from: "src/server/signaling/websocketServer.ts"
      to: "src/server/auth/permissionManager.ts"
      via: "Permission validation on connect and heartbeat"
      pattern: "permissionManager\\.(canJoinChannel|refreshPermissions|parseJwtClaims)"
    - from: "src/server/signaling/handlers.ts"
      to: "src/server/auth/permissionManager.ts"
      via: "Channel join permission check"
      pattern: "permissionManager\\.canJoinChannel"
    - from: "src/server/signaling/handlers.ts"
      to: "src/server/auth/auditLogger.ts"
      via: "Audit logging for join attempts"
      pattern: "auditLogger\\.log"
---

<objective>
Wire authorization enforcement into the existing signaling flow. Enhance JWT parsing to extract role and channelIds. Add permission checks to channel join. Implement heartbeat-based permission refresh that catches revocations gracefully (let current PTT finish, then remove). Integrate rate limiting on WebSocket connections.

Purpose: This is the core of Phase 2 -- making the router enforce what the control-plane manages. Without this, any user with a valid JWT can join any channel regardless of their assigned permissions.
Output: Modified websocketServer.ts with enhanced auth and heartbeat, modified handlers.ts with permission-checked join.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-user-management-access-control/02-CONTEXT.md
@.planning/phases/02-user-management-access-control/02-01-SUMMARY.md
@src/server/signaling/websocketServer.ts
@src/server/signaling/handlers.ts
@src/server/auth/permissionManager.ts
@src/server/auth/auditLogger.ts
@src/server/auth/rateLimiter.ts
@src/shared/types.ts
@src/shared/protocol.ts
@src/server/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance WebSocket server with role-aware JWT and permission refresh heartbeat</name>
  <files>
    src/server/signaling/websocketServer.ts
  </files>
  <action>
Modify src/server/signaling/websocketServer.ts to integrate Phase 2 authorization:

**1. Enhance ClientContext interface:**
Add to the existing ClientContext:
- `role: UserRole` (from shared/types)
- `eventId: string`
- `authorizedChannels: Set<string>` (channels the user is allowed to join, from JWT + Redis refresh)
- `globalRole: string`

**2. Enhance verifyClient():**
The existing JWT verification extracts userId and userName. Extend it to also extract:
- eventId (from JWT payload)
- role (map from JWT: if globalRole === 'ADMIN' -> ADMIN, if role === 'DISPATCH' -> DISPATCH, else GENERAL)
- channelIds (from JWT payload)
- Attach all to (info.req as any)

Also integrate rate limiter: call rateLimiter.consumeConnection(ip). If not allowed, reject with 429 Too Many Requests. Extract IP from req.socket.remoteAddress or x-forwarded-for header.

Also integrate rate limiter auth check: call rateLimiter.consumeAuth(ip). Apply progressive delay if needed.

**3. Enhance handleConnection():**
After creating ClientContext, populate the new fields from the request:
- ctx.role = (req as any).role
- ctx.eventId = (req as any).eventId
- ctx.authorizedChannels = new Set((req as any).channelIds || [])
- ctx.globalRole = (req as any).globalRole

On successful connection, audit log: AuditAction.AUTH_LOGIN with userId, eventId, role.

After connection setup, send CHANNEL_LIST message to client with the user's authorized channels (server pushes channel list per user decision: "Server pushes channel list to user on connect").

**4. Implement heartbeat-based permission refresh:**
Modify the existing 30-second heartbeat interval. On each heartbeat tick, for each connected client:
- Call permissionManager.refreshPermissions(ctx.userId, ctx.eventId) to get fresh channel list from Redis
- Compare with ctx.authorizedChannels
- If channels were ADDED: update ctx.authorizedChannels, send PERMISSION_UPDATE with action 'channels-added' and new channel list
- If channels were REMOVED: for each removed channel, check if user is currently in that channel (ctx.channels.has(channelId)):
  - If user is NOT currently transmitting on that channel: immediately remove them (call handlers.handleLeaveChannel internally)
  - If user IS currently transmitting (check channelStateManager): let them finish current PTT, then remove. Set a flag `pendingRemoval` on the channel. After next PTT_STOP for that channel, auto-remove.
  - Send PERMISSION_UPDATE with action 'channels-removed' and removed channel IDs
- Update ctx.authorizedChannels to the fresh list

This implements the locked decisions: "Permission checks at channel join time only", "Regular heartbeat refreshes permissions between joins", and "Graceful removal on permission revocation: if user is actively transmitting, let them finish current PTT, then remove."

**5. Constructor changes:**
Accept PermissionManager, AuditLogger, and RateLimiter as constructor parameters (alongside existing SignalingHandlers). Store as private members.

Keep ALL existing functionality intact. This is additive enhancement, not a rewrite.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify that ClientContext now includes role, eventId, authorizedChannels. Verify that verifyClient extracts role and channelIds from JWT. Verify heartbeat includes permission refresh logic.
  </verify>
  <done>
WebSocket server extracts full JWT claims (userId, userName, eventId, role, channelIds, globalRole) on connect. Rate limiter checks connection rate on verifyClient. Heartbeat refreshes permissions every 30s from Redis. Graceful removal lets transmitting users finish PTT before removal. CHANNEL_LIST pushed on connect. All auth events audit logged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add permission-checked channel join and audit logging to handlers</name>
  <files>
    src/server/signaling/handlers.ts
  </files>
  <action>
Modify src/server/signaling/handlers.ts to enforce permissions on channel join and log audit events:

**1. Constructor changes:**
Accept PermissionManager and AuditLogger as additional constructor parameters. Store as private members.

**2. Modify handleJoinChannel():**
Before the existing logic (session store, router creation, etc.), add permission check:

```typescript
// Permission check: user must be authorized for this channel
if (!ctx.authorizedChannels.has(channelId) && ctx.role !== UserRole.ADMIN) {
  // Audit log the denial
  this.auditLogger.log({
    action: AuditAction.CHANNEL_JOIN_DENIED,
    actorId: ctx.userId,
    eventId: ctx.eventId,
    targetId: channelId,
    metadata: { role: ctx.role, reason: 'not_authorized' }
  });

  this.sendError(ctx, message.id, 'Not authorized to join this channel');
  logger.warn(`Permission denied: ${ctx.userId} attempted to join unauthorized channel ${channelId}`);
  return;
}
```

On successful join, audit log: AuditAction.CHANNEL_JOIN.

Also enforce channel user limit: check config.channels.defaultMaxUsersPerChannel. Before allowing join, check sessionStore.getChannelUserCount(channelId). If at limit, deny with error "Channel is full".

Also enforce simultaneous channel limit: check if ctx.channels.size >= config.channels.defaultSimultaneousChannelLimit. If at limit, deny with error "Maximum channels reached. Remove a channel to add another." (exact message per user decision).

**3. Add handlePermissionRevocation() method:**
New method called by the heartbeat when channels are revoked:

```typescript
async handlePermissionRevocation(ctx: ClientContext, channelId: string, force: boolean = false): Promise<void>
```

- If force=true or user is not currently transmitting on this channel: call handleLeaveChannel internally (synthesize a LEAVE_CHANNEL message)
- If user IS transmitting (check channelStateManager.getChannelState): set a pending removal flag, log it, and let handlePttStop() trigger the actual removal
- Audit log: AuditAction.PERMISSION_DENIED with metadata including revocation reason

**4. Modify handlePttStop():**
After existing PTT stop logic, check if the channel has a pending removal for this user. If so, trigger handlePermissionRevocation with force=true.

**5. Add audit logging to existing handlers:**
- handlePttStart success: AuditAction.PTT_START
- handlePttStart denied: AuditAction.PTT_DENIED
- handlePttStop: AuditAction.PTT_STOP
- handleLeaveChannel: AuditAction.CHANNEL_LEAVE
- handleDisconnect: AuditAction.AUTH_LOGOUT

Keep all existing error handling and logging intact. Add audit logging alongside (not replacing) existing logger.info calls.

**6. Track pending removals:**
Add a private Map: `pendingChannelRemovals = new Map<string, Set<string>>()` keyed by `userId` with a set of channelIds pending removal after PTT completes.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify that handleJoinChannel includes permission check BEFORE session store operations. Verify audit logging is present in join, PTT start/stop, leave, and disconnect handlers. Verify handlePermissionRevocation method exists.
  </verify>
  <done>
Channel join checks ctx.authorizedChannels (Admin bypasses). Channel user limit enforced. Simultaneous channel limit enforced with exact error message per user decision. Graceful permission revocation: pending removals tracked, PTT_STOP triggers deferred removal. All handlers audit log their actions. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. A user with role GENERAL and channelIds ['ch1', 'ch2'] can join ch1 but not ch3
3. An ADMIN user can join any channel in their event
4. Heartbeat refreshes permissions from Redis every 30 seconds
5. Revoking a channel while user is transmitting: user finishes PTT, then is removed
6. Audit log entries created for join, join-denied, PTT start/stop/denied, leave, disconnect
7. Rate limiting rejects excessive connections with 429
</verification>

<success_criteria>
- SEC-03 satisfied: User authorization checked before channel access
- AUTH-08 partially satisfied: General user can only access assigned channels
- Heartbeat permission refresh catches real-time revocations
- Graceful removal preserves audio quality during revocation
- Full audit trail for all auth events
</success_criteria>

<output>
After completion, create `.planning/phases/02-user-management-access-control/02-03-SUMMARY.md`
</output>
