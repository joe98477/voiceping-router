---
phase: 02-user-management-access-control
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/server/state/permissionSync.ts
  - src/server/state/channelState.ts
autonomous: true

must_haves:
  truths:
    - "When control-plane changes channel assignments, the router receives the update in real-time via Redis pub/sub"
    - "Connected users automatically receive new channels and lose revoked channels without reconnecting"
    - "Permission changes propagate within seconds, not minutes"
  artifacts:
    - path: "src/server/state/permissionSync.ts"
      provides: "Redis pub/sub subscription for membership updates from control-plane"
      exports: ["PermissionSyncManager"]
    - path: "src/server/state/channelState.ts"
      provides: "Enhanced channel state with event association"
  key_links:
    - from: "src/server/state/permissionSync.ts"
      to: "control-plane/src/index.js"
      via: "Redis pub/sub channel vp:membership_updates"
      pattern: "subscribe.*vp:membership_updates"
    - from: "src/server/state/permissionSync.ts"
      to: "src/server/signaling/websocketServer.ts"
      via: "Callback to push permission updates to connected clients"
      pattern: "onPermissionChange"
---

<objective>
Create a real-time permission synchronization system that subscribes to Redis pub/sub channel `vp:membership_updates` (already published by control-plane's recomputeUserMembership function) and pushes permission changes to connected WebSocket clients immediately. This bridges the control-plane and router in real-time.

Purpose: The heartbeat catches permission changes every 30 seconds, but Redis pub/sub provides near-instant propagation. When a Dispatch user assigns someone to a new channel via the control-plane UI, that user sees the channel appear in their client within seconds, not 30 seconds.
Output: PermissionSyncManager that subscribes to Redis pub/sub and triggers real-time permission updates to connected clients.
</objective>

<execution_context>
@C:\Users\jotha\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jotha\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-user-management-access-control/02-CONTEXT.md
@.planning/phases/02-user-management-access-control/02-RESEARCH.md
@.planning/phases/02-user-management-access-control/02-01-SUMMARY.md
@src/server/state/channelState.ts
@src/server/state/redisClient.ts
@control-plane/src/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PermissionSyncManager for real-time membership updates via Redis pub/sub</name>
  <files>
    src/server/state/permissionSync.ts
  </files>
  <action>
Create src/server/state/permissionSync.ts that subscribes to the existing Redis pub/sub channel used by control-plane.

The control-plane already publishes on `vp:membership_updates` with this payload (from control-plane/src/index.js line 500-508):
```json
{
  "eventId": "...",
  "userId": "...",
  "channelIds": ["ch1", "ch2", "ch3"],
  "action": "set_user_channels"
}
```

**PermissionSyncManager class:**

1. **Constructor:** Accept a callback function `onPermissionChange(userId: string, eventId: string, newChannelIds: string[], action: string) -> void`. This callback will be invoked when the control-plane publishes a membership update.

2. **start() -> void:** Create a dedicated Redis pub/sub subscriber client (separate from the main Redis client, as required by Redis v4 for pub/sub -- this pattern is already established in channelState.ts). Subscribe to `vp:membership_updates`.

3. **Message handler:** On receiving a message from the subscription:
   - Parse JSON payload
   - Extract userId, eventId, channelIds, action
   - Call the onPermissionChange callback with these values
   - Log the event: "Permission update received for user {userId}: {action}"

4. **stop() -> void:** Unsubscribe from the channel and disconnect the subscriber client.

5. **Error handling:** If pub/sub connection fails, log error but don't crash. Retry connection with exponential backoff (reuse the 1s/2s/4s/8s/16s/30s pattern from Phase 1 reconnection). The heartbeat-based permission refresh serves as fallback if pub/sub is down.

Use the established pattern from channelState.ts for creating a dedicated pub/sub client. Use `createLogger('PermissionSync')` for logging.

The callback pattern decouples this from the WebSocket server -- the index.ts (server entry point) will wire the callback to push PERMISSION_UPDATE messages to connected clients. This wiring happens in Plan 07 (integration).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify the file exports PermissionSyncManager class. Verify it subscribes to 'vp:membership_updates' channel. Verify error handling includes retry logic.
  </verify>
  <done>
PermissionSyncManager subscribes to vp:membership_updates via dedicated Redis pub/sub client. Parses control-plane's membership update payloads. Calls onPermissionChange callback with userId, eventId, channelIds, action. Retry on connection failure. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance channel state manager with event association and multi-user tracking</name>
  <files>
    src/server/state/channelState.ts
  </files>
  <action>
Extend src/server/state/channelState.ts with capabilities needed for Phase 2 role enforcement:

**1. Add event-channel association tracking:**
Add method `setChannelEvent(channelId: string, eventId: string) -> void`: Store in Redis hash `channel:events` mapping channelId -> eventId. Called when a channel is first joined (the eventId comes from the user's JWT context).

Add method `getChannelEvent(channelId: string) -> string | null`: Look up which event a channel belongs to.

**2. Add active speakers tracking per event:**
Add method `getEventActiveSpeakers(eventId: string) -> Map<string, string>`: Returns a map of channelId -> userId for all currently active speakers in an event. This is needed for emergency broadcast (must pause ALL active speakers in the event).

Implementation: Iterate over all channel states for channels belonging to the event (use channel:events hash). For each channel that has a currentSpeaker, add to the map.

**3. Add method for bulk speaker management:**
Add method `pauseAllSpeakers(eventId: string) -> string[]`: Returns list of channelIds where speakers were active. For each channel in the event that has an active speaker, call stopPtt. This is needed for emergency broadcast preparation.

Add method `getChannelsForEvent(eventId: string) -> string[]`: Returns all channel IDs associated with an event from the Redis channel:events hash.

**4. Keep all existing methods intact.** The existing subscribeToChannel, startPtt, stopPtt, getChannelState etc. remain unchanged. These new methods are purely additive.

Use the existing Redis client getter pattern. Use createLogger('ChannelState') (already in use).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify that channelState.ts now has setChannelEvent, getChannelEvent, getEventActiveSpeakers, pauseAllSpeakers, getChannelsForEvent methods. Verify existing tests still pass if any exist (check with `npx vitest run` or `npm test`).
  </verify>
  <done>
ChannelStateManager has event-channel association tracking (channel:events hash), getEventActiveSpeakers for emergency broadcast preparation, pauseAllSpeakers for bulk speaker interruption, and getChannelsForEvent for event-scoped operations. All existing methods unchanged. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. PermissionSyncManager subscribes to vp:membership_updates pub/sub channel
3. ChannelStateManager can track channel-event associations
4. getEventActiveSpeakers returns correct map of active speakers
5. pauseAllSpeakers stops all active speakers in an event
</verification>

<success_criteria>
- Real-time permission changes from control-plane reach the router via Redis pub/sub
- Event-scoped channel operations support emergency broadcast and force-disconnect
- Fallback to heartbeat refresh if pub/sub is temporarily unavailable
- All existing channel state functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/02-user-management-access-control/02-04-SUMMARY.md`
</output>
